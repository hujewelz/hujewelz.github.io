<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Run Loop</title>
    <url>/ck9grdnz30000eyyee0ft8nmw/</url>
    <content><![CDATA[<p>本文并不是一篇个人博客，只是对 RunLoop 知识的一个整理，方便自己查阅。</p>
<ol>
<li>RunLoop 的概念</li>
<li>RunLoop 与线程的关系</li>
<li>RunLoop 的内部<ol>
<li>RunLoop 的 Mode</li>
<li>RunLoop 的内部逻辑</li>
</ol>
</li>
<li>苹果用 RunLoop 实现的功能</li>
<li>RunLoop 的实际应用举例</li>
</ol>
<!-- excerpt -->

<p>本文并不是一篇个人博客，只是对 RunLoop 知识的一个整理，方便自己查阅。点击<a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="noopener">这里</a>可以查看原文。</p>
<!-- toc -->
<h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        auto message &#x3D; get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message !&#x3D; quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模型通常被称作 Event Loop ，实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，Run Loop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部<br>“接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。<p></p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>iOS 开发中能遇到两个线程对象: <code>pthread_t</code> 和 <code>NSThread</code>。你可以通过 <code>pthread_main_np()</code> 或 <code>[NSThread mainThread]</code> 来获取主线程；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取当前线程。<code>CFRunLoop</code> 是基于 <code>pthread</code> 来管理的。苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</span><br><span class="line"><span class="comment">// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop-的内部"><a href="#RunLoop-的内部" class="headerlink" title="RunLoop 的内部"></a>RunLoop 的内部</h2><p>在 Core Foundation 中关于 RunLoop 有5个类</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png" alt=""><br>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong>是事件产生的地方。Source有两个版本：source0 和 source1。</p>
<ul>
<li>source0 只包含了一个回调，它并不能主动触发时间。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 Run Loop，让其处理这个事件。</li>
<li>source1 包含了一个mach_prot和一个回调，被用于通过内核和其他线程进行通信，接收分发系统事件。这种 source 能主动唤醒 Run Loop 的线程。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong>是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调。当其加入到 Run Loop 时，Run Loop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调，当 Run Loop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         &#x3D; (1UL &lt;&lt; 0), &#x2F;&#x2F; 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  &#x3D; (1UL &lt;&lt; 1), &#x2F;&#x2F; 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources &#x3D; (1UL &lt;&lt; 2), &#x2F;&#x2F; 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting &#x3D; (1UL &lt;&lt; 5), &#x2F;&#x2F; 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  &#x3D; (1UL &lt;&lt; 6), &#x2F;&#x2F; 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          &#x3D; (1UL &lt;&lt; 7), &#x2F;&#x2F; 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 Run Loop 会直接退出，不进入循环。</p>
<h3 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h3><p>CFRunLoop 的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     &#x2F;&#x2F; Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; &#x2F;&#x2F; Set</span><br><span class="line">    CFRunLoopModeRef _currentMode;    &#x2F;&#x2F; Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           &#x2F;&#x2F; Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个 <code>_commonModes</code>，一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 Run Loop 的内容发生变化时，Run Loop 都会自动将 <code>_commonModeItems</code> 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有 Mode 里。</p>
<p>主线程的 Run Loop 里有两个预置的 Mode：<code>kCFRunLoopDefaultMode</code> 和 <code>UITrackingRunLoopMode</code>。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，Run Loop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 Run Loop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。</p>
<h3 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h3><p>根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下：<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png" alt=""><br>其内部代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 用DefaultMode启动Run Loop</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 用指定的Mode启动，允许设置Run Loop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode &#x3D; __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 如果mode里没有source&#x2F;timer&#x2F;observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop &#x3D; NO;</span><br><span class="line">        int retVal &#x3D; 0;</span><br><span class="line">        do &#123;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop &#x3D; __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg &#x3D; __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 一个基于 port 的Source 的事件。</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 一个 Timer 到时间了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? RunLoop 自身的超时时间到了</span><br><span class="line">            &#x2F;&#x2F;&#x2F; ? 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); &#x2F;&#x2F; thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 &#x3D; __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop &#x3D; __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 超出传入参数标记的超时时间了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; 被外部调用者强制停止了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                &#x2F;&#x2F;&#x2F; source&#x2F;timer&#x2F;observer一个都没有了</span><br><span class="line">                retVal &#x3D; kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;&#x2F; 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal &#x3D;&#x3D; 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上 Run Loop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 </p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。<br><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 Run Loop 中。所以如果当前线程没有 Run Loop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code>时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。</p>
<h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 Run Loop 是用 <code>dispatch_source_t</code> 实现的 Timer。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 <code>dispatch_async()</code>。</p>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 <code>[connection start]</code> 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。<code>CFMultiplexerSource</code> 是负责各种 Delegate 回调的，<code>CFHTTPCookieStorage</code> 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：<code>com.apple.NSURLConnectionLoader</code> 和 <code>com.apple.CFSocket.private</code>。其中 CFSocket 线程是处理底层 socket 连接的。<code>NSURLConnectionLoader</code> 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 <code>Source0</code> 通知到上层的 Delegate。</p>
<p><img src="http://cc.cocimg.com/api/uploads/20150528/1432799200369980.png" alt=""></p>
<p><code>NSURLConnectionLoader</code> 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 <code>CFSocket</code> 的通知。当收到通知后，其会在合适的时机向 <code>CFMultiplexerSource</code> 等 <code>Source0</code> 发送通知，同时唤醒 Delegate 线程的 Run Loop 来让其处理这些通知。<code>CFMultiplexerSource</code> 会在 Delegate 线程的 Run Loop 对 Delegate 执行实际的回调。</p>
<h2 id="Run-Loop-的实际应用"><a href="#Run-Loop-的实际应用" class="headerlink" title="Run Loop 的实际应用"></a>Run Loop 的实际应用</h2><h3 id="创建常驻线程"><a href="#创建常驻线程" class="headerlink" title="创建常驻线程"></a>创建常驻线程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  self.thread &#x3D; [[NSThread alloc] initWithTarget:self selector:@selector(run) object:nil];</span><br><span class="line">  [_thread start];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (void)run &#123;</span><br><span class="line">  [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">  [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift与函数式编程的那些事</title>
    <url>/ck9grdnzg0002eyyefbpa6ftj/</url>
    <content><![CDATA[<p>函数式编程所依赖的原理，在很多方面其实是早于编程本身出现的。因为函数式编程这种范式依赖于 Alonzo Church 在20世纪30年代发明的 <a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">λ演算</a>。<br> <a id="more"></a><br>λ 演算的一个核心思想是不可变性——某个符合所对应的值永远是不变的。所以从理论上来讲，函数式编程语言中应该是没有赋值语句的。</p>
<p>本文是 Swift 系列文章中的第三篇，前两篇文章分别是：<a href="http://jewelz.me/cjt0zq7ce0006620o0nhutb0j/" target="_blank" rel="noopener">Swift 与面向协议编程的那些事</a>，<a href="">在 Swift 中使用值类型</a>。按照计划，这篇文章主要介绍一下函数式编程思想在 Swift 中的应用。</p>
<p>函数式编程所依赖的原理，在很多方面其实是早于编程本身出现的。因为函数式编程这种范式依赖于 Alonzo Church 在20世纪30年代发明的 <a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">λ演算</a>。 λ 演算的一个核心思想是不可变性——某个符合所对应的值永远是不变的。所以从理论上来讲，函数式编程语言中应该是没有赋值语句的。</p>
<p>函数式编程在维基百科中的定义是：<strong>函数式编程</strong>（functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将计算机运算视为函数运算，并且避免使用程序状态以及易变对象。其中，<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97" target="_blank" rel="noopener">λ演算</a>为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p>
<h2 id="计算数组元素之和"><a href="#计算数组元素之和" class="headerlink" title="计算数组元素之和"></a>计算数组元素之和</h2><p>我们最好还是用一个例子来解释什么是函数式编程。请看下面的这个例子：这段代码想要输出整型数组中所有元素的和。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(of arr: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(of: <span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>)) <span class="comment">// result: 55</span></span><br></pre></td></tr></table></figure>

<p>下面我们改用 Swift 标准库中提供的函数来写这个程序，其代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, +) <span class="comment">// result: 55</span></span><br></pre></td></tr></table></figure>

<p>这里我们直接调用数组的 <code>reduce</code> 方法，该方法接受一个初始值和一个闭包（就是一个匿名函数），最终将结果返回。如果从来没有接触过函数式可能觉得这段代码看起来很奇怪。没关系，我们可以把这段代码改得完整一点，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, &#123; result, ele <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> result + ele</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>reduce</code> 方法第二个参数接受一个函数，为了简单起见，我们只管 Int 型数据，那么其形式可能是这样：<code>(Int, Int) -&gt; Int</code> 。如果我们编写了一个像下面这样的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNums</span><span class="params">(x: Int, y: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，将它作为参数传给 <code>reduce</code> ，这样仍然能得到我们想要的结果，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">reduce</span>(<span class="number">0</span>, addTowNums) <span class="comment">// result: 55</span></span><br></pre></td></tr></table></figure>

<p>因为Swift 标准库中 Int 实现了 <code>+</code> 运算符，它其实就是个函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Int</span> : <span class="title">FixedWidthInteger</span>, <span class="title">SignedInteger</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> + <span class="params">(lhs: Int, rhs: Int)</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以上面的代码中可以将 <code>+</code> 作为函数传给 <code>reduce</code>。如果你想实现数组元素相乘，那么你就可以把 <code>*</code> 作为函数传给 <code>reduce</code>。正是得益于 Swift 中函数式的特性，我们才能将 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 等普通操作符（在 Swift 中其实就是函数了）作为函数传给 <code>reduce</code>。</p>
<h2 id="不可变性与软件架构"><a href="#不可变性与软件架构" class="headerlink" title="不可变性与软件架构"></a>不可变性与软件架构</h2><p>在上面的代码中，我们为什么说 <code>+</code> 具有函数式的特性？因为它符合函数式的一个核心思想：不可变性。对于 <code>+</code> 来说，它没有改变任何外部变量，而且不管你在什么地方，即使是并发环境下，只要传入的值一样，其结果永远都是一样的。如果一个函数，即使其返回结果永远不变，但是它改变了外部变量，它仍然不能说是函数式的。因为它仍然是可变的。</p>
<p>对于函数式编程，我们可以简单地归纳有以下特征：</p>
<ul>
<li><p>只用 “表达式”，不用 “语句”</p>
<p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；”语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>
</li>
<li><p>没有”副作用”</p>
<p>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。</p>
<p>函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p>
</li>
<li><p>不修改状态</p>
<p>上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。</p>
<p>在其他类型的语言中，变量往往用来保存”状态”（state）。不修改变量，意味着状态不能保存在变量中。</p>
</li>
<li><p>引用透明</p>
<p>函数程序通常还加强引用透明性，即如果提供同样的输入，那么函数总是返回同样的结果。就是说，表达式的值不依赖于可以改变值的全局状态。这使您可以从形式上推断程序行为，因为表达式的意义只取决于其子表达式而不是计算顺序或者其他表达式的副作用。这有助于验证正确性、简化算法，甚至有助于找出优化它的方法。</p>
</li>
</ul>
<p>从以上函数式编程的特征来看，它们的共同作用最终导致一个结果：不可变性。</p>
<p>为什么不可变性是软件架构设计需要考虑的重点呢？为什么软件架构师要操心变量的可变性呢？答案显而易见：所有的竞争问题、死锁问题、并发问题都是由可变变量导致的。如果变量永远不会被更改，那么就不可能产生竞争或者并发问题。如果锁的状态是不可变的，那么永远就不会产生死锁问题。</p>
<p>在函数式编程中，由于数据全部都是不可变的，所以没有并发编程的问题，是多线程安全的。可以有效降低程序运行中所产生的副作用，对于快速迭代的项目来说，函数式编程可以实现函数与函数之间的热切换而不用担心数据的问题，因为它是以函数作为最小单位的，只要函数与函数之间的关系正确即可保证结果的正确性。</p>
<h2 id="map、flatMap-与函数式"><a href="#map、flatMap-与函数式" class="headerlink" title="map、flatMap 与函数式"></a>map、flatMap 与函数式</h2><p>map 是我们在使用数组是经常使用的方法，如果我们想将数组中的每个元素做个变换，就会使用到它。例如我们想将一个整形数组中的每个元素做平方操作，就可以这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">map</span> &#123; $<span class="number">0</span> * $<span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<p>map 方法接受一个闭包作为参数，然后它会遍历整个数组，并对数组中的每个元素执行闭包中的操作，最后返回一个新数组，上面例子中将每个元素做平方，所以最后返的新数组就是：<code>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</code></p>
<p>下面我们可以看一下 map 在 Array 中的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>对 <code>rethrows</code> 关键字不是很了解的同学可以看看<a href="http://jewelz.me/cjt0zq7cf0008620oknjdqsx7/" target="_blank" rel="noopener">这篇文章</a>，这里我们可以忽略它，我们主要把关注点放到 <code>(Element) -&gt; T</code> 这个闭包的定义上。我们可以看到，该闭包接受的参数类型跟我们数组中元素的类型是一致的，其返回类型跟我们最终想得到的数据中元素的类型是一样的。也就是说我们可以使用 map 方法将某个类型的数组转换成完全另一种类型的数组，例如下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringArr = <span class="type">Array</span>(<span class="number">1</span>...<span class="number">3</span>).<span class="built_in">map</span> &#123; <span class="string">"No.\($0)"</span> &#125;  <span class="comment">//["No.1", "No.2", "No.3"]</span></span><br></pre></td></tr></table></figure>

<p>知道了 map 方法做的事情后，我们就很容易地实现我们的 map，代码可以像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            result.append(<span class="keyword">try</span> transform(ele))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这行代码 <code>result.append(try transform(ele))</code> 就是 map 方法的核心，这就是上面说的 map 对数组中的每个元素执行闭包中的操作。</p>
<p>如果你常用 Swift 的话， 还会发现除了数组定义了 map 方法， 同样 Optional 也存在这个方法。请看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> time: <span class="type">String?</span> = <span class="string">"2018-01-01"</span></span><br><span class="line"></span><br><span class="line">label.text = time.<span class="built_in">map</span>&#123; <span class="string">"时间：\($0)"</span>&#125;  <span class="comment">// "时间：2018-01-01"</span></span><br></pre></td></tr></table></figure>

<p>上面的代码经常会出现在我的项目中。<code>time</code> 是定义在一个结构体或类中，它的值是由服务器返回的，所以对于它的值我们不能确定，所以一般我定义成可选型，最终我们要在界面上显示成 <code>时间：xxxx-xx-xx</code> 的样式，我们得在服务器返回的字符串前面加上 <code>时间：</code>，如果你直接 <code>&quot;时间：\(time)&quot;}</code> 肯定是不行的，因为 <code>time</code> 是可选型，在使用时你得先解包，这样我们就得写一串处理 <code>time</code> 的代码（当然这里处理代码也很短，其它情况可能就比较长了），这样看起来非常繁琐。使用 <code>map</code> 方法就使得我们的代码干净简洁了很多。</p>
<p>我们可以看一下 Optional 中 map 的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U?</span></span><br></pre></td></tr></table></figure>

<p>你再回去看一下 Array 中 map 的定义，你会发现二者几乎没有区别。Array 中 返回的是一个数组 ，这里返回的是 可选型的值，这里看似没有任何联系，如果你把数组和可选型当成一种包装类型，你会发现它们是一样的，所以才有了 <code>map</code> 这个相同的行为。</p>
<p>那么什么是包装类型的值呢，你可以简单地理解为包含了多个值的一种值，例如数组，你可以通过一个数组变量访问到数组中的任何一个值，而对于可选型，也是一样的，你可以访问到一个 nil 值，或者一个解包后的值。像标准库中的 <code>String</code>, <code>Dictionary</code> 等都可以看做包装值，而且它们都有实现 <code>map</code>。</p>
<p><code>flatMap</code> 在使用上和 <code>map</code> 非常相似，如果你不仔细观察的话，你甚至都发现不了它们之间的区别。我们先看一下 <code>flatMap</code> 在 Optional 中的定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U?</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U?</span></span><br></pre></td></tr></table></figure>

<p>你仔细看的话，你会发现它与 map 的区别，flatMap 接受的闭包的返回类型是 <code>U?</code>，而 map 中的是 <code>U</code>，这就是它们在方法签名上唯一的区别。也就是说，<code>map</code> 中闭包返回值不能是可选型，而 <code>flatMap</code> 可以。如果你把它替换成上面包装值的概念，那就是 flatMap 中的闭包的返回值也是个包装值。</p>
<p>我们可以看一下数组中 <code>map</code> 和 <code>flatMap</code> 的区别是怎样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">SegmentOfResult</span> : <span class="type">Sequence</span></span><br></pre></td></tr></table></figure>

<p>虽然 <code>flatMap</code> 的方法签名比 <code>map</code> 复杂了很多，但是主要区别也是体现在闭包返回值类型上，<code>map</code> 中返回值是 T 的单一类型，而 <code>flatMap</code> 返回的是一个 Sequence，这里你可以简单理解为数组。对比上面 Optional 中 <code>map</code> 和 <code>flatMap</code> 的区别，你会发现它们都区别是一致的。</p>
<p>运行下面的代码，你就能更清楚的看到它们都区别了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">let</span> mapedArr = array.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">map</span>&#123; $<span class="number">0</span> * $<span class="number">0</span>&#125; &#125;          <span class="comment">// [[1, 4], [9, 16]]</span></span><br><span class="line"><span class="keyword">let</span> flatMapedArr = array.flatMap &#123; $<span class="number">0</span>.<span class="built_in">map</span>&#123; $<span class="number">0</span> * $<span class="number">0</span>&#125; &#125;  <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么这样设计"><a href="#为什么这样设计" class="headerlink" title="为什么这样设计"></a>为什么这样设计</h3><p>看到这里， 大家可能会产生疑问了。 为什么会多出个 <code>flatMap</code> 函数？这其实涉及另外一个维度的概念， Functors 和 Monads。 明白这个概念之后，你就会发现这其中的关联，以及为什么会有 <code>map</code> 和 <code>flatMap</code> 这两个函数存在了。</p>
<h4 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h4><p>在讲 functors和 monads 时，我们需要用到上面讲 Array 和 Optional 联系时用到的包装值的概念。</p>
<p>其实 简单来说，Functors 就是将包装值直接传递给函数的一种行为。 对应到我们的代码上，就是 <code>map</code> 函数了, 看下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(<span class="number">_</span> val: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> val * val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(<span class="number">10</span>) <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">var</span> optionalVal: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line">square(optionalVal) <span class="comment">// Value of optional type 'Int?' not unwrapped; did you mean to use '!' or '?'?</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们想求一个整数的平方，对于一个可选类型的值来说，我们必须将它解包后，才能传入 <code>square</code> 函数中。我们虽然不能直接把 optionalVal 直接传递给 <code>square</code> 函数，但是我们可以使用 map 将 <code>square</code> 最为参数传递进来，这就相当于间接地将 <code>optionalVal</code> 传递给 <code>square</code> 函数。就像下面代码中那样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">optionalVal.<span class="built_in">map</span>(square)</span><br></pre></td></tr></table></figure>

<p>同样地，我们把数组也看做一个包装值，虽然不能直接将数组传递给 <code>square</code> 函数，但是我们使用 map 仍然能将数组中的值传递给 <code>square</code> 函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">map</span>(square)</span><br></pre></td></tr></table></figure>

<p>总的来说 Functors 就是将一个<strong>包装值</strong>直接传递给函数，并且返回的结果依然是包装值的一种行为。 我们调用 Optional 中的 <code>map</code> 函数， 会用闭包将 Optional 中的值进行操作，然后返回值还是一个 Optional。</p>
<p>同样，我们对数组调用 <code>map</code> 函数， 会用闭包将数组中的值进行一些操作， 然后返回值还是一个数组。</p>
<p>从这个维度来思考，就能理解为什么 Optional 和数组，这两个看似没有任何关联的类型，为什么都有 <code>map</code> 和 <code>flatMap</code> 方法了。</p>
<h4 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h4><p>如果说 Functors 对应的是 <code>map</code> 函数， 那么 Monads 对应的就是 <code>flatMap</code> 函数啦。</p>
<p>Monads 用一句话来说就是， 它将一个<strong>包装值</strong>传递给一个返回值类型是<strong>包装值</strong>的函数。注意 monads 强调的是<strong>返回值类型是包装值的函数</strong> 。</p>
<p>Optional 的 <code>flatMap</code> 函数接受的闭包是 (Wrapped) -&gt; U?， 它返回的还是 Optional 类型。 数组的 flatMap 接受的闭包是 <code>(Element) -&gt; SegmentOfResult</code>，这里 <code>SegmentOfResult</code> 必须是 Sequence， 返回的依然还是数组。</p>
<p><code>map</code> 和 <code>flatMap</code> 的主要区别就是他们所接受闭包的返回类型， <code>map</code> 的闭包返回的是一个普通值， <code>flatMap</code> 的闭包返回的是一个包装值。</p>
<p>下面给出一个 monads 在实际中运用的例子：在下面代码中，在第一个请求返回后，我们拿到结果并发起第二个请求。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Provider</span>&lt;<span class="type">UserApi</span>&gt;(.users)</span><br><span class="line">    .flatMap &#123; response -&gt; <span class="type">Provider</span>&lt;<span class="type">UserApi</span>&gt; <span class="keyword">in</span></span><br><span class="line">     	<span class="keyword">let</span> res = response.array.first <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">        <span class="keyword">let</span> user = <span class="type">User</span>(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Provider</span>(.detail(user.name))</span><br><span class="line">    &#125;</span><br><span class="line">    .request &#123; response <span class="keyword">in</span></span><br><span class="line">    	<span class="built_in">print</span>(response)</span><br><span class="line">    &#125;.addToCancelBag()</span><br></pre></td></tr></table></figure>

<p>这里的 Provider 就是一个包装值，它的 <code>flatMap</code> 接受的闭包的返回类型就是另一个包装值。这完全符合 monads 的定义。</p>
<p>Functors 和 Monads 并不是 Swift 中独有的，它们是一种数学概念。而在函数式编程中，你经常会看到它们都身影。只有是<strong>把包装值传递给函数，并且返回的结果依然是包装值</strong>的行为就是 functors，<strong>把包装值传递给一个返回值类型是包装值的函数</strong>的行为就是 Monads。</p>
<h2 id="与函数式"><a href="#与函数式" class="headerlink" title="?? 与函数式"></a>?? 与函数式</h2><p>如果你对 Swift 中的可选类型 (Optional) 用的比较多的话，那么你可能会经常用到 <code>??</code> 这个操作符，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int?</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a ="</span>, a ?? <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p><code>??</code> 操作符左边是一个 Optional值，右边是一个普通值，它的作用就是，如果左边的 Optional 值为 <code>nil</code>， 那么就使用右边的值作为结果，如果左边的 Optional 不为 <code>nil</code>，则返回左边的 Optional 解包后的值，就像下面代码展示的那样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a: <span class="type">Int?</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a ="</span>, a == <span class="literal">nil</span> ? <span class="number">100</span> : a!)</span><br></pre></td></tr></table></figure>

<p>事情真的是这么简单吗？在回答这个问题前，我们可以先自己实现一个 <code>??</code>，为了跟系统的进行区分，这里我们把新函数定义为 <code>???</code>，为了实现我们的 <code>???</code> 函数，就必须使用自定义操作符。最终的代码就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ???: <span class="type">AdditionPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> ??? &lt;T&gt; <span class="params">(<span class="keyword">optional</span>: T?, defaultValue: T)</span></span> -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="keyword">optional</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> defaultValue &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a ="</span>, a ??? <span class="number">100</span>) <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>目前看起来好像跟标准库中 <code>??</code> 的结果是一模一样的，不过先不要着急，我们可以把 <code>??</code> 和我们的 <code>???</code> 右边替换成一个函数，代码是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...<span class="number">10000</span> &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a: <span class="type">Int?</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b1 = clock()</span><br><span class="line"><span class="keyword">let</span> result = a ?? doSomething()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"time1: "</span>, clock() - b1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b2 = clock()</span><br><span class="line"><span class="keyword">let</span> result2 = a ??? doSomething()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"time2: "</span>, clock() - b2)</span><br></pre></td></tr></table></figure>

<p>为了测试  <code>??</code> 和我们的 <code>???</code>的性能，我简单地记录了这两个调用的时间，下面是其中一次的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time1:  206</span><br><span class="line">time2:  254042</span><br></pre></td></tr></table></figure>

<p>不过你执行多少次，你都能得出一个结果：<code>??</code> 调用比<code>???</code> 调用快了很多。为什么会出现这种情况，我们的 <code>???</code> 到底有什么问题呢？如果你在 <code>doSomething</code> 函数中打个断点，你会发现，它只在 <code>???</code> 调用时才会执行。也就是说 <code>??</code> 函数在判断了第一个值不为 nil 时，不会调用第二个表达式。而我们在调用 <code>???</code> 之前，就必须先把右边的数据准备好，这样不管左边的值是不是 nil，右边的表达式都会调用。所以才有了上面的区别。那么系统是怎么做到这样的呢？我们很容易就想到，把右边的值替换成一个函数，就可以办到。代码就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ??? &lt;T&gt; <span class="params">(<span class="keyword">optional</span>: T?, defaultValue: <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> value = <span class="keyword">optional</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> defaultValue() &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result2 = a ??? doSomething</span><br></pre></td></tr></table></figure>

<p>再次运行，你会发现 <code>doSomething</code> 函数没有再执行了。细心的同学可能会发现，这里调用 <code>???</code> 跟调用 <code>??</code> 有点区别，在 <code>??</code> 的调用中，右边是 <code>doSomethin()</code>，而我们的 <code>???</code> 右边是 <code>doSomething</code>。这里其实使用了一个叫做自动闭包的东西，我们在闭包前面加上 <code>@autoclosure</code> 关键字，就能让我们的普通闭包变成自动闭包。使用自动闭包的好处是编译器会自动把一个值转成闭包。当然，自动闭包是有一定限制的，只能作用在没有参数的闭包上。我们把代码修改一下就可以跟调用 <code>??</code> 一样，使用我们的 <code>???</code> 了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> ??? &lt;T&gt; <span class="params">(<span class="keyword">optional</span>: T?, defaultValue: @autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">T</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这里花这么多时间讲 <code>??</code> 操作符，其实是为了体现函数式的另一个特征，那就是惰性计算。从上面的例子中，可以看出，有与没有惰性计算，在程序性能上还是有很大差别的。上面只是简单的做了 10000 次循环，运行时间就差了百倍。如果这是个耗时操作，那么这种优化就可以大大地提高程序性能。</p>
<p>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算使您可以编写更高性能和避免可能潜在地生成无穷输出的函数。因为它不会计算多于程序的其余部分所需要的值，所以不需要担心由于表达式执行耗时操作所带来的性能问题或由无穷计算所导致的 out-of-memory 错误。</p>
<p>上面就是我对函数式编程的一些思考，因为篇幅有限，很多东西不能展开来讲。如果同学们能从我这篇文章中得到一点启发，那么这篇文章也就能提现它的价值了。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>从 Swift 中的序列到类型擦除</title>
    <url>/ck9grdnzn0006eyye9yombb7y/</url>
    <content><![CDATA[<p>如果有这样的一个需求，我希望能像数组一样，用 for 循环遍历一个类或结构体中的所有属性。要实现这样的需求，我们需要让自定义的类型遵守 Sequence 协议。</p>
<a id="more"></a>

<p>如果有这样的一个需求，我希望能像数组一样，用 for 循环遍历一个类或结构体中的所有属性。就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> persion = <span class="type">Persion</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> persion &#123;</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现这样的需求，我们需要让自定义的类型遵守 Sequence 协议。</p>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>Sequence 协议是集合类型结构中的基础。一个序列 (sequence) 代表的是一系列具有相同类型的值，你可以对这些值进行迭代。Sequence 协议提供了许多强大的功能，满足该协议的类型都可以直接使用这些功能。上面这样步进式的迭代元素的能力看起来十分简单，但它却是 Sequence 可以提供这些强大功能的基础。</p>
<p>满足 Sequence 协议的要求十分简单，你需要做的所有事情就是提供一个返回迭代器 (iterator) 的 <code>makeIterator()</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Sequence 协议有个关联类型 Iterator，而且它必须遵守 IteratorProtocol 协议。从这里我们可以看出 Sequence 是一个可以创建迭代器协议的类型。所以在搞清楚它的步进式的迭代元素能力之前，有必要了解一下迭代器是什么。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>序列通过创建一个迭代器来提供对元素的访问。迭代器每次产生一个序列的值，并且当遍历序列时对遍历状态进行管理。在 IteratorProtocol 协议中唯一的一个方法是 next()，这个方法需要在每次被调用时返回序列中的下一个值。当序列被耗尽时，next() 应该返回 nil，不然迭代器就会一直工作下去，直到资源被耗尽为止。</p>
<p>IteratorProtocol 的定义非常简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Element?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关联类型 Element 指定了迭代器产生的值的类型。这里<code>next()</code> 被标记了 mutating，表明了迭代器是可以存在可变的状态的。这里的 mutating 也不是必须的，如果你的迭代器返回的值并没有改变迭代器本身，那么没有 mutating 也是没有任何问题的。 不过几乎所有有意义的迭代器都会要求可变状态，这样它们才能够管理在序列中的当前位置。</p>
<p>对 Sequence 和 IteratorProtocol 有了基础了解后，要实现开头提到的需求就很简单了。比如我想迭代输出一个 Person 实例的所有属性，我们可以这样做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Persion</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> email: <span class="type">String</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">MyIterator</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MyIterator</span>(obj: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Persion 遵守了 Sequence 协议，并返回了一个自定义的迭代器。迭代器的实现也很简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> children: <span class="type">Mirror</span>.<span class="type">Children</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(obj: <span class="type">Persion</span>) &#123;</span><br><span class="line">        children = <span class="type">Mirror</span>(reflecting: obj).children</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child = children.popFirst() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(child.label.wrapped) is \(child.value)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器中的 <code>children</code> 是 <code>AnyCollection&lt;Mirror.Child&gt;</code>  的集合类型，每次迭代返回一个值后，更新 <code>children</code> 这个状态，这样我们的迭代器就可以持续的输出正确的值了，直到输出完 <code>children</code> 中的所有值。</p>
<p>现在可以使用 for 循环输出 Persion 中所有的属性值了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Persion</span>.author &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out put:</span></span><br><span class="line"><span class="comment">// name is jewelz</span></span><br><span class="line"><span class="comment">// age is 23</span></span><br><span class="line"><span class="comment">// email is hujewelz@gmail.com</span></span><br></pre></td></tr></table></figure>

<p>如果现在有另外一个结构体或类也需要迭代输出所以属性呢？，这很好办，让我们的结构体遵守 Sequence 协议，并返回一个我们自定义的迭代器就可以了。这种拷贝代码的方式确实能满足需求，但是如果我们利用协议拓展就能写出更易于维护的代码，类似下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_Iterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> children: <span class="type">Mirror</span>.<span class="type">Children</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(obj: <span class="type">Any</span>) &#123;</span><br><span class="line">        children = <span class="type">Mirror</span>(reflecting: obj).children</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> child = children.popFirst() <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(child.label.wrapped) is \(child.value)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Sequencible</span>: <span class="title">Sequence</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequencible</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; _Iterator &#123;</span><br><span class="line">        <span class="keyword">return</span> _Iterator(obj: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我定义了一个继承 Sequence 的空协议，是为了不影响 Sequence 的默认行为。现在只要我们自定义的类或结构体遵守 Sequencible 就能使用 for 循环输出其所有属性值了。就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span>: <span class="title">Sequencible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Sequence"</span></span><br><span class="line">    <span class="keyword">var</span> author = <span class="type">Persion</span>.author</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表示相同序列的类型"><a href="#表示相同序列的类型" class="headerlink" title="表示相同序列的类型"></a>表示相同序列的类型</h2><p>现在需求又变了，我想将所有遵守了 Sequencible 协议的任何序列存到一个数组中，然后 for 循环遍历数组中的元素，因为数组中的元素都遵守了 Sequencible 协议，所以又可以使用 for 循环输出其所有属性，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> obj &#123;</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这里的 array 应该定义成什么类型呢？定义成 [Any] 类型肯定是不行的，这样的话在循环中得将 item 强转为 Sequencible，那么是否可以定义成  [Sequencible] 类型呢？答案是否定的。当这样定义时编辑器会报出这样的错误：</p>
<blockquote>
<p>Protocol ‘Sequencible’ can only be used as a generic constraint because it has Self or associated type requirements</p>
</blockquote>
<p>熟悉 Swift 协议的同学应该对这个报错比较熟了。就是说含有 Self 或者关联类型的协议，只能被当作泛型约束使用。所以像下面这样定义我们的 array 是行不通的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sequencibleStore: [<span class="type">Sequencible</span>] = [<span class="type">Persion</span>.author, <span class="type">Demo</span>()]</span><br></pre></td></tr></table></figure>

<p>如果有这样一个类型，可以隐藏 Sequencible 这个具体的类型不就解决这个问题了吗？这种将指定类型移除的过程，就被称为类型擦除。</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>回想一下  Sequence 协议的内容，我们只要通过 <code>makeIterator()</code> 返回一个迭代器就可以了。那么我们可以实现一个封装类(结构体也是一样的)，里面用一个属性存储了迭代器的实现，然后在 <code>makeIterator()</code> 方法中通过存储的这个属性构造一个迭代器。类似这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; _AnyIterator&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> _AnyIterator(iteratorImpl)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的这个封装可以这样定义：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_AnySequence</span>&lt;<span class="title">Element</span>&gt;: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> iteratorImpl: () -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于刚刚上面的那个数组就可以这样初始化了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sequencibleStore: [_AnySequence&lt;<span class="type">String</span>&gt;] = [_AnySequence(<span class="type">Persion</span>.author), _AnySequence(<span class="type">Demo</span>())]</span><br></pre></td></tr></table></figure>

<p>这里的 _AnySequence 就将具体的 Sequence 类型隐藏了，调用者只知道数组中的元素是一个可以迭代输出字符串类型的序列。</p>
<p>现在我们可以一步步来实现上面的 _AnyIterator 和 _AnySequence。_AnyIterator 的实现跟上面提到的 _AnySequence 的思路一致。我们不直接存储迭代器，而是让封装类存储迭代器的 next 函数。要做到这一点，我们必须首先将 iterator 参数复制到一个变量中，这样我们就可以调用它的 next 方法了。下面是具体实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_AnyIterator</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextImpl: () -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">_AnyIterator</span>: <span class="title">IteratorProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">I</span>&gt;(<span class="number">_</span> iterator: <span class="type">I</span>) <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">I</span>.<span class="type">Element</span>, <span class="type">I</span>: <span class="type">IteratorProtocol</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> mutatedIterator = iterator</span><br><span class="line">        nextImpl = &#123; mutatedIterator.next() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextImpl()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在 _AnyIterator 中，迭代器的具体类型（比如上面用到的_Iterator）只有在创建实例的时候被指定。在那之后具体的类型就被隐藏了起来。我们可以使用任意类型的迭代器来创建 _AnyIterator 实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iterator = _AnyIterator(_Iterator(obj: <span class="type">Persion</span>.author))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> item = iterator.next() &#123;</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out put:</span></span><br><span class="line"><span class="comment">// name is jewelz</span></span><br><span class="line"><span class="comment">// age is 23</span></span><br><span class="line"><span class="comment">// email is hujewelz@gmail.com</span></span><br></pre></td></tr></table></figure>

<p>我们希望外面传入一个闭包也能创建一个 _AnyIterator，现在我们添加下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="number">_</span> impl: @escaping () -&gt; <span class="type">Element?</span>) &#123;</span><br><span class="line">    nextImpl = impl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加这个初始化方法其实为了方便后面实现  _AnySequence 用的。上面说过 _AnySequence 有个属性存储了迭代器的实现，所以我们的 _AnyIterator 能通过一个闭包来初始化。</p>
<p>_AnyIterator 实现完后就可以来实现我们的 _AnySequence 了。我这里直接给出代码，同学们可以自己去实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">_AnySequence</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Iterator</span> = _AnyIterator&lt;<span class="type">Element</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> iteratorImpl: () -&gt; <span class="type">Element?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">_AnySequence</span>: <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>&lt;<span class="type">S</span>&gt;(<span class="number">_</span> base: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Iterator</span>.<span class="type">Element</span>, <span class="type">S</span>: <span class="type">Sequence</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> iterator = base.makeIterator()</span><br><span class="line">        iteratorImpl = &#123;</span><br><span class="line">            iterator.next()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; _AnyIterator&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> _AnyIterator(iteratorImpl)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> _AnySequence 的指定构造器也被定义为泛型，接受一个遵循 Sequence 协议的任何序列作为参数，并且规定了这个序列的迭代器的 next() 的返回类型要跟我们定义的这个泛型结构的 Element 类型要一致。这里的这个泛型约束其实就是我们实现类型擦除的魔法所在了。它将具体的序列的类型隐藏了起来，只要序列中的值都是相同的类型就可以当做同一种类型来使用。就像下面的例子中的 array 就可以描述为 “元素类型是 String 的任意序列的集合”。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [_AnySequence(<span class="type">Persion</span>.author), _AnySequence(<span class="type">Demo</span>())]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> obj <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"+-------------------------+"</span>)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> obj &#123;</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out put:</span></span><br><span class="line"><span class="comment">// name is jewelz</span></span><br><span class="line"><span class="comment">//  age is 23</span></span><br><span class="line"><span class="comment">// email is hujewelz@gmail.com</span></span><br><span class="line"><span class="comment">// +-------------------------+</span></span><br><span class="line"><span class="comment">// name is Sequence</span></span><br><span class="line"><span class="comment">// author is Persion(name: "jewelz", age: 23, email: "hujewelz@gmail.com")</span></span><br></pre></td></tr></table></figure>

<p>得益于 Swift 的类型推断，这里的 array 可以不用显式地指明其类型，点击 option 键，你会发现它是 <code>[_AnySequence&lt;String&gt;]</code> 类型。也就是说只有其元素是 String 的任意序列都可以作为数组的元素。这就跟我们平时使用类似 “一个 Int 类型的数组” 的语义是一致的了。如果要向数组中插入一个新元素，可以这样创建一个序列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = _AnySequence &#123; () -&gt; _AnyIterator&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> _AnyIterator &#123; () -&gt; <span class="type">String?</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> arc4random() % <span class="number">10</span> == <span class="number">5</span> ? <span class="literal">nil</span> : <span class="type">String</span>(<span class="type">Int</span>(arc4random() % <span class="number">10</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">array.append(s)</span><br></pre></td></tr></table></figure>

<p>上面的代码中通过一个闭包初始化了一个 _AnySequence，这里我就不给出自己的实现，同学们可以自己动手实现一下。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在标准库中，其实已经提供了 <strong>AnyIterator</strong> 和 <strong>AnySequence</strong>。我还没去看标准库的实现，有兴趣的同学可以点击<a href="https://github.com/apple/swift/tree/master/stdlib/public/core" target="_blank" rel="noopener">这里</a>查看。 我这里实现了自己的 _AnyIterator 和 _AnySequence 就是为了提供一种实现类型擦除的思路。如果你在项目中频繁地使用带有关联类型或 Self 的协议，那么你也一定会遇到跟我一样的问题。这时候实现一个类型擦除的封装，将具体的类型隐藏了起来，你就不用为 Xcode 的报错而抓狂了。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift与面向协议编程的那些事</title>
    <url>/ck9grdnzq0007eyye9rdmah7z/</url>
    <content><![CDATA[<p>一直想写一些 Swift 的东西，却不知道从何写起。因为想写的东西太多，然后所有的东西都混杂在一起，导致什么都写不出来。翻了翻以前在组内分享的一些东西，想想把这些内容整理下，写进博客吧。我对计划要写的东西做了个清单（最近做什么都喜欢在前一天睡觉前做个清单，这样多少改善了我的拖延症🤪）：</p>
<a id="more"></a>

<ul>
<li><input disabled="" type="checkbox"> 面向协议编程</li>
<li><input disabled="" type="checkbox"> 使用值类型代替引用类型</li>
<li><input disabled="" type="checkbox"> 函数式编程</li>
<li><input disabled="" type="checkbox"> 单向数据流</li>
</ul>
<p>面向协议编程是 Swift 不同于其他语言的一个特性之一，也是比 Objective-C 强大的一个语言特性（并不是Swift 独有的，但是比 OC 的协议要强大很多），所以以面向协议编程作为 Swift 系列文章的开端是最合适不过的了。</p>
<p>文章的内容可能有点长，我就把要讲的内容简单地列了一下，同学们可以根据自己掌握的情况，跳到对应的小结进行阅读。下面是主要内容：</p>
<ul>
<li>面向协议编程不是个新概念</li>
<li>Swift 中的协议<ul>
<li>从一个绘图应用开始。通过实现一个绘图应用，来讲解在 Swift 中使用协议</li>
<li>带有 Self 和关联类型的协议<ul>
<li>带有 Self 的协议。通过实现一个二分查找，来讲解如何在协议中使用 Self</li>
<li>带有关联类型的协议。通过实现一个带加载动画的数据加载器，来讲解如何在协议中使用关联类型</li>
</ul>
</li>
<li>协议与函数派发。通过一个使用多态的例子，来讲解函数派发在协议中的表现</li>
</ul>
</li>
<li>使用协议改善既有的代码设计</li>
</ul>
<h2 id="面向协议编程不是个新概念"><a href="#面向协议编程不是个新概念" class="headerlink" title="面向协议编程不是个新概念"></a>面向协议编程不是个新概念</h2><p>面向协议编程并不是一个新概念，它其实就是广为所知的面向接口编程。面向协议编程 (Protocol Oriented Programming) 是 Apple 在 2015 年 WWDC 上提出的 Swift 的一种编程范式。</p>
<p>很多程序员都能理解类、对象、继承和接口这些面向对象的概念（不知道的自己面壁去啊）。可是类与接口的区别何在？有类了干嘛要使用接口？相信很多人都有这样的疑问。接口（协议是同一个东西）定义了类型，实现接口（子类型化）让我们可以用一个对象来代替另一个对象。另一方面，类继承是通过复用父类的功能或者只是简单地共享代码和表述，来定义对象的实现和类型的一种机制。类继承让我们能够从现成的类继承所需要大部分功能，从而快速定义新的类。所以接口侧重的是类型（是把某个类型当做另一种类型来用），而类侧重的是复用。理解了这个区别你就知道在什么时候使用接口，什么时候使用类了。</p>
<p>GoF 在《设计模式》一书中提到了可复用面向对象软件设计的原则：</p>
<blockquote>
<p>针对接口编程，而不是针对实现编程</p>
</blockquote>
<p>定义具有相同接口的类群很重要，因为多态是基于接口的。其他面向对象的编程语言，类如 Java，允许我们定义 “接口”类型，它确定了客户端同所有其他具体类直接到一种 “合约”。Objective-C 和 Swift中与之对应的就是协议（protocol）了。协议也是对象之间的一种合约，但本身是不能够实例化为对象的。实现协议或者从抽象类继承，使得对象共享相同的接口。因此，子类型的所有对象，都可以针对协议或抽象类的接口做出应答。</p>
<h2 id="Swift-中的协议"><a href="#Swift-中的协议" class="headerlink" title="Swift 中的协议"></a>Swift 中的协议</h2><p>在 WWDC2015 上，Apple 发布了Swift 2。新版本包含了很多新的语言特性。在众多改动之中，最引人注意的就是 protocol extensions。在 Swift 第一版中，我们可以通过 extension 来为已有的 class，struct 或 enum 拓展功能。而在 Swift 2 中，我们也可以为 protocol 添加 extension。可能一开始看上去这个新特性并不起眼，实际上 protocol extensions 非常强大，以至于可以改变 Swift 之前的某些编程思想。后面我会给出一个 protocol extension 在实际项目中使用案例。</p>
<p>除了协议拓展，Swift 中的协议还有一些具有其他特性的协议，比如带有关联类型的协议、包含 Self 的协议。这两种协议跟普通的协议还是有一些不同的，后面我也会给出具体的例子。</p>
<p>我们现在可以开始编写代码，来掌握在实际开发中使用 Swift 协议的技巧。下面的绘图应用和二分查找的例子是来自 WWDC2015 中<a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener">这个 Session</a>。在写本文前，笔者也想了很多例子，但是始终觉得没有官方的例子好。所以我的建议是：<a href="https://developer.apple.com/videos/play/wwdc2015/408/" target="_blank" rel="noopener">这个 Session</a> 至少要看一遍。看了一遍后，开始写自己的实现。</p>
<h3 id="从一个绘图应用开始"><a href="#从一个绘图应用开始" class="headerlink" title="从一个绘图应用开始"></a>从一个绘图应用开始</h3><p>现在我们可以先通过完成一个具体的需求，来学习如何在 Swift 中使用协议。</p>
<p>我们的需求是实现一个可以绘制复杂图形的绘图程序，我们可以先通过一个 Render 来定义一个简单的绘制过程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(to p: CGPoint)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"move to (\(p.x), \(p.y))"</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">line</span><span class="params">(to p: CGPoint)</span></span> &#123; <span class="built_in">print</span>(<span class="string">"line to (\(p.x), \(p.y))"</span>)&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">arc</span><span class="params">(at center: CGPoint, radius: CGFloat, starAngle: CGFloat, endAngle: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"arc at center: \(center), radius: \(radius), startAngel: \(starAngle), endAngle: \(endAngle)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以定义一个 Drawable 协议来定义一个绘制操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(with render: Renderer)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Drawable 协议定义了一个绘制操作，它接受一个具体的绘制工具来进行绘图。这里将可绘制的内容和实际的绘制操作分开了，这么做的目的是为了职责分离，在后面你会看到这种设计的好处。</p>
<p>如果我们想绘制一个圆，我们可以很简单地利用上面实现好了的绘制工具来绘制一个圆形，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span>: <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> center: <span class="type">CGPoint</span></span><br><span class="line">    <span class="keyword">let</span> radius: <span class="type">CGFloat</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(with render: Renderer)</span></span> &#123;</span><br><span class="line">        render.arc(at: center, radius: radius, starAngle: <span class="number">0</span>, endAngle: <span class="type">CGFloat</span>.pi * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们又想要绘制一个多边形，那么有了 Drawable 协议，实现起来也非常简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Polygon</span>: <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> corners: [<span class="type">CGPoint</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(with render: Renderer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> corners.isEmpty &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        render.move(to: corners.last!)</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> corners &#123; render.line(to: p) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单图形的绘制已经完成了，现在可以完成我们这个绘图程序了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Diagram</span>: <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> elements: [<span class="type">Drawable</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">draw</span><span class="params">(with render: Renderer)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> elements &#123; ele.draw(with: render) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> render = <span class="type">Renderer</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">Circle</span>(center: <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">100</span>), radius: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">let</span> triangle = <span class="type">Polygon</span>(corners: [</span><br><span class="line">    <span class="type">CGPoint</span>(x: <span class="number">100</span>, y: <span class="number">0</span>),</span><br><span class="line">    <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">150</span>),</span><br><span class="line">    <span class="type">CGPoint</span>(x: <span class="number">200</span>, y: <span class="number">150</span>)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> client = <span class="type">Diagram</span>(elements: [triangle, circle])</span><br><span class="line">client.draw(with: render)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Result:</span></span><br><span class="line"><span class="comment">// move to (200.0, 150.0)</span></span><br><span class="line"><span class="comment">// line to (100.0, 0.0)</span></span><br><span class="line"><span class="comment">// line to (0.0, 150.0)</span></span><br><span class="line"><span class="comment">// line to (200.0, 150.0)</span></span><br><span class="line"><span class="comment">// arc at center: (100.0, 100.0), radius: 100.0, startAngel: 0.0, endAngle: 6.28318530717959</span></span><br></pre></td></tr></table></figure>

<p>通过上面的代码很容易就实现了一个简单的绘图程序了。不过，目前这个绘图程序只能在控制台中显示绘制的过程，我们想把它绘制到屏幕上怎么办呢？要想把内容绘制到屏幕上其实也简单的很，仍然是使用协议，我们可以把 Renderer 结构体改成 protocol：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">move</span><span class="params">(to p: CGPoint)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">line</span><span class="params">(to p: CGPoint)</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">arc</span><span class="params">(at center: CGPoint, radius: CGFloat, starAngle: CGFloat, endAngle: CGFloat)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了 Renderer 的改造，我们可以使用 CoreGraphics 来在屏幕上绘制图形了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGContext</span>: <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">line</span><span class="params">(to p: CGPoint)</span></span> &#123;</span><br><span class="line">        addLine(to: p)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">arc</span><span class="params">(at center: CGPoint, radius: CGFloat, starAngle: CGFloat, endAngle: CGFloat)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">CGMutablePath</span>()</span><br><span class="line">        path.addArc(center: center, radius: radius, startAngle: starAngle, endAngle: endAngle, clockwise: <span class="literal">true</span>)</span><br><span class="line">        addPath(path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过拓展 CGContext，使其遵守 Renderer 协议，然后使用 CGContext 提供的接口非常简单的实现了绘制工作。 下图是这个绘图程序最终的效果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/swiftprotocol/render.png" alt=""></p>
<p>完成上面绘图程序的关键，是将图形的定义和实际绘制操作拆开了，通过设计 <code>Drawable</code> 和 <code>Renderer</code> 两个协议，完成了一个高拓展的程序。想绘制其他形状，只要实现一个新的 Drawable 就可以了。例如我想绘制下面这样的图形：</p>
<img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/swiftprotocol/render2.png" width="390px" height="390px" />

<p>我们可以将原来的 Diagram 进行缩放就可以了。代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> big = <span class="type">Diagram</span>(elements: [triangle, circle])</span><br><span class="line">diagram = <span class="type">Diagram</span>(elements: [big, big.scaled(by: <span class="number">0.2</span>)])</span><br></pre></td></tr></table></figure>

<p>而通过实现 Renderer 协议，你既可以完成基于控制台的绘图程序也可以完成使用 CoreGraphics 的绘图程序，甚至可以很简单地就能实现一个使用 OpenGL 的绘图程序。这种编程思想，在编写跨平台的程序是非常有用的。</p>
<h3 id="带有-Self-和关联类型的协议"><a href="#带有-Self-和关联类型的协议" class="headerlink" title="带有 Self 和关联类型的协议"></a>带有 Self 和关联类型的协议</h3><p>我在前面部分已经指出，带有关联类型的协议和普通的协议是有一些不同的。对于那些在协议中使用了 Self 关键字的协议来说也是如此。在 Swift 3 中，这样的协议不能被当作独立的类型来使用。这个限制可能会在今后实现了完整的泛型系统后被移除，但是在那之前，我们都必须要面对和处理这个限制。</p>
<h4 id="带有-Self-的协议"><a href="#带有-Self-的协议" class="headerlink" title="带有 Self 的协议"></a>带有 Self 的协议</h4><p>我们仍然从一个例子开始：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="number">_</span> keys: [Int], <span class="keyword">for</span> key: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lo = <span class="number">0</span>, hi = keys.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = lo + (hi - lo) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> keys[mid] == key &#123; <span class="keyword">return</span> mid &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> keys[mid] &lt; key &#123; lo = mid + <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; hi = mid - <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> position = binarySearch([<span class="type">Int</span>](<span class="number">1</span>...<span class="number">10</span>), <span class="keyword">for</span>: <span class="number">3</span>)</span><br><span class="line"><span class="comment">// result: 2</span></span><br></pre></td></tr></table></figure>

<p>上面的代码实现了一个简单的二分查找，但是目前只支持查找 Int 类型的数据。如果想支持其他类型的数据，我们必须对上面的代码进行改造，改造的方向就是使用 protocol，例如我可以添加下面的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">precedes</span><span class="params">(other: Ordered)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(to other: Ordered)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(<span class="number">_</span> keys: [Ordered], <span class="keyword">for</span> key: Ordered)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lo = <span class="number">0</span>, hi = keys.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = lo + (hi - lo) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> keys[mid].<span class="built_in">equal</span>(to: key) &#123; <span class="keyword">return</span> mid &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> keys[mid].precedes(other: key) &#123; lo = mid + <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; hi = mid - <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了支持查找 Int 类型数据，我们就必须让 Int 实现 <code>Oredered</code> 协议：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/swiftprotocol/binarysearch1.png" alt=""></p>
<p>写完上面的实现，发现代码根本就不能执行，报错说的是 Int 类型和 Oredered 类型不能使用 <code>&lt;</code> 进行比较，下面的 <code>==</code> 也是一样。为了解决这个问题，我们可以在 protocol 中使用 Self：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">precedes</span><span class="params">(other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(to other: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">precedes</span><span class="params">(other: Int)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &lt; other &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(to other: Int)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> == other &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Oredered 中使用了 Self 后，编译器会在实现中将 Self 替换成具体的类型，就像上面的代码中，将 Self 替换成了 Int。这样我们就解决了上面的问题。但是又出现了新的问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/swiftprotocol/binarysearch2.png" alt=""></p>
<p>这就是上面所说的，带有 Self 的协议不能被当作独立的类型来使用。在这种情况下，我们可以使用泛型来解决这个问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span>&lt;T: Ordered&gt;<span class="params">(<span class="number">_</span> keys: [T], <span class="keyword">for</span> key: T)</span></span> -&gt; <span class="type">Int</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 String 类型的数据，也可以使用这个版本的二分查找了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">precedes</span><span class="params">(other: String)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &lt; other &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">equal</span><span class="params">(to other: String)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> == other &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> position = binarySearch([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>], <span class="keyword">for</span>: <span class="string">"d"</span>)</span><br><span class="line"><span class="comment">// result: 3</span></span><br></pre></td></tr></table></figure>

<p>当然，如果你熟悉 Swift 标准库中的协议的话，你会发现上面的实现可以简化为下面的几行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> keys: [T], <span class="keyword">for</span> key: T)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> lo = <span class="number">0</span>, hi = keys.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = lo + (hi - lo) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> keys[mid] == key &#123; <span class="keyword">return</span> mid &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> keys[mid] &lt; key &#123; lo = mid + <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; hi = mid - <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义 Ordered 协议只是为了演示在协议中使用 Self 的过程。实际开发中，可以灵活地运用标准库中提供的协议。其实在标准库中 Comparable 协议中也是用到了 Self 的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面通过实现一个二分查找算法，演示了如何使用带有 Self 的协议。简单来讲，你可以把 Self 看做一个占位符，在后面具体类型的实现中可以替换成实际的类型。</p>
<h4 id="带有关联类型的协议"><a href="#带有关联类型的协议" class="headerlink" title="带有关联类型的协议"></a>带有关联类型的协议</h4><p>带有关联类型的协议也不能被当作独立的类型来使用。在 Swift 中这样的协议非常多，例如 Collection，Sequence，IteratorProtocol 等等。如果你仍然想使用这种协议作为类型，可以使用一种叫做类型擦除的技术。你可以从<a href="http://jewelz.me/cjs77iamr00028is6rdrwj0cw/" target="_blank" rel="noopener">这里</a>了解如何实现它。</p>
<p>下面仍然通过一个例子来演示如何在项目中使用带有关联类型的协议。这次我们要通过协议实现一个带有加载动画的数据加载器，并且在出错时展示相应的占位图。</p>
<p>这里，我们定义了一个 Loading 协议，代表可以加载数据，不过要满足 Loading 协议，必须要提供一个 <code>loadingView</code>，这里的 <code>loadingView</code> 就是协议中关联类型的实例。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Loading</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">LoadingView</span>: <span class="type">UIView</span>, <span class="type">LoadingViewType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> loadingView: <span class="type">LoadingView</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Loading 协议中的关联类型有两个要求，首先必须是 UIView 的子类，其次需要遵守 LoadingViewType 协议。LoadingViewType 可以简单定义成下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">LoadingViewType</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isAnimating: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> isError: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startAnimating</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stopAnimating</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在 Loading 协议的拓展中定义一些跟加载逻辑相关的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Loading</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">startLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !view.subviews.<span class="built_in">contains</span>(loadingView) &#123;</span><br><span class="line">            view.addSubview(loadingView)</span><br><span class="line">            loadingView.frame = view.bounds</span><br><span class="line">        &#125;</span><br><span class="line">        view.bringSubview(toFront: loadingView)</span><br><span class="line">        loadingView.startAnimating()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stopLoading</span><span class="params">()</span></span> &#123;</span><br><span class="line">        loadingView.stopAnimating()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以继续给 Loading 添加一个带网络数据加载的逻辑：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Loading</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadData</span><span class="params">(with re: Resource, completion: @escaping <span class="params">(Result)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        startLoading()</span><br><span class="line">        <span class="type">NetworkTool</span>.shared.request(re) &#123; result <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">case</span> .succeed = result <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.loadingView.isError = <span class="literal">true</span> <span class="comment">// 显示出错的视图，这里可以根据错误类型显示对应的视图，这里简单处理了</span></span><br><span class="line">                <span class="keyword">self</span>.stopLoading()</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            completion(result)</span><br><span class="line">            <span class="keyword">self</span>.loadingView.isError = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">self</span>.stopLoading()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是整个 Loading 协议的实现。这里跟上面的例子不同，这儿主要使用了协议的拓展来实现需求。这样做的原因，是因为所有的加载逻辑几乎都是一样的，可能的区别就是加载的动画不同。所以这里把负责动画的部分放到了  LoadingViewType 协议里，Loading 的加载逻辑都放到协议的拓展里进行定义。协议声明里定义的方法与在协议拓展里定义的方法其实是有区别的，后面也会给出一个例子来说明它们都区别。</p>
<p>要想让 ViewController 有加载数据的功能，只要让控制器遵守 Loading 协议就行，然后在合适的地方调用 <code>loadData</code> 方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">Loading</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> loadingView = <span class="type">TestLoadingView</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        loadData(with: <span class="type">Test</span>.justEmpty) &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/swiftprotocol/loading.gif" alt=""></p>
<p>我们只要让控制器遵守 Loading 协议，就实现了从网络加载数据并带有加载动画，而且在出错时显示错误视图的功能。这里肯定有人会说，使用继承也可以实现上述需求。当然，我们可以把协议中的加载逻辑都放到一个基类中，也可以实现该需求。如果后面又要添加刷新和分页功能，那么这些代码也只能放到基类中，这样就会随着项目越来越大，基类也变得越来越臃肿，这就是所谓的上帝类。如果我们将数据加载、刷新、分页作为不同的协议，让控制器需要什么就遵守相应的协议，那么控制器就不会包含那些它不需要的功能了。这就像搭积木一样，可以灵活地给程序添加它需要的内容。</p>
<h3 id="协议与函数派发"><a href="#协议与函数派发" class="headerlink" title="协议与函数派发"></a>协议与函数派发</h3><p>函数派发就是一个程序在调用一个方法时，如何选择要执行的指令的过程。当我们每次调用一个方法时函数派发都会发生。</p>
<p>编译型语言有三种基础的函数派发方式：直接派发(Direct Dispatch)，函数表(Table Dispatch) 和消息(Message Dispatch)。大部分语言支持一到两种。Java 默认使用函数表派发，你可以通过使用 <code>final</code> 关键字将其变为直接派发。C++ 默认使用直接派发，通过 <code>virtual</code> 关键字可以改为函数表派发。Objective-C 总是使用消息派发，但允许开发者使用 C 直接派发来获取性能的提高（比如直接调用 IMP）。Swift 在这方面走在了前面，她支持全部的3种派发方式。这样的方式非常好,，不过也给很多Swift开发者带来了困扰。</p>
<p>这里只简单说一下函数派发在 protocol 中的不同表现。看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了 Flyable 协议，表示了飞行的能力。遵守该协议就必须实现 <code>fly()</code> 方法。我们可以提供几个实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eagle</span>: <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"🦅 is flying"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plane</span>: <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"✈️ is flying"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写个客户端程序测试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fls: [<span class="type">Flyable</span>] = [<span class="type">Eagle</span>(), <span class="type">Plane</span>()]</span><br><span class="line"><span class="keyword">for</span> fl <span class="keyword">in</span> fls &#123;</span><br><span class="line">    fl.fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">🦅 <span class="keyword">is</span> flying</span><br><span class="line">✈️ <span class="keyword">is</span> flying</span><br></pre></td></tr></table></figure>

<p>上面测试程序的运行结果和我们的设想完全一样。上面 <code>fly()</code> 方法是在协议的定义里进行声明的，现在我们把它放到协议拓展里进行声明，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">"Something is flying"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行前你可以先猜测一下运行的结果。</p>
<p>先暂停 3 秒钟…</p>
<p>下面是运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Something is flying</span><br><span class="line">Something is flying</span><br></pre></td></tr></table></figure>

<p>你看，我们只是简单地把在协议定义里的方法挪到了协议拓展里，运行结果却完全不同。出现像上面那样的运行结果还跟这行代码有关：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fls: [<span class="type">Flyable</span>] = [<span class="type">Eagle</span>(), <span class="type">Plane</span>()]</span><br></pre></td></tr></table></figure>

<p>如果你直接使用具体类型进行调用，肯定是没有问题的，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Eagle</span>().fly() 	<span class="comment">// 🦅 is flying</span></span><br><span class="line"><span class="type">Plane</span>().fly() 	<span class="comment">// ✈️ is flying</span></span><br></pre></td></tr></table></figure>

<p>出现上面两种完全不同的结果，主要是因为函数派发根据方法声明的位置的不同而采用了不同的策略，总结起来有这么几点:</p>
<ul>
<li>值类型（struct, enum）总是会使用直接派发</li>
<li>而协议和类的 <code>extension</code> 都会使用直接派发</li>
<li>协议和普通 Swift 类声明作用域里的方法都会使用函数表进行派发</li>
<li>继承 <code>NSObject</code> 的类声明作用域里的方法都会使用函数表派发</li>
<li>继承 <code>NSObject</code> 的类的 <code>extension</code> 、使用 <code>dynamic</code> 标记的方法会使用消息派发</li>
</ul>
<p>下面这张图很清楚地总结了 Swift 中函数派发方式，不过少了 <code>dynamic</code> 的方式。</p>
<p><img src="https://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/Defaults-1-768x503.png" alt=""></p>
<p>在上面的例子中，虽然 <code>Eagle</code> 和 <code>Plane</code> 都实现了 <code>fly()</code> 方法，但在多态时，仍然会调用协议拓展里的默认实现。因为，在协议拓展声明的方法，在调用时，使用的是直接派发，直接派发总是要优于其他的派发方式的。</p>
<p>所以理解 Swift 中的函数派发，对于我们写出结构清晰、没有 bug 的代码是非常重要的。当然，如果你没有使用到多态，直接使用具体的类型，是不会出现上面的问题的。既然你都开始 “针对接口编程，而不是针对实现编程”，怎么会用不到多态呢，是吧。</p>
<h2 id="使用协议改善既有的代码设计"><a href="#使用协议改善既有的代码设计" class="headerlink" title="使用协议改善既有的代码设计"></a>使用协议改善既有的代码设计</h2><p>通过上面的例子可以看出，通过协议进行代码共享相比与通过继承的共享，有这几个优势：</p>
<ul>
<li>我们不需要被强制使用某个父类。</li>
<li>我们可以让已经存在的类型满足协议 (比如我们让 CGContext 满足了 Renderer)。子类就没那么灵活了，如果 CGContext 是一个类的话，我们无法以追溯的方式去变更它的父类。</li>
<li>协议既可以用于类，也可以用于结构体、枚举，而继承就无法和结构体、枚举一起使用了。</li>
<li>协议可以模拟多继承。</li>
<li>最后，当处理协议时，我们无需担心方法重写或者在正确的时间调用 super 这样的问题。</li>
</ul>
<p>通过面向协议的编程，我们可以从传统的继承上解放出来，用一种更灵活的方式，像搭积木一样对程序进行组装。协议和类一样，在设计时要遵守 “单一职责” 原则，让每个协议专注于自己的功能。得益于协议扩展，我们可以减少继承带来的共享状态的风险，让代码更加清晰。</p>
<p>使用面向协议编程有助于我们写出低耦合、易于扩展以及可测试的代码，而结合泛型来使用协议，更可以让我们免于动态调用和类型转换的苦恼，保证了代码的安全性。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift中的rethrows</title>
    <url>/ck9grdnzs0008eyyeaq5fbzir/</url>
    <content><![CDATA[<p>我最近在学习Swift函数式编程时，越来越觉得Swift是一门强大的语言。在 Swift 的世界中，函数不再是二等公民。<a id="more"></a> 是的，Swift 引入了大量函数式编程的特性，使得我们能够把函数当作一等公民来对待。在Swift中，适当引入函数式编程的思想和方法，常常会有奇效。</p>
<p>然而，当我想去深入了解时，发现这里水好深，还有好多自己不知道的东西。<br>废话不多说，我们先从<code>map</code>函数说起吧。Swift中<code>map</code>是这么声明的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(@noescape transform: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>这里<code>@noescape</code>是什么东西？<code>rethrows</code>又是什么东西？查了资料才知道原来是这么回事儿：<br><code>@noescape</code>，这是一个从 Swift 1.2 引入的关键字，它是专门用于修饰函数闭包这种参数类型的，当出现这个参数时，它表示该闭包不会跳出这个函数调用的生命期：即函数调用完之后，这个闭包的生命期也结束了。以下是苹果的文档原文：</p>
<blockquote>
<p>A new @noescape attribute may be used on closure parameters to functions. This indicates that the parameter is only ever called (or passed as an @noescape parameter in a call), which means that it cannot outlive the lifetime of the call. This enables some minor performance optimizations, but more importantly disables the self. requirement in closure arguments.</p>
</blockquote>
<p>如果想了解更多关于<code>@noescape</code>，可以看看这篇文章：<a href="http://nshint.io/blog/2015/10/23/noescape-attribute/" target="_blank" rel="noopener">http://nshint.io/blog/2015/10/23/noescape-attribute/</a></p>
<p>那<code>rethrows</code>又是怎么一回事儿呢？下面我们就通过写一个我们自己的<code>map</code>来看一看<code>rethrows</code>是个什么鬼。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mymap</span>&lt;T&gt;<span class="params">(@noescape transform: <span class="params">(Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> ts = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            ts.append(transform(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ts</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CalculationError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">DivideByZero</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squareOf</span><span class="params">(x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;<span class="keyword">return</span> x*x&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divideTenBy</span><span class="params">(x: Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> x != <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">CalculationError</span>.<span class="type">DivideByZero</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10.0</span> / <span class="type">Double</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来调用一下<code>mymap</code>函数：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-2bc93aaf0c7719b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-01 上午9.54.43.png"><br>可以看到当我们传人的闭包有异常抛出时，编译器就报错了。根据报错信息我们重写了个<code>map</code>函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mymapThrow</span>&lt;T&gt;<span class="params">(@noescape transform: <span class="params">(Generator.Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">throws</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> ts = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            ts.append(<span class="keyword">try</span> transform(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ts</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>来调用一下<code>mymapThrow</code>函数：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-eb9c916287489d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-01 上午10.09.11.png"><br>编译器又报错了，我们让新的<code>map</code>函数能抛出异常，然后在调用<code>mymapThrow</code>函数的地方处理异常。但是这会带来一个问题，例如<code>x2</code>这里我们传入的闭包并没有异常抛出啊，难道我们在每次调用的时候都非得写那么一大串异常处理的代码吗？例如这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ns: [<span class="type">Double</span>]</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> ns = xs.mymapThrow(divideTenBy)</span><br><span class="line">    ns</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ns2: [<span class="type">Double</span>]</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> ns2 = xs.mymapThrow(squareOf)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按 Swift 类型安全的写法，在有异常抛出的地方就一定需要使用 try 语法。我相信在平时我们传入的闭包函数没有异常的情况一定远远多于有异常的情况，难道我们非得为了代码的安全性就必须牺牲掉方便性吗？显然，Swift比我们想象的要更聪明。于是本文章的主角<code>rethrows</code>登场了。<br>我们重新写个<code>map</code>函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_map</span>&lt;T&gt;<span class="params">(@noescape transform: <span class="params">(Generator.Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> ts = [<span class="type">T</span>]()</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            ts.append(<span class="keyword">try</span> transform(e))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ts</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再来看一下结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-c837b571719e6495.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-03-01 上午10.28.18.png"><br>这一下就没问题了。当传入的闭包函数没有异常时我们也不用去捕获异常，有异常时我们就去处理异常。所以<code>rethrows</code>关键字的意义就在于：</p>
<blockquote>
<p>这个函数如果抛出异常，仅可能是因为传递给它的闭包的调用导致了异常。如果闭包的调用没有导致异常，编译器就知道这个函数不会抛出异常。那么我们也就不用去处理异常了。</p>
</blockquote>
<p>哈哈，一个<code>map</code>函数就有这么多的学问，看来我还得花更多的精力去学习Swift了。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift构造器</title>
    <url>/ck9grdnzu000ceyyedsfxdty1/</url>
    <content><![CDATA[<p>构造过程就是为一个实例上的每个存储属性设置初始值，并在新实例准备就绪之前执行所需的任何其他设置或初始化。</p>
<a id="more"></a>

<p>我们通过定义构造器（暂时就这么叫吧，因为大家都这么叫，其实我觉得称为初始化器或初始化方法更合适一点）来实现这个构造过程，其实它就是一个特殊的方法，可以用来创建一个特定类型的新示例。</p>
<p>Swift 中的构造器与 Objective-C 中不同，它没有返回值。不过它们的主要作用都是确保类型的新实例在第一次使用之前已正确初始化。OC 中我们并没有显示地给每个属性赋初始值，是因为它们在定义时有默认值，这一点与 Swift 不同。</p>
<h2 id="为存储属性设置初始值"><a href="#为存储属性设置初始值" class="headerlink" title="为存储属性设置初始值"></a>为存储属性设置初始值</h2><p>类和结构体必须在创建该类或结构体的实例时将其所有存储属性设置为适当的初始值。当然我们可以在定义属性时做好这个工作，不过大多数情况下，我们都是在构造器中给存储属性设置初始值。其实也并不是所有的存储属性都得去设置初始值，可选类型因为会被默认置为nil，所以并不强制在初始化时赋值。有一点需要注意的是不论是你在定义属性时就给定一个初值还是在构造器中给定初始值都不会触发属性监听。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器会在创建实例的时候自动调用，一般来说每个类都需要构造器，无论是自己写的还是编译器为你生成的。我们使用 <code>init</code> 关键字就可以定义一定构造器，并且不用使用 <code>func</code> 关键字:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在括号里面可以加各种参数，来进行更复杂的初始化。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和普通函数一样，构造函数也可以有内部参数名和外部参数名，在我们没有给定外部参数名的情况下，Swift 会自动给我们生成一个跟内部参数名一样的外部参数名。如果不想使用外部参数名，可以在内部参数名之前加上 <code>_</code> 即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span>(<span class="number">_</span> name: <span class="type">String</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>如果在一个类或结构体中所有的存储属性都有默认值，并且没有定义任何构造器也没有父类，那么 Swift 就会提供一个默认的构造器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ShoppingListItem &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var quantity &#x3D; 1</span><br><span class="line">    var purchased &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line">var item &#x3D; ShoppingListItem()</span><br></pre></td></tr></table></figure>

<h3 id="结构体的逐一成员构造器"><a href="#结构体的逐一成员构造器" class="headerlink" title="结构体的逐一成员构造器"></a>结构体的逐一成员构造器</h3><p>如果我们在结构体中没有定义任何自己的构造器，那么 Swift 会给我们提供一个逐一成员构造器，这和默认构造器不同，不管结构体中的存储属性有没有赋初识值，包括常量属性。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> width: <span class="type">Float</span></span><br><span class="line">  <span class="keyword">var</span> height: <span class="type">Float</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> maxWH: <span class="type">Float</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aSize = <span class="type">Size</span>(width: <span class="number">200</span>, height: <span class="number">300</span>, maxWH: <span class="number">200</span>)</span><br></pre></td></tr></table></figure>



<h2 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h2><p>所谓构造代理就是构造器可以调用别的构造器来辅助完成构造过程， 目的主要是为了避免写重复的代码。</p>
<p>值类型（结构体和枚举）和类的构造器代理规则是不一样的。值类型不支持继承，所以它们的构造器代理就比较简单，只需要通过 <code>self.init</code> 调用自己的其他构造器。下面是苹果官方给出的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>, height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>, y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">init</span>(origin: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.origin = origin</span><br><span class="line">        <span class="keyword">self</span>.size = size</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(center: <span class="type">Point</span>, size: <span class="type">Size</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> originX = center.x - (size.width / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> originY = center.y - (size.height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(origin: <span class="type">Point</span>(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果给值类型定义了自己的构造器，那么默认的构造器将不会被合成，如果你还是想要默认的构造器，就用extension来写自定义构造器即可。</p>
<h2 id="类的继承和初始化"><a href="#类的继承和初始化" class="headerlink" title="类的继承和初始化"></a>类的继承和初始化</h2><p>类的所有存储属性包括从父类继承而来的都必须在初始化的时候赋予初值。Swift 为类定义了两种构造器来确保所有的存储属性都获得初值，即指定构造器和便利构造器。</p>
<h3 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h3><p>指定构造器是主要的构造手段，每个类至少要有1个，意味着可以有多个，但是多数情况下会是1个，而便利构造器则没有要求。指定构造器必须完全初始化该类引入的所有存储属性，并调用适当的父类构造器以继续完成父类中属性的初始化过程。便利构造器则要求最终要调用一个指派构造器。</p>
<p>在语法上便利构造器和指定构造器没有太大差别，只是在指定构造器 <code>init</code> 前多了一个 <code>convenience</code> 关键字</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(params) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="类的构造器代理"><a href="#类的构造器代理" class="headerlink" title="类的构造器代理"></a>类的构造器代理</h3><p>为了简化指定构造器和便利构造器之间的关系，Swift 对构造器代理应用以下三个规则：</p>
<ol>
<li><strong>一个指定构造器必须调用其直接父类的指定构造器。</strong></li>
<li><strong>一个便利构造器必须调用类中其它的构造器。</strong></li>
<li><strong>一个便利构造器必须最终调用一个指定构造器。</strong></li>
</ol>
<p>用两句话概括就是：</p>
<ul>
<li>指定构造器总是向上代理</li>
<li>便利构造器总是横向代理</li>
</ul>
<p>下面的图很好地解释了这个规则<br><img src="http://image18-c.poco.cn/mypoco/myphoto/20170228/13/1843604332017022813450909.png?487x379_130" alt=""></p>
<h3 id="两段式构造"><a href="#两段式构造" class="headerlink" title="两段式构造"></a>两段式构造</h3><p>Swift 中类的初始化分为两个阶段。在第一个阶段中，每个存储属性都要被赋值，如果有一部分属性是从父类继承得来，那么调用父类的构造器来完成所有存储属性的赋值。反正就是在第一个阶段要保证所有的存储属性都要有初始值。第二阶段就可以对属性进行进一步操作了。</p>
<p>使用两段式构造会让初始化过程更加安全。两段式构造防止属性值在初始化之前被访问，并防止属性值被另一个构造器意外设置为不同的值。</p>
<p>同时，Swift 的编译器会为两段式构造执行四个有用的安全检查，以确保这个过程不会发生错误：</p>
<ul>
<li><strong>安全检查 1：在进行构造器的向上代理之前，必须确保类中所有的存储属性都被初始化。</strong></li>
</ul>
<p>如上所述，当所有存储属性的初始状态已知时，对象的内存才被认为是完全初始化的。为了满足这条规则，指定构造器必须确保在它在移交给初始化链之前初始化它自己的所有属性。</p>
<ul>
<li><strong>安全检查 2：在给继承来的属性赋值之前，指定构造器必须先向上代理父类的构造器。如果不这么做的话，在给继承来的属性赋完值后，它可能会在父类的构造器中被重写。</strong></li>
<li><strong>安全检查 3：一个便利构造器在给任何属性赋值之前，必须先调用其它的构造器。如果不这么做的话，便利构造器赋的值会被指定构造器覆盖。</strong></li>
<li><strong>安全检查 4：在两段式构造过程的第一阶段完成之前，初始化函数不能调用其它实例方法, 不能从实例属性中取值, 也不能用<code>self</code>。</strong></li>
</ul>
<p>结合上面的四个安全检查，再来看看两段式构造过程做了什么：</p>
<h5 id="阶段-1"><a href="#阶段-1" class="headerlink" title="阶段 1"></a>阶段 1</h5><ul>
<li>类的一个指定构造器或便利构造器被调用。</li>
<li>为该类的新实例分配内存。但是内存还未初始化。</li>
<li>指定构造器确保所有的存储属性都有值。这些存储属性的内存现在已初始化。</li>
<li>指定构造器将初始化移交给父类初始化函数来对父类存储属性实现同样的操作。</li>
<li>这个过程一直沿着继承链持续下去，直到达到继承链顶端。</li>
<li>到了继承链顶端，并且最终父类保证所有的存储属性都有值之后，实例的内存就被当做完全初始化了，此时阶段1完成。</li>
</ul>
<h5 id="阶段-2"><a href="#阶段-2" class="headerlink" title="阶段 2"></a>阶段 2</h5><ul>
<li>从继承链顶端倒回来，每一个指派初始化函数都可以进一步定制实例，初始化函数至此可以访问 <code>self</code>，并且可以修改自己的属性，调用实例方法，等等。</li>
<li>最终，调用链上的任意便利构造器都可以操作实例了，也可以访问 <code>self</code>。</li>
</ul>
<h3 id="构造器的继承和重载"><a href="#构造器的继承和重载" class="headerlink" title="构造器的继承和重载"></a>构造器的继承和重载</h3><p>与 Objective-C 不同，Swift 中的子类默认不会自动从父类那里继承其构造器。虽然不能自动继承不过我们还是有办法从父类那里继承构造器。</p>
<p>当子类在覆盖父类的指定构造器时，需要要用 <code>override</code> 来修饰，即使你的子类的构造器的实现是一个便利构造器。但是，如果子类的指定造器与父类的便利构造器相同，那么父类的便利构造器永远都不会被子类调用到，所以这种情况是不需要 <code>override</code> 的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  var numberOfFoots: Int</span><br><span class="line">  var name: String</span><br><span class="line">  </span><br><span class="line">  init(name: String, foots: Int) &#123;</span><br><span class="line">    self.name &#x3D; name</span><br><span class="line">    numberOfFoots &#x3D; foots</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  convenience init(name: String) &#123;</span><br><span class="line">    self.init(name: name, foots: 4)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class 🐔: Animal &#123;</span><br><span class="line">  </span><br><span class="line">  override init(name: String, foots: Int) &#123;</span><br><span class="line">    super.init(name: name, foots: foots)</span><br><span class="line">    numberOfFoots &#x3D; 2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  init(name: String) &#123;</span><br><span class="line">    super.init(name: name, foots: 2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Animal</code> 分别定义了一个指定构造器和便利构造器，在 🐔 中重写了父类的<code>init(name: String, foots: Int)</code>，所以要使用 <code>override</code> 关键字，并且又定义了一个跟父类便利构造器相同的指定构造器，这个时候就不需要 <code>override</code> 关键字了。因为便利构造器只能横向代理，是不会被子类重写的。</p>
<h3 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h3><p>上面已经说过，Swift 中的子类默认不会自动继承父类的构造函数。但是，如果满足某些条件，父类的构造器会自动继承。以下就是构造器会自动继承的两个规则：</p>
<ul>
<li><strong>规则 1</strong> <br><br>  如果子类没有定义任何指定构造器，它会自动继承父类所有的指定构造器。</li>
<li><strong>规则 2</strong> <br><br>  如果子类实现了父类中所有的指定构造器——不管是从规则1继承而来还是提供了自己的实现，那么它会自动继承父类所有的便利构造器。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(age: <span class="type">Int</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.<span class="keyword">init</span>(name: <span class="string">"unknow"</span>, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, age: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>: <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中 <code>Man</code> 继承了 <code>Person</code> ，根据规则 1，<code>Man</code> 会继承父类的所有的指定构造器，同时根据规则 2，<code>Man</code> 实现了父类中所有的指定构造器 (这里是继承得来)，所以它会自动继承父类所有的便利构造器。就像下面这样：<br><img src="http://image18-c.poco.cn/mypoco/myphoto/20170228/15/18436043320170228153534059.png?421x118_130" alt=""></p>
<h2 id="可失败的构造器"><a href="#可失败的构造器" class="headerlink" title="可失败的构造器"></a>可失败的构造器</h2><p>有时候我们需要构造失败，例如传入了不恰当的参数，这种情况使用可失败的构造器是很有用的，这样可以引起调用者的注意。</p>
<p>为了应对可能失败的初始化条件，可以为我们的类型（类、结构体或枚举）定义一个或多个可失败构造器。用 <code>init?</code> 就可以定义一个可失败构造器。不过可失败和不可失败的构造器不能有一样的参数类型列表，否则就有二义性了。当构造失败时，可以返回 <code>nil</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> species: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(species: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> species.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过可失败构造器实例化的对象是个可选值，所以在使用时需要解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> giraffe = <span class="type">Animal</span>(species: <span class="string">"Giraffe"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"An animal was initialized with a species of \(giraffe.species)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可失败构造器的传递"><a href="#可失败构造器的传递" class="headerlink" title="可失败构造器的传递"></a>可失败构造器的传递</h3><p>类，结构或枚举的可失败构造器可以从相同的类，结构或枚举中代理给另一个可失败构造器。类似地，子类的可失败构造器可以向上代理父类的可失败构造器。</p>
<p>在任何种情况下，如果委托给另一个构造器导致初始化失败，整个初始化过程立即失败，并且不再执行初始化代码。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">lass <span class="type">Product</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span>: <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> quantity: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>, quantity: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> quantity &lt; <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.quantity = quantity</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重载可失败构造器"><a href="#重载可失败构造器" class="headerlink" title="重载可失败构造器"></a>重载可失败构造器</h3><p>你可以像重载普通构造器一样，重载父类的可失败构造器。你可以在子类中用普通的构造器重载父类的可失败构造器，但是不能反过来。看下面的例子就很清楚了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>?(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutomaticallyNamedDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">if</span> name.isEmpty &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = <span class="string">"[Untitled]"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.name = name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UntitledDocument</span>: <span class="title">Document</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: <span class="string">"[Untitled]"</span>)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="必需构造器-Required-Initializers"><a href="#必需构造器-Required-Initializers" class="headerlink" title="必需构造器(Required Initializers)"></a>必需构造器(Required Initializers)</h2><p>如果 <code>init</code> 用了 <code>required</code> 来修饰， 那么意味着子类必需要实现这个构造器。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// initializer implementation goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类重写父类的必需构造器时，仍然需要用<code>required</code> 来修饰，而不用使用 <code>override</code> 关键字。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeSubclass</span>: <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">// subclass implementation of the required initializer goes here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你满足构造器继承的条件的话，必需构造器也不是一定要自己实现的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 Swift 中构造器的简单介绍。与 Objective-C 相比，Swift 中的构造过程确实比较复杂，这也确确实实地体现了 Swift 是一门安全的语言。总的来说，Swift 的构造过程就是为了在任何实例使用之前所有的存储属性都要先初始化完成。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 应用启动流程分析-Dyld</title>
    <url>/ck9grdnzv000deyyee29t8nmm/</url>
    <content><![CDATA[<p>iOS 应用程序启动过程可以以 <code>main</code> 函数为界，这里我们先不用管 <code>main()</code>函数调用后的过程，主要来分析一下 <code>mian()</code> 函数调用之前的dyld阶段。</p>
<p>我们可以先写个简单的程序来看看系统在调用 <code>main()</code> 之前，调用了哪些函数。</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/01.png" alt=""></p>
<p>这里给 <code>load</code> 方法添加了一个断点。从调用栈可以看到最先调用的是 <code>__dyld_start</code> 函数。我们可以从 <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="noopener">dyld 源码</a> dyldStartup.s 中找到 <code>__dyld_start</code> 的实现。此函数由汇编实现，兼容各种平台架构，此处主要以arm64 架构下的汇编代码为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if __arm64__</span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">__dso_static: </span><br><span class="line">	.quad   ___dso_handle</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.align 2</span><br><span class="line">	.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">	mov 	x28, sp</span><br><span class="line">	and     sp, x28, #~15		&#x2F;&#x2F; force 16-byte alignment of stack</span><br><span class="line">	mov	x0, #0</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	stp	x1, x0, [sp, #-16]!	&#x2F;&#x2F; make aligned terminating frame</span><br><span class="line">	mov	fp, sp			&#x2F;&#x2F; set up fp to point to terminating frame</span><br><span class="line">	sub	sp, sp, #16             &#x2F;&#x2F; make room for local variables</span><br><span class="line">	ldr     x0, [x28]		&#x2F;&#x2F; get app&#39;s mh into x0</span><br><span class="line"> 	ldr     x1, [x28, #8]           &#x2F;&#x2F; get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span><br><span class="line">	add     x2, x28, #16		&#x2F;&#x2F; get argv into x2</span><br><span class="line">	adrp	x4,___dso_handle@page</span><br><span class="line">	add 	x4,x4,___dso_handle@pageoff &#x2F;&#x2F; get dyld&#39;s mh in to x4</span><br><span class="line">	adrp	x3,__dso_static@page</span><br><span class="line">	ldr 	x3,[x3,__dso_static@pageoff] &#x2F;&#x2F; get unslid start of dyld</span><br><span class="line">	sub 	x3,x4,x3		&#x2F;&#x2F; x3 now has slide of dyld</span><br><span class="line">	mov	x5,sp                   &#x2F;&#x2F; x5 has &amp;startGlue</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">	mov	x16,x0                  &#x2F;&#x2F; save entry point address in x16</span><br><span class="line">	ldr     x1, [sp]</span><br><span class="line">	cmp	x1, #0</span><br><span class="line">	b.ne	Lnew</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; LC_UNIXTHREAD way, clean up stack and jump to result</span><br><span class="line">	add	sp, x28, #8		&#x2F;&#x2F; restore unaligned stack pointer without app mh</span><br><span class="line">	br	x16			&#x2F;&#x2F; jump to the program&#39;s entry point</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; LC_MAIN case, set up stack for call to main()</span><br><span class="line">Lnew:	mov	lr, x1		    &#x2F;&#x2F; simulate return address into _start in libdyld.dylib</span><br><span class="line">	ldr     x0, [x28, #8] 	    &#x2F;&#x2F; main param1 &#x3D; argc</span><br><span class="line">	add     x1, x28, #16	    &#x2F;&#x2F; main param2 &#x3D; argv</span><br><span class="line">	add	x2, x1, x0, lsl #3  </span><br><span class="line">	add	x2, x2, #8	    &#x2F;&#x2F; main param3 &#x3D; &amp;env[0]</span><br><span class="line">	mov	x3, x2</span><br><span class="line">Lapple:	ldr	x4, [x3]</span><br><span class="line">	add	x3, x3, #8</span><br><span class="line">	cmp	x4, #0</span><br><span class="line">	b.ne	Lapple		    &#x2F;&#x2F; main param4 &#x3D; apple</span><br><span class="line">	br	x16</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; __arm64__</span><br></pre></td></tr></table></figure>

<p>这里主要关注一下 <code>bl</code> 指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">bl	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br></pre></td></tr></table></figure>

<p>从注释了解到，其实就是调用 <code>dyldbootstrap::start()</code> 函数。在 dyldInitialization.cpp 中可以找到 <code>start</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> ) &#123;</span><br><span class="line">		rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">	mach_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">	<span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>start</code> 函数中做了很多 dyld 初始化相关的工作，包括：</p>
<ul>
<li>rebaseDyld() dyld 重定位</li>
<li>mach_init() mach消息初始化</li>
<li>__guard_setup() 栈溢出保护</li>
</ul>
<p>初始化工作完成后，此函数调用到了 <code>dyld::_main</code>，再将返回值传递给 <code>__dyld_start</code> 去调用真正的 <code>main()</code> 函数。</p>
<p>我们可以在 dyld.cpp 中找到<code>_main</code> 的实现， 代码比较长，就不贴代码了，不过我们可以看看 <code>_main</code> 函数的注释:</p>
<blockquote>
<p>Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which sets up some registers and call this function.</p>
<p>Returns address of main() in target program which __dyld_start jumps to</p>
</blockquote>
<p>这个是说，内核加载 dyld，并跳转到 __dyld_start 函数，它主要设置一些寄存器，并且调用了 <code>_main</code>函数。这里刚好跟上面分析的过程相吻合。</p>
<p><code>dyld::_mina()</code> 是应用程序启动的关机函数，主要做了以下一些事情：</p>
<ol>
<li>设置运行环境</li>
<li>实例化主程序 </li>
<li>加载共享缓存</li>
<li>加载插入的动态库</li>
<li>链接主程序</li>
<li>链接插入的动态库</li>
<li>执行弱符合绑定</li>
<li>执行初始化方法</li>
<li>查找入口并返回</li>
</ol>
<h5 id="设置运行环境"><a href="#设置运行环境" class="headerlink" title="设置运行环境"></a>设置运行环境</h5><p>这一步主要是设置运行参数、环境变量等。代码在开始的时候，将入参<code>mainExecutableMH</code> 赋值给了<code>sMainExecutableMachHeader</code>，这是一个<code>macho_header</code> 结构体，表示的是当前主程序的 Mach-O 头部信息，加载器依据 Mach-O 头部信息就可以解析整个 Mach-O 文件信息。接着调用 <code>setContext()</code> 设置上下文信息，包括一些回调函数、参数、标志信息等。如 <code>loadLibrary()</code> 函数实际调用的是 <code>libraryLocator()</code>，负责加载动态库。代码片断如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gLinkContext.loadLibrary			= &amp;libraryLocator;</span><br><span class="line">    gLinkContext.terminationRecorder	= &amp;terminationRecorder;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实例化主程序"><a href="#实例化主程序" class="headerlink" title="实例化主程序"></a>实例化主程序</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br></pre></td></tr></table></figure>

<p>这一步将主程序的 Mach-O 加载进内存，并实例化一个 ImageLoader。<code>instantiateFromLoadedImage()</code> 首先调用 <code>isCompatibleMachO()</code> 检测Mach-O 头部的magic、cputype、cpusubtype 等相关属性，判断 Mach-O 文件的兼容性，如果兼容性满足，则调用<code>ImageLoaderMachO::instantiateMainExecutable()</code> 实例化主程序的ImageLoader，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* <span class="built_in">image</span> = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		addImage(<span class="built_in">image</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">image</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageLoaderMachO::instantiateMainExecutable()</code> 函数里面首先会调用<code>sniffLoadCommands()</code> 函数来获取一些数据，包括：</p>
<ul>
<li><strong>compressed</strong>：若Mach-O存在LC_DYLD_INFO和LC_DYLD_INFO_ONLY加载命令，则说明是压缩类型的Mach-O</li>
<li><strong>segCount</strong>：根据 LC_SEGMENT_COMMAND 加载命令来统计段数量。</li>
<li><strong>libCount</strong>：根据 LC_LOAD_DYLIB、LC_LOAD_WEAK_DYLIB、LC_REEXPORT_DYLIB、LC_LOAD_UPWARD_DYLIB 这几个加载命令来统计库的数量，库的数量不能超过4095个。</li>
<li><strong>codeSigCmd</strong>：通过解析LC_CODE_SIGNATURE来获取代码签名加载命令。</li>
<li><strong>encryptCmd</strong>：通过LC_ENCRYPTION_INFO和LC_ENCRYPTION_INFO_64来获取段的加密信息。</li>
</ul>
<p>ImageLoader 是抽象类，其子类负责把 Mach-O 文件实例化为 image，当<code>sniffLoadCommands()</code> 解析完以后，根据 <code>compressed</code> 的值来决定调用哪个子类进行实例化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( compressed ) </span><br><span class="line">    <span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">#<span class="keyword">if</span> SUPPORT_CLASSIC_MACHO</span><br><span class="line">    <span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable()</code> 执行完后，会调用 <code>addImage()</code> 函数将 image 加入到 <code>sAllImages</code> 全局镜像列表中。并将image映射到申请的内存中， 其代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(ImageLoader* <span class="built_in">image</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// add to master list</span></span><br><span class="line">    allImagesLock();</span><br><span class="line">        sAllImages.push_back(<span class="built_in">image</span>);</span><br><span class="line">    allImagesUnlock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update mapped ranges</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegStart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegEnd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=<span class="built_in">image</span>-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="built_in">image</span>-&gt;segUnaccessible(i) ) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> start = <span class="built_in">image</span>-&gt;segActualLoadAddress(i);</span><br><span class="line">		<span class="keyword">uintptr_t</span> <span class="built_in">end</span> = <span class="built_in">image</span>-&gt;segActualEndAddress(i);</span><br><span class="line">		<span class="keyword">if</span> ( start == lastSegEnd ) &#123;</span><br><span class="line">			<span class="comment">// two segments are contiguous, just record combined segments</span></span><br><span class="line">			lastSegEnd = <span class="built_in">end</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// non-contiguous segments, record last (if any)</span></span><br><span class="line">			<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">				addMappedRange(<span class="built_in">image</span>, lastSegStart, lastSegEnd);</span><br><span class="line">			lastSegStart = start;</span><br><span class="line">			lastSegEnd = <span class="built_in">end</span>;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">		addMappedRange(<span class="built_in">image</span>, lastSegStart, lastSegEnd);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_LIBRARIES || (sEnv.DYLD_PRINT_LIBRARIES_POST_LAUNCH &amp;&amp; (sMainExecutable!=<span class="literal">NULL</span>) &amp;&amp; sMainExecutable-&gt;isLinked()) ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">"dyld: loaded: %s\n"</span>, <span class="built_in">image</span>-&gt;getPath());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载共享缓存"><a href="#加载共享缓存" class="headerlink" title="加载共享缓存"></a>加载共享缓存</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load shared cache</span></span><br><span class="line">checkSharedRegionDisable();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_SHARED_CACHE_SUPPORT</span></span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</span><br><span class="line">	mapSharedCache();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这一步先调用 <code>checkSharedRegionDisable()</code> 检查共享缓存是否禁用。该函数的iOS实现部分仅有一句注释，从注释我们可以推断iOS必须开启共享缓存才能正常工作。接下来调用 <code>mapSharedCache()</code> 来加载共享缓存。</p>
<h5 id="加载插入的动态库"><a href="#加载插入的动态库" class="headerlink" title="加载插入的动态库"></a>加载插入的动态库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">        loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步是加载环境变量DYLD_INSERT_LIBRARIES中配置的动态库，先判断环境变量DYLD_INSERT_LIBRARIES中是否存在要加载的动态库，如果存在则调用 <code>loadInsertedDylib()</code> 依次加载。</p>
<p><code>loadInsertedDylib()</code> 内部设置了一个LoadContext 后，调用了 <code>load()</code> 函数。该函数内部调用的一系列的 loadPhase*。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line">ImageLoader* <span class="built_in">image</span> = loadPhase0(path, orgPath, context, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>大致会按照下图的顺序搜索动态库，并调用不同的函数来继续处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/02.png" alt=""></p>
<p>当内部调用到 <code>loadPhase5load()</code> 函数的时候，会先在共享缓存中搜索，如果存在则调用 <code>ImageLoaderMachO::instantiateFromCache()</code>  来实例化ImageLoader，否则通过 <code>loadPhase5open()</code> 打开文件并读取数据到内存后，再调用 <code>loadPhase6()</code> ，通过 <code>ImageLoaderMachO::instantiateFromFile()</code>  来实例化 ImageLoader，最后调用 <code>checkandAddImage()</code> 验证镜像并将其加入到全局镜像列表中。</p>
<h5 id="链接主程序"><a href="#链接主程序" class="headerlink" title="链接主程序"></a>链接主程序</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>

<p>这一步调用 <code>link()</code> 函数将实例化后的主程序进行动态修正，让二进制变为可正常执行的状态。<code>link()</code> 函数内部调用了<code>ImageLoader::link()</code> 函数，从源代码可以看到，这一步主要做了以下几个事情：</p>
<ul>
<li><code>recursiveLoadLibraries()</code> 加载所有依赖的库到内存。</li>
<li><code>recursiveUpdateDepth()</code> 递归刷新依赖库的层级。</li>
<li><code>recursiveRebase()</code> 由于ASLR的存在，必须递归对主程序以及依赖库进行重定位操作。</li>
<li><code>recursiveBind()</code>  把主程序二进制和依赖进来的动态库全部执行符号表绑定。</li>
<li><code>weakBind()</code> 如果链接的不是主程序二进制的话，会在此时执行弱符号绑定，主程序二进制则在link()完后再执行弱符号绑定。</li>
<li><code>context.registerDOFs(dofs)</code> 注册DOF（DTrace Object Format）。</li>
</ul>
<h5 id="链接插入的动态库"><a href="#链接插入的动态库" class="headerlink" title="链接插入的动态库"></a>链接插入的动态库</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">        ImageLoader* <span class="built_in">image</span> = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">        link(<span class="built_in">image</span>, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">image</span>-&gt;setNeverUnloadRecursive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">    <span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">        ImageLoader* <span class="built_in">image</span> = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">image</span>-&gt;registerInterposing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步与链接主程序一样，将前面调用 <code>addImage()</code> 函数保存在 <code>sAllImages</code> 中的动态库列表循环取出并调用 <code>link()</code> 进行链接，需要注意的是，<code>sAllImages</code> 中保存的第一项是主程序的镜像，所以要从 i+1的位置开始，取到的才是动态库的 ImageLoader。</p>
<p>接下来循环调用每个镜像的 <code>registerInterposing()</code> 函数，该函数会遍历Mach-O 的 LC_SEGMENT_COMMAND 加载命令，读取__DATA, __interpose，并将读取到的信息保存到 <code>fgInterposingTuples</code> 中。</p>
<h5 id="执行弱符合绑定"><a href="#执行弱符合绑定" class="headerlink" title="执行弱符合绑定"></a>执行弱符合绑定</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">sMainExecutable-&gt;weakBind(gLinkContext);</span><br></pre></td></tr></table></figure>

<p><code>weakBind()</code> 首先通过 <code>getCoalescedImages()</code> 合并所有动态库的弱符号到一个列表里，然后调用 <code>initializeCoalIterator()</code> 对需要绑定的弱符号进行排序，接着调用 <code>incrementCoalIterator()</code> 读取dyld_info_command 结构的 <code>weak_bind_off</code> 和 <code>weak_bind_size</code> 字段，确定弱符号的数据偏移与大小，最终进行弱符号绑定。</p>
<h5 id="执行初始化方法"><a href="#执行初始化方法" class="headerlink" title="执行初始化方法"></a>执行初始化方法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span></span><br><span class="line">    <span class="comment">// Old way is to run initializers via a callback from crt1.o</span></span><br><span class="line">    <span class="keyword">if</span> ( ! gRunInitializersOldWay ) </span><br><span class="line">        initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// run all initializers</span></span><br><span class="line">    initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这一步由 <code>initializeMainExecutable()</code> 完成。dyld 会优先初始化动态库，然后初始化主程序。该函数首先执行 <code>runInitializers()</code>，内部再依次调用 <code>processInitializers()</code>、<code>recursiveInitialization()</code>。在 <code>processInitializers()</code> 之后会发送 <code>dyld_image_state_initialized</code> 通知。</p>
<p>在 <code>recursiveInitialization()</code> 的实现中有这么一行代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>注释告诉我们，这个函数主要目的是让 objc 知道 image 即将被初始化。之后执行初始化操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="keyword">this</span>-&gt;doInitialization(context);</span><br></pre></td></tr></table></figure>

<p>在 <code>doInitialization()</code> 中首先调用了 <code>doImageInit()</code> ，然后调用 <code>doModInitFunctions()</code> 。</p>
<p><code>doImageInit</code> 执行镜像的初始化函数，也就是 LC_ROUTINES_COMMAND中记录的函数，然后再执行 <code>doModInitFunctions</code> 来解析并执行<em>DATA</em> 中<strong>mod_init_func 这个 section 中保存的函数。_mod_init_funcs 中保存的是全局C++对象的构造函数以及所有带 `</strong>attribute__((constructor)` 的C函数。</p>
<p>可以简单的写几行代码验证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void init_test() &#123;</span><br><span class="line">    printf(&quot;init_test called&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static TestClass t;</span><br></pre></td></tr></table></figure>

<p>代码编译后可以使用 <a href="https://sourceforge.net/projects/machoview/" target="_blank" rel="noopener">MachOView</a>来查看 Mach-O 中的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/03.png" alt=""></p>
<p>可以看到 _mod_init_funcs 这个 section 中刚好有两个数据。</p>
<p>继续回到 <code>doInitialization()</code> 函数，在其实现中我们可以找到最终调用的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide);</span><br><span class="line"><span class="keyword">if</span> ( context.verboseInit )</span><br><span class="line">	dyld::<span class="built_in">log</span>(<span class="string">"dyld: calling -init function 0x%p in %s\n"</span>, func, <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br></pre></td></tr></table></figure>

<p><code>Initializer</code>  是一个指向初始化方法的函数指针，这里的初始化方法就是上面 __mod_init_func 这个 section 中保存的函数。</p>
<p>我们可以通过添加 DYLD_PRINT_INITIALIZERS 环境变量在打印程序中依赖库的 <code>initializer</code> 方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/04.png" alt=""></p>
<p>从打印中可以看到最先调用 libSystem.B.dylib 的 initializer :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**dyld: calling initializer function 0x7fff780ee94c in &#x2F;usr&#x2F;lib&#x2F;libSystem.B.dylib**</span><br></pre></td></tr></table></figure>

<p>可以从<a href="https://opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c.auto.html" target="_blank" rel="noopener">这里</a>找到 libSystem 的 initializer 的完整实现。这里截取了部分代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_libkernel_init(libkernel_funcs);</span><br><span class="line"></span><br><span class="line">bootstrap_init();</span><br><span class="line">mach_init();</span><br><span class="line">pthread_init();</span><br><span class="line">__libc_init(vars, libSystem_atfork_prepare, libSystem_atfork_parent, libSystem_atfork_child, apple);</span><br><span class="line">__keymgr_initializer();</span><br><span class="line">_dyld_initializer();</span><br><span class="line">libdispatch_init();</span><br></pre></td></tr></table></figure>

<p>这里我们只要关注一下 <code>libdispatch_init()</code> 函数。因为 <code>libdispatch_init()</code>  函数最终调用了 runtime 的初始化方法 <code>_objc_init</code>。我们可以打个符号断点来验证一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/05.png" alt=""></p>
<p>这里可以看到 <code>_objc_init</code> 调用的顺序，先 <code>libSystem_initializer</code> 调用 <code>libdispatch_init</code> 再到 <code>_objc_init</code> 初始化 runtime。</p>
<p>这样从<a href="https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/" target="_blank" rel="noopener">这里</a>找到 <code>libdispatch_init()</code> 函数的实现。其中有这么几个函数调用： </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_dispatch_hw_config_init();</span><br><span class="line">_dispatch_time_init();</span><br><span class="line">_dispatch_vtable_init();</span><br><span class="line">_os_object_init();</span><br><span class="line">_voucher_init();</span><br><span class="line">_dispatch_introspection_init();</span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>_os_object_init()</code> 函数实现中发现确实调用了 <code>_objc_init()</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_os_object_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 runtime 被初始化了。</p>
<h5 id="查找入口点并返回"><a href="#查找入口点并返回" class="headerlink" title="查找入口点并返回"></a>查找入口点并返回</h5><p>这一步调用主程序的 <code>getEntryFromLC_MAIN()</code>，从加载命令读取 LC_MAIN入口，如果没有 LC_MAIN 就调用 <code>getEntryFromLC_UNIXTHREAD()</code> 读取LC_UNIXTHREAD，找到后就跳到入口点指定的地址并返回。<br>至此，整个dyld的加载过程就完成了。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原理 dyld</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS核心动画: Core Animation</title>
    <url>/ck9grdnzy000ieyye5dms1ut2/</url>
    <content><![CDATA[<p>我们写的应用程序往往都不是静态的，因为它们需要适应用户的需求以及为执行各种任务而改变状态。一个好的动画清晰地向我们解释了，这些状态变化时界面正在发生什么。在了解了动画背后的基本原理后，你会发现原来实现一个动画并不那么困难。</p>
<a id="more"></a>

<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>在开始写第一个动画之前，有必要了解一下 Core Animation 。</p>
<p>从字面上来理解，大部分人会以为它是只是用来做动画的，但实际上它是从一个叫做 Layer Kit 这么一个不怎么和动画有关的名字演变而来，所以做动画这只是 Core Animation 特性的冰山一角。<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html" target="_blank" rel="noopener">Apple 官网</a>是这么解释 Core Animation 的：</p>
<blockquote>
<p>Core Animation is a graphics rendering and animation infrastructure available on both iOS and OS X that you use to animate the views and other visual elements of your app.</p>
</blockquote>
<p>核心动画是一iOS和Mac OS平台上负责图形渲染和动画的基础框架。它并不是绘图系统本身，它是一个基础设施，用于在硬件中合成和操纵应用程序的内容。这个基础设施的核心是图层对象(CALayer)，你可以使用它来管理和操纵你的内容。</p>
<p>它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于是这个树形成了UIKit以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。</p>
<p>Core Animation位于AppKit和UIKit下，并且与Cocoa和Cocoa Touch的视图工作流紧密集成。</p>
<p><img src="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Art/ca_architecture_2x.png" alt=""></p>
<p>使用 Core Animation 做动画，我们只需要设置一些简单的动画参数(例如起点和终点)然后告诉它开始动画即可，其他的工作Core Animation 都会为我们搞定。而所有这些动画产生作用的地方就是 CALayer 。</p>
<p>使用 Core Animation 创建的大部分动画都涉及修改Layer的属性。 像视图一样，图层对象也具有bounds，position，opacity等属性，对于大多数这些属性，更改属性的值将会创建一个隐式动画，从而使图层从旧值动画到新值。在我们需要对动画行为进行更多控制的情况下，可以显式地为这些属性设置动画。不过有一点需要说明的是，当把动画添加到一个 layer 时，是不直接修改它的属性的。</p>
<p>Core Animation 维护了三个平行layer层次结构：model layer tree（模型层树）、presentation layer tree（表示层树）和 rendering tree（渲染树）。模型层树反映了我们能直接看到的 layers 的状态，表示层树则是动画正在表现的值的近似。</p>
<p>所以当我们在 view 上增加一个渐出动画。如果在动画中的任意时刻，查看 layer 的 opacity 值，你是得不到与屏幕内容对应的透明度的。你应该查看 presentation layer 的 opacity 值以获得正确的结果。</p>
<p>通过使用 <code>[CALayer presentationLayer]</code> 和 <code>[CALayer modelLayer]</code>，你可以在两个 layer 之间轻松切换。</p>
<h2 id="开始动画吧"><a href="#开始动画吧" class="headerlink" title="开始动画吧"></a>开始动画吧</h2><h3 id="基础动画（CABasicAnimation）"><a href="#基础动画（CABasicAnimation）" class="headerlink" title="基础动画（CABasicAnimation）"></a>基础动画（CABasicAnimation）</h3><p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coreanimation/car.gif" alt=""></p>
<p>像上图中通过修改坐标值来进行动画是比较常见和简单的。使用 CABasicAnimation，我们可以如下实现这个动画：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *carAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position.x"</span>];</span><br><span class="line">carAnimation.fromValue = @<span class="number">65</span>;</span><br><span class="line">carAnimation.toValue = @(<span class="keyword">self</span>.view.frame.size.width);</span><br><span class="line">carAnimation.duration = <span class="number">4</span>;</span><br><span class="line">[<span class="keyword">self</span>.carLayer addAnimation:carAnimation forKey:<span class="string">@"carAnimation"</span>];</span><br></pre></td></tr></table></figure>

<p>在这里，我使用<code>animationWithKeyPath:</code>来创建 <code>CABasicAnimation</code> 对象，这说明动画会改变 layer 的x-position，这是 Core Animation 一个非常方便的特性，完整的 keyPath 列表可以看<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html" target="_blank" rel="noopener">这里</a></p>
<p>然而，当我们运行该代码时，我们会发现当汽车在完成动画后马上回到了初始位置。这是因为在默认情况下，动画不会在超出其持续时间后还修改 presentation layer。实际上，在结束时它会被彻底移除。一旦动画被移除，presentation layer 将回到 model layer 的值，并且因为我们从未修改该 layer 的 position 属性，所以我们的汽车将重新出现在它开始的地方。</p>
<p>我们有两种方法来解决这个问题：</p>
<p>第一种方法是直接在 model layer 上更新属性。这是个人比较推荐的的做法。<br>一旦动画完成并且从 layer 中移除，presentation layer 将回到 model layer 设置的值，而这个值恰好与动画最后一个步骤相匹配。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *carAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position.x"</span>];</span><br><span class="line">carAnimation.fromValue = @<span class="number">65</span>;</span><br><span class="line">carAnimation.toValue = @(<span class="keyword">self</span>.view.frame.size.width);</span><br><span class="line">carAnimation.duration = <span class="number">4</span>;</span><br><span class="line">[<span class="keyword">self</span>.carLayer addAnimation:carAnimation forKey:<span class="string">@"carAnimation"</span>];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">self</span>.carLayer.position = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.frame.size.width+<span class="number">58</span>, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.view.bounds) - <span class="number">78</span>);</span><br></pre></td></tr></table></figure>

<p>第二张方式是通过设置动画的 <code>fillMode</code> 属性为 <code>kCAFillModeForward</code> 以留在最终状态，并设置 <code>removedOnCompletion</code> 为 <code>NO</code> 以防止它被自动移除：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *carAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position.x"</span>];</span><br><span class="line">carAnimation.fromValue = @<span class="number">65</span>;</span><br><span class="line">carAnimation.toValue = @(<span class="keyword">self</span>.view.frame.size.width);</span><br><span class="line">carAnimation.duration = <span class="number">4</span>;</span><br><span class="line">carAnimation.fillMode = kCAFillModeForwards;</span><br><span class="line">carAnimation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">[<span class="keyword">self</span>.carLayer addAnimation:carAnimation forKey:<span class="string">@"carAnimation"</span>];</span><br></pre></td></tr></table></figure>

<p>如果将已完成的动画保持在 layer 上时，会造成额外的开销，因为渲染器会去进行额外的绘画工作。</p>
<p>实际上我们创建的动画对象在被添加到 layer 时立刻就复制了一份。这个特性在多个 view 中重用动画时这非常有用。比方说我们想要第二辆汽车在第一辆汽车启动不久后也开始启动：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CABasicAnimation</span> *carAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position.x"</span>];</span><br><span class="line">carAnimation.fromValue = @<span class="number">65</span>;</span><br><span class="line">carAnimation.toValue = @(<span class="keyword">self</span>.view.frame.size.width);</span><br><span class="line">carAnimation.duration = <span class="number">4</span>;</span><br><span class="line">[<span class="keyword">self</span>.carLayer addAnimation:carAnimation forKey:<span class="string">@"carAnimation"</span>];</span><br><span class="line"><span class="keyword">self</span>.carLayer.position = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.frame.size.width+<span class="number">58</span>, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.view.bounds) - <span class="number">78</span>);</span><br><span class="line">  </span><br><span class="line">carAnimation.beginTime = <span class="built_in">CACurrentMediaTime</span>() + <span class="number">1.5</span>;</span><br><span class="line">[<span class="keyword">self</span>.carLayer2 addAnimation:carAnimation forKey:<span class="string">@"carAnimation"</span>];</span><br><span class="line"><span class="keyword">self</span>.carLayer2.position = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.view.frame.size.width+<span class="number">58</span>, <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.view.bounds) - <span class="number">78</span>);</span><br></pre></td></tr></table></figure>
<p>正是由于 <code>addAnimation:</code>时，<code>carAnimation</code> 被复制了，所以当我们设置动画的 <code>beginTime</code> 为未来1.5时，并没用影响到 <code>carLayer</code>，只有 <code>carLayer2</code> 受到了影响。</p>
<h3 id="关键帧动画（CAKeyframeAnimation）"><a href="#关键帧动画（CAKeyframeAnimation）" class="headerlink" title="关键帧动画（CAKeyframeAnimation）"></a>关键帧动画（CAKeyframeAnimation）</h3><p>通常情况下，我们使用 <code>CABasicAnimation</code> 就可以创建一些简单的动画，例如上面例子中的小汽车的移动。现在我们可以使用 <code>CAKeyframeAnimation</code> 来实现更复杂的动画。</p>
<p>关键帧（keyframe）使我们能够定义动画中任意的一个点，然后让 Core Animation 填充所谓的中间帧。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coreanimation/18436043320170223145213034.gif" alt=""></p>
<p>使用 <code>CAKeyframeAnimation</code>来制作上面的动画非常简单：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> *animation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"transform.scale"</span>];</span><br><span class="line">animation.values = @[ @<span class="number">1</span>, @<span class="number">1.2</span>, @<span class="number">0.8</span>, @<span class="number">1.2</span>, @<span class="number">1</span>];</span><br><span class="line">animation.keyTimes = @[ @<span class="number">0</span>, @(<span class="number">1</span>/<span class="number">6.0</span>), @(<span class="number">3</span>/<span class="number">6.0</span>), @(<span class="number">5</span>/<span class="number">6.0</span>), @<span class="number">1</span>];</span><br><span class="line">animation.duration = <span class="number">1</span>;</span><br><span class="line">animation.repeatCount = HUGE_VALF;</span><br><span class="line">[<span class="keyword">self</span>.heartLayer addAnimation:animation forKey:<span class="string">@"heart"</span>];</span><br></pre></td></tr></table></figure>

<p><code>values</code> 数组定义了关键帧的位置。<br>设置 <code>keyTimes</code> 属性让我们能够指定关键帧动画发生的时间。它们被指定为关键帧动画总持续时间的一个分数。</p>
<h4 id="在关键帧动画中使用路径"><a href="#在关键帧动画中使用路径" class="headerlink" title="在关键帧动画中使用路径"></a>在关键帧动画中使用路径</h4><p>向上面那样将动画一些关键帧存储到 <code>values</code>数组中，在实现一个路径复杂的动画时，并不是一个好的选择，CAKeyframeAnimation 为我们提供了更加便利的 <code>path</code> 属性作为代替。</p>
<p>先让我们来实现一个外星飞船绕着地球做圆周运动的动画：<br><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coreanimation/18436043320170223160215019.gif" alt=""></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CAKeyframeAnimation</span> * animation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"position"</span>];</span><br><span class="line">  </span><br><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithArcCenter:<span class="keyword">self</span>.view.center radius:<span class="number">150</span> startAngle:<span class="number">0</span> endAngle:M_PI*<span class="number">2</span> clockwise:<span class="number">1</span>];</span><br><span class="line">animation.path = path.CGPath;</span><br><span class="line">animation.duration = <span class="number">5</span>;</span><br><span class="line">animation.repeatCount = HUGE_VALF;</span><br><span class="line">animation.rotationMode = kCAAnimationRotateAuto;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.spaceshipLayer addAnimation:animation forKey:<span class="string">@"path"</span>];</span><br></pre></td></tr></table></figure>

<p>这里我使用 <code>UIBezierPath</code> 创建一个圆形的 CGPath 作为我们的关键帧动画的 path。然后动画就会按我们的预期那样运行了。这里有一个比较重要的属性: <code>rotationMode</code>。设置 <code>rotationMode</code> 属性为 <code>kCAAnimationRotateAuto</code> 确保飞船沿着路径旋转。如果我们不设置该属 那动画会是什么样的呢。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coreanimation/18436043320170223160237065.gif" alt=""></p>
<p>这样就看出了差别吧。飞船旋转的动作系统自动帮我们做好了，当然我们可以使用 <code>CAAnimationGroup</code> 自己去实现。</p>
<h3 id="动画组（CAAnimationGroup）"><a href="#动画组（CAAnimationGroup）" class="headerlink" title="动画组（CAAnimationGroup）"></a>动画组（CAAnimationGroup）</h3><p>对于某些复杂的效果，可能需要同时为多个属性进行动画，这时就可以使用 <code>CAAnimationGroup</code> 来组合多个动画了。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS Animations</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS渲染原理</title>
    <url>/ck9grdnzz000keyye5v2p3stc/</url>
    <content><![CDATA[<p>在说清楚iOS中的界面是如何被绘制并显示在屏幕上之前，有必要了解一下iOS中的 <code>UIView</code> 和 <code>CALayer</code>。<br>在iOS当中，所有的视图都从一个叫做 <code>UIVIew</code> 的基类派生而来，<code>UIView</code> 可以处理触摸事件，可以支持基于Core Graphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<a id="more"></a>

<h2 id="CALayer"><a href="#CALayer" class="headerlink" title="CALayer"></a>CALayer</h2><p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。<br>CALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内。</p>
<p>每一个UIview都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。<br>实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<p>一个 Layer 的 frame 是由它的 <code>anchorPoint</code>, <code>position</code>, <code>bounds</code> 和 <code>transform</code> 共同决定的，而一个 View 的 <code>frame</code> 只是简单的返回 Layer的 <code>frame</code>，同样 View 的 <code>center</code> 和 <code>bounds</code> 也是返回 Layer 的一些属性。</p>
<h2 id="UIView的显示过程"><a href="#UIView的显示过程" class="headerlink" title="UIView的显示过程"></a>UIView的显示过程</h2><p>动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序。这个进程就是所谓的渲染服务。在iOS5和之前的版本是 <code>SpringBoard</code> 进程（同时管理着iOS的主屏）。在iOS6之后的版本中叫做<code>BackBoard</code>。</p>
<p>当显示view或者运行一段动画时候，这个过程会被四个分离的阶段被打破：</p>
<ul>
<li>布局 - 这是准备你的视图/图层的层级关系，以及设置图层属性（位置，背景色，边框等等）的阶段。</li>
<li>显示 - 这是图层的寄宿图片被绘制的阶段。绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径。</li>
<li>准备 - 这是Core Animation准备发送动画数据到渲染服务的阶段。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。</li>
<li>提交 - 这是最后的阶段，Core Animation打包所有图层和动画属性，然后通过IPC（内部处理通信）发送到渲染服务进行显示。</li>
</ul>
<p>但是这些仅仅阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有更多的工作。一旦打包的图层和动画到达渲染服务进程，他们会被反序列化来形成另一个叫做渲染树的图层树。使用这个树状结构，渲染服务对动画的每一帧做出如下工作：</p>
<ul>
<li>对所有的图层属性计算中间值，设置OpenGL几何形状（纹理化的三角形）来执行渲染</li>
<li>在屏幕上渲染可见的三角形</li>
</ul>
<p>所以一共有六个阶段；最后两个阶段在动画过程中不停地重复。前五个阶段都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你真正只能控制前两个阶段：布局和显示。Core Animation框架在内部处理剩下的事务。</p>
<h2 id="界面的绘制和渲染"><a href="#界面的绘制和渲染" class="headerlink" title="界面的绘制和渲染"></a>界面的绘制和渲染</h2><p>UIView是如何显示到屏幕上的?</p>
<p>这件事要从RunLoop开始，RunLoop是一个60fps的回调，也就是说每16.7ms绘制一次屏幕，也就是我们需要在这个时间内完成view的缓冲区创建，view内容的绘制这些是CPU的工作；然后把缓冲区交给GPU渲染，这里包括了多个View的拼接(Compositing),纹理的渲染(Texture)等等，最后Display到屏幕上。但是如果你在16.7ms内做的事情太多，导致CPU，GPU无法在指定时间内完成指定的工作，那么就会出现卡顿现象，也就是丢帧。<br>60fps是Apple给出的最佳帧率，但是实际中我们如果能保证帧率可以稳定到30fps就能保证不会有卡顿的现象，60fps更多用在游戏上。所以如果你的应用能够保证33.4ms绘制一次屏幕，基本上就不会卡了。</p>
<p>总的来说，UIView从Draw到Render的过程有如下几步：</p>
<ul>
<li>每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store。</li>
<li>UIView的绘制和渲染是两个过程，当UIView被绘制时，CPU执行drawRect，通过context将数据写入backing store。</li>
<li>当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上。</li>
</ul>
<p>其实说到底CPU就是做绘制的操作把内容放到缓存里，GPU负责从缓存里读取数据然后渲染到屏幕上。</p>
<p>下图就是从CPU到GPU的过程：</p>
<p><img src="http://cc.cocimg.com/api/uploads/20160928/1475056442197233.jpeg" alt=""></p>
<p>通常来说，计算机系统中 CPU、GPU、显示器是以上面这种方式协同工作的。CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号如下图所示，逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/render/18436043320170222134916051.jpg" alt=""></p>
<p>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。从上图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p>
<h3 id="离屏渲染-Offscreen-Rendering-And-Mask"><a href="#离屏渲染-Offscreen-Rendering-And-Mask" class="headerlink" title="离屏渲染(Offscreen Rendering And Mask)"></a>离屏渲染(Offscreen Rendering And Mask)</h3><p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/render/18436043320170222133323050.png" alt=""></p>
<p>UIKit是iOS中用来管理用户图形交互的框架，但是UIKit本身构建在Core Animation框架（Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角）之上，Core Animation分成了两部分OpenGL ES和Core Graphics，OpenGL ES是直接调用底层的GPU进行渲染；Core Graphics是一个基于CPU的绘制引擎；</p>
<p>在OpenGL中，GPU屏幕渲染有以下两种方式：</p>
<ol>
<li>On-Screen Rendering，意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li>
<li>Off-Screen Rendering，意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 </li>
</ol>
<p>如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：<strong>CPU渲染</strong>。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。</p>
<p>离屏渲染的代价主要包括两方面内容：</p>
<ul>
<li>创建新的缓冲区</li>
<li>上下文的切换，离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。</li>
</ul>
<p>为什么需要离屏渲染？</p>
<p>目的在于当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，即当主屏的还没有绘制好的时候，所以就需要屏幕外渲染，最后当主屏已经绘制完成的时候，再将离屏的内容转移至主屏上。</p>
<p>离屏渲染的触发方式：</p>
<ul>
<li><code>shouldRasterize</code>（光栅化）</li>
<li><code>masks</code>（遮罩）</li>
<li><code>shadows</code>（阴影）</li>
<li><code>edge antialiasing</code>（抗锯齿）</li>
<li><code>group opacity</code>（不透明）</li>
</ul>
<p>上述的一些属性设置都会产生离屏渲染的问题，大大降低GPU的渲染性能。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcodebuild的使用</title>
    <url>/ck9grdo01000oeyyedip82an7/</url>
    <content><![CDATA[<p><strong>xcodebuild</strong> 用于构建 Xcode 项目中包含的一个或多个<strong>target</strong> ，或者构建一个包含在 Xcode 工作区或 Xcode 项目的 <strong>scheme</strong></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcodebuild [-project projectname] [-target targetname ...] </span><br><span class="line">           [-configuration 	configurationname]</span><br><span class="line">           [-sdk [sdkfullpath | sdkname]] [buildaction ...] </span><br><span class="line">           [setting&#x3D;value ...] [-userdefault&#x3D;value ...]</span><br><span class="line">           </span><br><span class="line">xcodebuild [-project projectname] -scheme schemename </span><br><span class="line">           [-destination destinationspecifier]</span><br><span class="line">           [-destination-timeout value] [-configuration configurationname]</span><br><span class="line">           [-sdk [sdkfullpath | sdkname]] [buildaction ...] </span><br><span class="line">           [setting&#x3D;value ...] [-userdefault&#x3D;value ...]</span><br><span class="line">           </span><br><span class="line">xcodebuild -workspace workspacename -scheme schemename </span><br><span class="line">           [-destination destinationspecifier]</span><br><span class="line">           [-destination-timeout value] [-configuration configurationname]</span><br><span class="line">           [-sdk [sdkfullpath | sdkname]] [buildaction ...] </span><br><span class="line">           [setting&#x3D;value ...] [-userdefault&#x3D;value ...]</span><br><span class="line">           </span><br><span class="line">xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem]</span><br><span class="line">xcodebuild -showsdks</span><br><span class="line">xcodebuild -list [-project projectname | -workspace workspacename]</span><br><span class="line"></span><br><span class="line">xcodebuild -exportArchive -exportFormat format </span><br><span class="line">           -archivePath xcarchivepath </span><br><span class="line">           -exportPath destinationpath </span><br><span class="line">           [-exportProvisioningProfile profilename] </span><br><span class="line">           [-exportSigningIdentity identityname] </span><br><span class="line">           [-exportInstallerIdentity identityname]</span><br></pre></td></tr></table></figure>



<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>要构建一个Xcode项目，请从包含项目的目录运行 <strong>xcodebuild</strong>（即包含 projectname.xcodeproj 的目录）。如果你在这目录中有多个项目，需要使用 <strong>-project</strong> 来指明应该构建哪个项目。默认情况下， <strong>xcodebuild</strong> 会使用默认的构建配置构建项目中列出的第一个 target。 target 的顺序是项目的一个属性，对于项目的所有用户都是一样的。</p>
<p>要构建 Xcode 工作区，你必须同时传递 <strong>-workspace</strong> 和 <strong>-scheme</strong> 选项来定义构建。<strong>scheme</strong> 的参数将控制构建哪些 target 以及它们是如何构建的。不过你仍然可以将其他选项传递给 <strong>xcodebuild</strong> 来覆盖该 scheme 的一些参数。</p>
<p>还有几个参数可以显示有关已安装的Xcode版本或本地目录中项目或工作区的信息，但不启动构建。包括 <strong>-version</strong>, <strong>-showsdks</strong> 和 <strong>-usage</strong>。</p>
<h4 id="选项-options"><a href="#选项-options" class="headerlink" title="选项(options)"></a>选项(options)</h4><ul>
<li><p><strong>-project</strong> projectname<br>  构建由 projectname 指定的项目。如果在同一个目录下有多个项目文件，该选项是必需的。</p>
</li>
<li><p><strong>-target</strong> targetname<br>  构建由 targetname 指定的目标。</p>
</li>
<li><p><strong>-alltargets</strong><br>  构建指定项目中的所有目标</p>
</li>
<li><p><strong>-workspace</strong> workspacename<br>  构建由workspacename指定的工作空间。</p>
</li>
<li><p><strong>-scheme</strong> schemename<br>  构建由 schemename 指定的方案。如果构建一个 workspace ，则为必需。</p>
</li>
<li><p><strong>-destination</strong> destinationspecifier<br>  使用由 destinationpecifier 描述的目标设备。默认为与选定scheme兼容的 destination。</p>
</li>
<li><p><strong>-destination-timeout</strong> timeout<br>  在搜索目标设备时使用的超时时间。默认值是30秒。</p>
</li>
<li><p><strong>-configuration</strong> configurationname<br>  在构建每个 target 时使用由 configurationname 指定的构建配置。</p>
</li>
<li><p><strong>-arch</strong> architecture<br>  构建每个 target 时使用的 architecture。</p>
</li>
<li><p><strong>-sdk</strong> [<sdkfullpath> | <sdkname>]<br>  使用适合于该 SDK 的构建工具，针对指定的 SDK 构建 Xcode 项目或工作区。参数可以是 SDK 的绝对路径，也可以是 SDK 的名称。</p>
</li>
<li><p><strong>-showsdks</strong><br>  列出 Xcode 中所有可用的 SDK，包括适合与 <code>-sdk</code> 一起使用的规范名称。不会启动构建。</p>
</li>
<li><p><strong>-list</strong><br>  列出项目中的所有 target 和配置，或工作区中的 scheme。不会启动构建。</p>
</li>
<li><p><strong>-derivedDataPath</strong> path<br>  在执行构建操作时覆盖用于 derived data 的文件夹。</p>
</li>
<li><p><strong>-resultBundlePath</strong> path<br>  将包绑定到指定的路径，并在其中的方案上执行构建操作。</p>
</li>
<li><p><strong>-exportArchive</strong><br>  指定应导出归档。 需要<code>-exportFormat</code>，<code>-archivePath</code>和<code>-exportPath</code>。 不能与构建操作一起使用。</p>
</li>
<li><p><strong>-exportFormat</strong> format<br>  指定归档应该导出到的格式。有效的格式是IPA（iOS），PKG（Mac）和APP。 如果未指定xcodebuild 将尝试自动检测格式为IPA或PKG。</p>
</li>
<li><p><strong>-archivePath</strong> xcarchivepath<br>  指定归档操作生成的归档的路径，或者指定归档在<code>-exportArchive</code>时被导出。</p>
</li>
<li><p><strong>-exportPath</strong> destinationpath<br>  指定导出产品的目的路径，包括导出文件的名称。</p>
</li>
<li><p><strong>-exportProvisioningProfile</strong> profilename<br>  指定导出归档时使用的 provisioning profile 文件。</p>
</li>
<li><p><strong>-exportSigningIdentity</strong> identityname<br>  指定导出归档时使用的应用程序签名标识。如果可能的话，这可以从<code>-exportProvisioningProfile</code>中推断出来。</p>
</li>
<li><p><strong>-exportInstallerIdentity</strong> identityname<br>  指定导出归档时使用的安装程序签名标识。、也可以从<code>-exportSigningIdentity</code>或<code>-exportProvisioningProfile</code>中推断出来。</p>
</li>
<li><p><strong>-exportWithOriginalSigningIdentity</strong><br>  指定在导出文件时使用的用于创建归档的签名标识。</p>
</li>
</ul>
<h5 id="buildaction-…"><a href="#buildaction-…" class="headerlink" title="buildaction …"></a>buildaction …</h5><p>指定要在 target 上执行的构建操作（或多个操作）:</p>
<table>
<thead>
<tr>
<th>action</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>build</td>
<td>在构建根目录（SYMROOT）中构建目标。这是默认的构建操作。</td>
</tr>
<tr>
<td>analyze</td>
<td>从构建根目录（SYMROOT）构建和分析target或scheme。需要指定一个scheme。</td>
</tr>
<tr>
<td>archive</td>
<td>从构建根目录（SYMROOT）归档一个scheme。需要指定一个scheme。</td>
</tr>
<tr>
<td>test</td>
<td>从构建根目录（SYMROOT）测试一个scheme。这需要指定一个scheme和一个目的地。</td>
</tr>
<tr>
<td>installsrc</td>
<td>将项目源复制到源根目录（SRCROOT）。</td>
</tr>
<tr>
<td>install</td>
<td>构建target并将其安装到 DSTROOT 中的目标安装目录中。</td>
</tr>
<tr>
<td>clean</td>
<td>从构建根目录（SYMROOT）中删除构建产品和中间文件。</td>
</tr>
</tbody></table>
<h5 id="Destinations"><a href="#Destinations" class="headerlink" title="Destinations"></a>Destinations</h5><p><strong>-destination</strong>选项采用描述设备（或多个设备）作为目的地的目标说明符作为其参数。目标说明符是由一组逗号分隔的键值对组成的单个参数。 可以多次指定<strong>-destination</strong>选项，以使<strong>xcodebuild</strong>在多个目标上执行指定的操作。</p>
<p>目标说明符可能包含平台密钥以指定其中一个受支持的目标平台。 应根据您选择的设备的平台提供附加的键</p>
<p>某些设备可能需要一些时间才能查找。 <strong>-destination-timeout</strong> 选项可用于指定在设备被认为不可用之前等待的时间。默认为30秒。</p>
<p>目前，xcodebuild支持这些平台：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OS X             本地 Mac，在Xcode界面中称为My Mac，支持以下内容: </span><br><span class="line">                 arch 要使用的体系结构，x86_64（默认）或者i386。</span><br><span class="line">                 </span><br><span class="line">iOS              iOS 设备，支持以下内容：</span><br><span class="line">                 name 使用的设备的名称</span><br><span class="line">                 id   在Xcode Organizer中“设备”选项卡中的设备的标识符。</span><br><span class="line">                 </span><br><span class="line">iOS Simulator    iOS 模拟器，支持以下内容: </span><br><span class="line">                 name 在 Xcode 的界面中提供的模拟器的全名。</span><br><span class="line">                 OS   要模拟的iOS版本（如6._）或最新字符串（默认值），以指示该版本Xcode   </span><br><span class="line">                 支持的最新iOS版本。</span><br></pre></td></tr></table></figure>
<p>e.g.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace MyWorkspace.xcworkspace -scheme MyScheme -destination <span class="string">'platform=OS X,arch=x86_64'</span> build</span></span><br></pre></td></tr></table></figure>


<h5 id="导出归档"><a href="#导出归档" class="headerlink" title="导出归档"></a>导出归档</h5><p><strong>-exportArchive</strong> 选项指定 <strong>xcodebuild</strong> 应该导出由 <strong>-archivePath</strong> 指定的归档并转换为 <strong>-exportFormat</strong> 指定的格式。导出的产品将放置在由 <strong>-exportPath</strong> 指定的路径中。 导出归档时重新签名是可选的。 配置文件(Provisioning Profile)可以由 <strong>-exportProvisioningProfile</strong> 指定。在某些情况下，应该在导出期间使用的应用程序签名标识可以从配置文件中确定。对于不可能的情况（包括在导出产品中没有嵌入配置文件的情况），可以使用 <strong>-exportSigningIdentity</strong> 指定应用程序签名标识。将 Mac 归档文件导出为 PKG 时，可以使用安装程序签名标识对导出的包进行签名。 这可以从应用程序签名标识中推断出来（例如，如果为应用程序签名标识指定了“Developer ID Application”，则将自动推断“Developer ID Installer”），也可以使用<strong>-exportInstallerIdentity</strong>明确指定它。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild clean install</span></span><br></pre></td></tr></table></figure>
<p>清理构建目录; 然后在 <strong>xcodebuild</strong> 启动的目录中构建并安装 Xcode 项目中的第一个target。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -target MyTarget OBJROOT=/Build/MyProj/Obj.root SYMROOT=/Build/MyProj/Sym.root</span></span><br></pre></td></tr></table></figure>
<p>在 <strong>xcodebuild</strong> 开始的目录中的 Xcode 项目中构建 MyTarget，将中间文件放入<code>/Build/MyProj/Obj.root</code>目录中，并将构建的产品放入<code>/Build/MyProj/Sym.root</code>目录中。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -sdk macosx10.6</span></span><br></pre></td></tr></table></figure>
<p>在 Mac OS X 10.6 SDK 中启动 <strong>xcodebuild</strong> 的目录中生成 Xcode 项目。可以使用<strong>-showsdks</strong>选项查看所有可用SDK的名称。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace MyWorkspace.xcworkspace -scheme MyScheme</span></span><br></pre></td></tr></table></figure>
<p>在 Xcode 工作区 MyWorkspace.xcworkspace 中构建方案 MyScheme。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace MyWorkspace.xcworkspace -scheme MyScheme archive</span></span><br></pre></td></tr></table></figure>
<p>在 Xcode 工作区 MyWorkspace.xcworkspace 中归档方案 MyScheme。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace MyWorkspace.xcworkspace -scheme MyScheme -destination <span class="string">'platform=OS X,arch=x86_64'</span> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>在 Xcode 工作区 MyWorkspace.xcworkspace 中使用Xcode中描述为’platform=OS X,arch=x86_64’的目标测试 MyScheme 中的方案。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace MyWorkspace.xcworkspace -scheme MyScheme -destination <span class="string">'platform=iOS Simulator,name=iPhone'</span> -destination <span class="string">'platform=iOS,name=My iPad'</span> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -workspace MyWorkspace.xcworkspace -scheme MyScheme -destination generic/platform=iOS build</span></span><br></pre></td></tr></table></figure>
<p>使用通用 iOS 设备在 Xcode 工作区 MyWorkspace.xcworkspace 中构建方案 MyScheme。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -exportArchive -exportFormat IPA -archivePath MyMobileApp.xcarchive -exportPath MyMobileApp.ipa -exportProvisioningProfile <span class="string">'MyMobileApp Distribution Profile'</span></span></span><br></pre></td></tr></table></figure>
<p>使用 “MyMobileApp Distribution Profile” 配置文件将归档 MyMobileApp.xcarchive 作为 IPA 文件导出到MyMobileApp.ipa目录中。</p>
<hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xcodebuild -exportArchive -exportFormat APP -archivePath MyMacApp.xcarchive -exportPath MyMacApp.pkg -exportSigningIdentity <span class="string">'Developer ID Application: My Team'</span></span></span><br></pre></td></tr></table></figure>
<p>使用 “Developer ID Installer：My Team” 签名将 MyMacApp.xcarchive 作为 PKG 文件导出到MyMacApp.pkg目录中。</p>
]]></content>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关闭主板 CFG 锁</title>
    <url>/ck9grdo04000reyye42i27h6e/</url>
    <content><![CDATA[<p>在很多新的主板中都会有 “CFG Locak” 的选项，它的作用是关闭或者开启 MSR 0xe2 寄存器。</p>
<a id="more"></a>

<p><strong>MSR 0xE2</strong> 是 Model Specific Register 的一个寄存器位数锁定，属于非标准寄存器，是用来控制 CPU 的工作环境和读取工作状态，例如电压、温度、功耗等非程序性指标。而 Mac OS 的电源管理中 CPU 的 P-State (频率) 和 C-State (睡眠) 就是放在 MSR 寄存器里的。现在世面上大多数有 UEFI 的主板厂商默认都锁定了 MSR 寄存器，也就是 BIOS 中的 CFG Lock 是 Disable 的（如果你的主板 BIOS 有这个选项的话）。</p>
<p>如果 CFG Lock 是开启状态（即 MSR 0xE2 是被锁定的），MSR 0xE2 就是只读的，当 AppleIntelCPUPowernamegement 一旦去写入数据，马上就会内核崩溃。当我们使用黑苹果时就必须解锁 MSR 0xE2，否则就无法使用原生电源管理了。</p>
<p>如果你的主板 BIOS 有 “CFG Lock” 选项的话，那么你只需要关闭即可，如果很不幸没有该选项就可以按照下面的方式来关闭 CFG Lock。</p>
<h2 id="确认主板-CFG-Lock-是否上锁"><a href="#确认主板-CFG-Lock-是否上锁" class="headerlink" title="确认主板 CFG Lock 是否上锁"></a>确认主板 CFG Lock 是否上锁</h2><p>打开 Hackintool, 选则上面的 Tools（工具）选项，点击下边最左侧的 Intel 图标，输入密码，过几秒钟后就会显示大量内容，搜索 CFG 就能快速找到我们想要的内容，如果是 <code>CFG Lock............................. : 0 (MSR not locked)</code> 则表明已经解锁了 MSR，结果是 1 就表明没有解锁。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/cfglock/img1.png" alt=""></p>
<h2 id="关闭-CFG-Lock"><a href="#关闭-CFG-Lock" class="headerlink" title="关闭 CFG Lock"></a>关闭 CFG Lock</h2><p>在开始下面的工作之前，再强调一遍，如果你的主板 BIOS 有 “CFG Lock” 选项的话，那么你只需要关闭即可。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在正式开始之前，你需要下载下面的这些内容：</p>
<ul>
<li><a href="https://github.com/acidanthera/OpenCorePkg/releases" target="_blank" rel="noopener">VerifyMsrE2</a></li>
<li><a href="https://github.com/datasone/grub-mod-setup_var/releases" target="_blank" rel="noopener">Modifed GRUB Shell</a></li>
<li><a href="https://github.com/LongSoft/UEFITool/releases" target="_blank" rel="noopener">UEFITool</a> （看清楚名字千万不要下载错了）</li>
<li><a href="https://github.com/LongSoft/Universal-IFR-Extractor/releases" target="_blank" rel="noopener">Universal-IFR-Extractor</a></li>
</ul>
<p>然后在你的主板提供商的网站上下载对应版本的 BIOS。</p>
<h3 id="检查你的主板是否支持关闭-CFG-Lock"><a href="#检查你的主板是否支持关闭-CFG-Lock" class="headerlink" title="检查你的主板是否支持关闭 CFG Lock"></a>检查你的主板是否支持关闭 CFG Lock</h3><p>我们从下载的 OpenCore 包中，在 <code>EFI/OC/Tools</code> 可以找到 VerifyMsrE2.efi，通过它我们可以知道主板是否支持关闭 CFG Lock。</p>
<p>将下载好的 VerifyMsrE2.efi 拷贝到你的 <code>EFI/OC/Tools</code> 目录下。然后用 ProperTree 打开 <code>config.plis</code> , 在 <code>Misc -&gt; Tools</code> 中添加 <code>VerifyMsrE2.efi</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/cfglock/img3.png" alt=""></p>
<p>重启电脑，在 OpenCore 的引导界面中选择刚刚添加的 <code>VerifyMsrE2</code>，然后你就知道你的主板是否支持关闭 CFG Lock 了。</p>
<h3 id="手动开启"><a href="#手动开启" class="headerlink" title="手动开启"></a>手动开启</h3><h6 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h6><p>打开下载好的 UEFITool, 然后将下载好的 BIOS 文件拖到软件中，按下快捷鍵 <code>Command + F</code>，在窗口中点击 Text 选项，输入『CFG Lock』后点击 OK。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/cfglock/search_cfg_lock.png" alt="Example"></p>
<p>在最下面就会出现 <code>Unicode text &quot;CFG Lock&quot; found in PE32 image section at offset 85FD0h</code> 的信息。双击该信息，就会自动定位到包含有 CFG Lock 信息的模块, <code>PE32 image section</code>。选中 <code>PE32 image section</code>, 然后鼠标右键，选择 Extract body, 填好名称后保存到合适的位置，后缀名不要修改保持默认就好。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/cfglock/cfg_lock_section_info.png" alt=""></p>
<h6 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h6><p>在终端使用 <code>ifrextract</code> 将刚刚保存的文件转换为文本文件，命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">path/to/ifrextract path/to/youfile path/to/setup.txt</span><br></pre></td></tr></table></figure>

<div class="note warning"><p>上面命令中的路径请自行替换成自己实际的路径</p></div>

<h6 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h6><p>打开刚刚转换成功的文本文件，然后搜索 <code>CFG Lock, VarStoreInfo (VarOffset/VarName):</code>，我搜索到的结果是 <strong>CFG Lock, VarStoreInfo (VarOffset/VarName): 0x5C1</strong>，这里的 <strong>0x5C1</strong> 就是我们要找的偏移量, 可以看到后面 <code>VarStore: 0x1</code>, 这就代表是锁住的。我们做了这么多就是为了将该地址 (0x5C1) 的数据修改为 <code>0x0</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/cfglock/cfg_lock_address.png" alt=""></p>
<h6 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h6><p>将下载好的 <code>modGRUBShell.efi</code> 重命名为 <code>BOOTX64.efi</code>, 在一个空白的引导 U 盘内创建 <code>EFI</code> 文件夹，然后在 <code>EFI</code> 文件夹中创建 <code>BOOT</code> 文件夹，并将重命名的 <code>BOOTX64.efi</code> 放入其中。<br>如果没有引导 U 盘，可以把 U 盘插入电脑，然后格式化为 <code>fat32</code> 格式，命名为 <code>EFI</code> 就可以了。</p>
<p>重启电脑，选择从 U 盘启动，这将会启动 grub 模式，然后使用如下命令来解锁 MSR 0xE2:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setup_var 0x5C1 0x00</span><br></pre></td></tr></table></figure>

<p>设置好后你可以通过 <code>setup_var 0x5C1</code>， 来查看设置的值有没有成功，如果出现 <code>offset 0x5C1 is: 0x00</code>，则表示设置成功。</p>
<div class="note danger"><p>这里的 0x5C1 是笔者的偏移量，请一定要使用自己的。</p>
<p>请注意，可变偏移量不仅对于每个主板都是唯一的，甚至对于其固件版本也是唯一的。未经检查，切勿尝试使用偏移量。</p></div>

<h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>完成上面的工作后，你就成功的解锁了 MSR 0xE2。然后就可以将 config.plist 做如下设置：</p>
<p><code>Kernel -&gt; Quirk</code> 选项中：</p>
<ul>
<li><code>AppleCpuPmCfgLock</code> 设置为 <code>False</code></li>
<li><code>AppleXcpmCfgLock</code> 设置为 <code>False</code></li>
</ul>
<p><code>UEFI -&gt; Quirk</code> 选项中：</p>
<ul>
<li>IgnoreInvalidFlexRatio 设置为 <code>False</code></li>
</ul>
<p>至此关闭主板 CFG Lock 的整个工作就结束了，苹果原生电源管理也能正常工作了。</p>
]]></content>
      <categories>
        <category>Hackintosh</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>OpenCore</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Core Graphics绘制图形</title>
    <url>/ck9grdo08000weyye0sstgppb/</url>
    <content><![CDATA[<p>Core Graphic是iOS中一套基于C的框架，用于一切绘图操作，UIKit就是基于Core Graphic实现的，因此它可以实现比UIKit更底层的功能。</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coregraphics/18436043320170222133323050.png" alt=""></p>
<p>根据苹果的描述，UIKit是我们最容易也是最常接触到的框架。绝大多数图形界面都由UIKit完成。但是UIKit依赖于Core Graphics框架，也是基于Core Graphics框架实现的。如果想要完成某些更底层的功能或者追求极致的性能，那么依然推荐使用Core Graphics完成。</p>
<p>在使用Core Graphics进行绘图时，需要注意以下几点：</p>
<ol>
<li>Core Graphics其实是一套基于C的API框架，使用了Quartz作为绘图引擎。这也就意味着Core Graphics不是面向对象的。</li>
<li>Core Graphics需要一个图形上下文（Context）。所谓的图形上下文（Context），说白了就是一张画布。这一点非常容易理解，Core Graphics提供了一系列绘图API，自然需要指定在哪里画图。因此很多API都需要一个上下文（Context）参数。</li>
<li>Core Graphics的图形上下文（Context）是堆栈式的。只能在栈顶的上下文（画布）上画图。</li>
<li>Core Graphics中有一些API，名称不同却有着相似的功能，新手只需要掌握一种，并能够看懂其他的即可。</li>
</ol>
<h2 id="Core-Graphics的基本使用"><a href="#Core-Graphics的基本使用" class="headerlink" title="Core Graphics的基本使用"></a>Core Graphics的基本使用</h2><p>使用 Core Graphics 进行绘图可以总结为一下几个步骤：</p>
<ol>
<li>获取上下文（画布）</li>
<li>创建路径（自定义或者调用系统的API）并添加到上下文中。</li>
<li>进行绘图内容的设置（画笔颜色、粗细、填充区域颜色、阴影、连接点形状等）</li>
<li>开始绘图（CGContextDrawPath）</li>
<li>释放路径（CGPathRelease）</li>
</ol>
<p>为了使用Core Graphics来绘图，最简单的方法就是自定义一个类继承自UIView，并重写子类的drawRect方法。在这个方法中绘制图形。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 获取图形上下文</span><br><span class="line">  CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2. 创建路径</span><br><span class="line">  float radius &#x3D; MIN(self.bounds.size.width, self.bounds.size.height) * 0.5 - 4;</span><br><span class="line">  CGContextAddArc(ctx, self.frame.size.width&#x2F;2, self.frame.size.height&#x2F;2, radius, 0, M_PI*2, 1);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3. 设置绘制参数</span><br><span class="line">  CGContextSetLineWidth(ctx, 4);</span><br><span class="line">  CGContextSetRGBStrokeColor(ctx, 0, 0, 0, 1);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4. 绘制路径</span><br><span class="line">  CGContextStrokePath(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>CGContextRef</code> 创建路径后将清空图形上下文，如果我们想保存路径来复用，可以使用Quartz提供的CGPath函数集合来创建可复用的路径对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 获取图形上下文</span><br><span class="line">  CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2. 创建路径</span><br><span class="line">  CGMutablePathRef path &#x3D; CGPathCreateMutable();</span><br><span class="line">  </span><br><span class="line">  float radius &#x3D; MIN(self.bounds.size.width, self.bounds.size.height) * 0.5 - 4;</span><br><span class="line">  CGPathAddArc(path, NULL, self.frame.size.width&#x2F;2, self.frame.size.height&#x2F;2, radius, 0, M_PI*2, 1);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;将路径添加到上下文</span><br><span class="line">  CGContextAddPath(ctx, path);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3. 设置绘制参数</span><br><span class="line">  CGContextSetLineWidth(ctx, 4);</span><br><span class="line">  CGContextSetRGBStrokeColor(ctx, 0, 0, 0, 1);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4. 绘制路径</span><br><span class="line">  CGContextStrokePath(ctx);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 5. 释放路径</span><br><span class="line">  CGPathRelease(path);</span><br></pre></td></tr></table></figure>

<h3 id="使用UIBezierPath"><a href="#使用UIBezierPath" class="headerlink" title="使用UIBezierPath"></a>使用UIBezierPath</h3><p>UIBezierPath存在于UIKit中，是对路径绘制的封装，和CGContextRef类似，优点是更面向对象，我们可以像操作普通对象一样对其进行操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">  CGFloat radius &#x3D; MIN(self.bounds.size.width, self.bounds.size.height) * 0.5 - 4;</span><br><span class="line">  UIBezierPath *path &#x3D; [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.frame.size.width&#x2F;2, self.frame.size.height&#x2F;2) radius:radius startAngle:0 endAngle:M_PI*2 clockwise:1];</span><br><span class="line">  path.lineWidth &#x3D; 4;</span><br><span class="line">  [[UIColor blueColor] setStroke];</span><br><span class="line">  [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Core-Graphics绘制图片"><a href="#使用Core-Graphics绘制图片" class="headerlink" title="使用Core Graphics绘制图片"></a>使用Core Graphics绘制图片</h3><p>Core Graphics 不仅可以绘制图形，还可以绘制图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawImage &#123;</span><br><span class="line">  &#x2F;&#x2F; 1.开启上下文</span><br><span class="line">  UIGraphicsBeginImageContextWithOptions(self.dogImageView.bounds.size, NO, [UIScreen mainScreen].scale);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2.取得当前的上下文</span><br><span class="line">  CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3.设置上下文</span><br><span class="line">  CGContextSetFillColorWithColor(ctx, [UIColor orangeColor].CGColor);</span><br><span class="line">  CGContextFillRect(ctx, self.dogImageView.bounds);</span><br><span class="line">  &#x2F;&#x2F; 4.获取图片</span><br><span class="line">  self.dogImageView.image &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 5.关闭上下文</span><br><span class="line">  UIGraphicsEndImageContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开发中我们经常会有圆角图片的需求，我们也可以用<code>Core Graphics</code>来绘制圆角图片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coregraphics/18436043320170222164112080.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)circleImage &#123;</span><br><span class="line">  &#x2F;&#x2F; 1.开启上下文</span><br><span class="line">  UIGraphicsBeginImageContextWithOptions(self.dogImageView.bounds.size, NO, [UIScreen mainScreen].scale);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 2.取得当前的上下文</span><br><span class="line">  CGContextRef ctx &#x3D; UIGraphicsGetCurrentContext();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 3.添加路径</span><br><span class="line">  CGFloat radius &#x3D; self.dogImageView.frame.size.width &#x2F; 2;</span><br><span class="line">  CGContextAddArc(ctx, self.dogImageView.bounds.size.width&#x2F;2, self.dogImageView.bounds.size.height&#x2F;2, radius, 0, M_PI*2, 1);</span><br><span class="line">  CGContextClip(ctx);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 4.绘制图片</span><br><span class="line">  [self.dogImageView.image drawInRect:self.dogImageView.bounds];</span><br><span class="line">  self.dogImageView.image &#x3D; UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 5.关闭上下文</span><br><span class="line">  UIGraphicsEndImageContext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>开发你的第一个 Mac 应用</title>
    <url>/ck9grdo09000zeyyed9fk1jje/</url>
    <content><![CDATA[<p>以前我们都是开发 iOS 应用，今天让我们来做点不一样的，来开始开发 Mac OS  应用。</p>
<a id="more"></a>

<div class="note info"><p>由于云存储过期了，导致图片都无法显示了。</p></div>

<p>以前我们都是开发 iOS 应用，今天让我们来做点不一样的，来开始开发 Mac OS  应用。很多同学可能会觉得开发 Mac 应用是不是很挺难，不管你以前有没有 Mac 应用的开发经验，只有你按照下面的步骤来，你很快就能开发一款 Mac 应用了。</p>
<p>今天要做的不是普通的窗口应用，而是 Status Bar 应用。什么是 Status Bar 应用？就像下图中的就是 Status Bar 应用。这是不是比做一个窗口应用有趣多了。现在就开始吧。 </p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp00.png" alt=""></p>
<h1 id="Let-s-beging"><a href="#Let-s-beging" class="headerlink" title="Let`s beging"></a>Let`s beging</h1><p>首先打开你的 xCode 创建一个新工程，记住要选择 macOS，创建一个 Cocoa App。</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp01.png" alt=""></p>
<p>直接点击下一步。给你的工程取一个牛B哄哄的名字。有一点需要注意的是，Use Storyboards 和 Create Document-Based Application 单选框都不要选。</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp02.png" alt=""></p>
<p>语言就选择你最熟悉的语言就可以了，我这里选的是 Swift。如果你还没开始使用 Swift，那么我强烈建议你最好开始使用 Swift 来开发你的新应用。</p>
<p>选好你要将工程存放的位置，点击 Create 就完成了工程的创建了。</p>
<p>工程创建完后，你会发现有一个 MainMenu.xib 文件。打开它，这就是你的应用默认的样子了。</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp03.png" alt=""></p>
<p>你可以把 Objects 下面的 Main Menu 删掉，因为我们这个 App 中根本就用不到它，后面我们会添加自己的 Menu。</p>
<p>先暂时放下这个 xib 文件，让我们开始实现 Status Bar App吧。</p>
<h1 id="Status-Item"><a href="#Status-Item" class="headerlink" title="Status Item"></a>Status Item</h1><p>打开 AppleDelegate.swift 文件，让我们开始编写 Mac App 的第一行代码吧。在你的 AppleDelegate 类中创建一个 NSStatusItem：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> statusItem = <span class="type">NSStatusBar</span>.system.statusItem(withLength: <span class="type">NSStatusItem</span>.variableLength)</span><br></pre></td></tr></table></figure>

<p> 然后在 <code>applicationDidFinishLaunching</code>  添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">(<span class="number">_</span> aNotification: Notification)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> image = <span class="type">NSImage</span>(named: <span class="type">NSImage</span>.<span class="type">Name</span>(<span class="string">"Icon_32x32"</span>))</span><br><span class="line">    statusItem.highlightMode = <span class="literal">true</span></span><br><span class="line">    statusItem.image = image</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你需要把 <code>NSImage(named: NSImage.Name(&quot;Icon_32x32&quot;))</code> 中的图片名换成你自己的图片，并且别忘了把图片导入到项目中。现在你可以运行你的项目了。你会发现系统菜单栏中确实出现了刚刚你添加的 StatusItem，不过同时也出现了一个窗口，并且 Dock 栏中也显示了应用图标。这在我们的 Status Bar 应用中是不应该出现的。现在就先解决这两个问题。</p>
<p>要让我们的应用在运行时不要出现窗口很简单，你只需要打开 MainMenu.xib 文件，然后选中 Window，在右边的辅助编辑器中将 Visible At Launch 的单选框的勾选去掉就可以了。</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp04.png" alt=""></p>
<p>要让我们的应用图标从 Dock 栏中去掉，你只需要在 Info.plist 文件中添加一行 <code>Application is agent (UIElement)</code>，并将其设置为 YES 即可。再次运行你会发现不会再出现窗口了，应用图标也从Dock 栏中去掉了。是不是很赞呢。</p>
<p>现在点击菜单栏中的图标，没有任何功能，现在是时候给我们的应用添加一些功能了，就像上面图片中那个样子。</p>
<h1 id="添加-Menu"><a href="#添加-Menu" class="headerlink" title="添加 Menu"></a>添加 Menu</h1><p>再次打开 MainMenu.xib 文件，在右侧辅助编辑器的下面搜索 menu，然后将一个 Menu 拖动到 xib 中，它会自动出现在 Objects 下。</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp05.png" alt=""></p>
<p>默认情况下，Menu 中有三个 Menu Item，你可以将一个 Menu Item 拖到 Menu 中来添加更多的 Menu Item，当然，你也可以选中某一个，然后点击 <code>Delete</code> 键将其删掉。</p>
<p>这是我的菜单最终的样子:</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp06.png" alt=""></p>
<p>鼠标双击一个菜单栏左侧位置，你就可以给菜单栏添加标题了，双击一个菜单栏右侧位置，然后在键盘中键入你想输入的键，作为菜单栏功能的快捷键。</p>
<p>为了让菜单更好看，我在第二个菜单栏与第一个菜单栏和第三个菜单栏中间插入了一个分割线，要插入分割线很简单，只要将一个 Separator Menu Item 拖到你的 Menu 中就可以了。</p>
<p>我给第一个菜单栏添加了一个可以显示图片的视图。要想实现这个也很简单。你可以在右侧下面的 Object library 中将一个 Custom View 拖到 xib 中。然后在里面添加一个 Image View，并给 Image View 设置一个图片。就像下图这样:</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp07.png" alt=""></p>
<p>现在选中第一个菜单栏 (Item 1)，按住 <code>control</code> 键，拖动鼠标，在弹出框中选择 view，就像下图中的样子。</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp08.png" alt=""></p>
<p>我们创建了自己的菜单，现在只需要将菜单与 Status Item 联系起来。这个步骤同样很简单。将你的 Menu 创建一个 Outlet ，拖到 AppDelegate 中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> menu: <span class="type">NSMenu!</span></span><br></pre></td></tr></table></figure>

<p>然后在 <code>applicationDidFinishLaunching</code> 中添加下面一行代码:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">(<span class="number">_</span> aNotification: Notification)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    statusItem.menu = menu</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行你的应用，点击系统菜单栏中你的应用的图标，果然出现了刚刚在 xib 中创建的 Menu。现在你的 Status Bar 应用终于有模有样了。接着我们可以先实现菜单中的 Quit 功能。</p>
<p>在你的 xib 中选中 Quit 这个菜单栏，按住 <code>control</code> 键，拖动鼠标，在你的 AppDelegate 中创建一个 Action，然后在你的方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">quit</span><span class="params">(<span class="number">_</span> sender: NSMenuItem)</span></span> &#123;</span><br><span class="line">    <span class="type">NSApp</span>.terminate(<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以运行你的应用看看 Quit 是不是可以起效，不出意外，点击 Quit，你的应用就能退出了，同时快捷键也可以让你的应用退出了。</p>
<p>下图中就是应用最终的样子:</p>
<p><img src="http://othizsxsl.bkt.clouddn.com/macapp00.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面简单的几个步骤，我们很快就实现了自己的第一个 Status Bar 应用。为了让新手也能上手，所以文章写的比较啰嗦，如果你已经有过 iOS 的开发经验，那么你可以跳着看，完成这个简单的  Status Bar 应用可能都不会花费你5分钟时间。</p>
<p>最后总结一下创建我们的 Status Bar 应用的几个关键步骤：</p>
<ul>
<li>创建并设置 Status Item</li>
<li>隐藏系统提供的默认窗口</li>
<li>从 Dock 栏中隐藏应用图标</li>
<li>给 Status Item 添加 Menu</li>
<li>实现 Menu Item 的功能（退出功能）</li>
</ul>
<p>后面我会教你如何实现点击菜单栏弹出一个新的窗口。就像我们的应用中，点击 Preferences，会弹出一个偏好设置的窗口。你不用担心这会很难，这比你想象的要简单的多。</p>
]]></content>
      <categories>
        <category>Cocoa Programing</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Cocoa</tag>
      </tags>
  </entry>
  <entry>
    <title>使用一个UIImageView实现轮播控件</title>
    <url>/ck9grdo0b0014eyyedgyh6ez7/</url>
    <content><![CDATA[<p>在做iOS开发中，图片轮播是一个比较频繁的需求了。网上也有很多比较好的实现，有使用2个、3个<code>UIImageView</code>的，也有使用<code>UICollectionView</code>的。这里我要讲的是如何用一个<code>UIImageView</code>实现一个图片轮播控件，当然加载网络图片是必须的。闲话少说，直接进入正题：</p>
<a id="more"></a>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-f3b399cb6f10893e.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h2 id="构建UI"><a href="#构建UI" class="headerlink" title="构建UI"></a>构建UI</h2><p>在轮播控件中只需要一个<code>UIImageView</code>和一个<code>UIPageControl</code>即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> imageView: <span class="type">UIImageView</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> imageV = <span class="type">UIImageView</span>()</span><br><span class="line">    imageV.userInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    imageV.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> imageV</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> pageControl: <span class="type">UIPageControl</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> pageC = <span class="type">UIPageControl</span>()</span><br><span class="line">    pageC.currentPage = <span class="number">0</span></span><br><span class="line">    pageC.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> pageC</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>添加好约束即可。然后需要给图片添加一个左划和右划手势，以及一个点击的手势</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addGesture</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">left</span> = <span class="type">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.swipGesterHandelr(<span class="number">_</span>:)))</span><br><span class="line">    <span class="keyword">left</span>.direction = .<span class="type">Left</span></span><br><span class="line">    <span class="keyword">self</span>.imageView.addGestureRecognizer(<span class="keyword">left</span>)        </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">right</span> = <span class="type">UISwipeGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.swipGesterHandelr(<span class="number">_</span>:)))</span><br><span class="line">    <span class="keyword">right</span>.direction = .<span class="type">Right</span></span><br><span class="line">    <span class="keyword">self</span>.imageView.addGestureRecognizer(<span class="keyword">right</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> tap = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(<span class="keyword">self</span>.tapGesterHandelr(<span class="number">_</span>:)))</span><br><span class="line">    <span class="keyword">self</span>.imageView.addGestureRecognizer(tap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建并启动定时器"><a href="#创建并启动定时器" class="headerlink" title="创建并启动定时器"></a>创建并启动定时器</h2><p>既然是轮播，那么就必须得有一个定时器吧，当你使用定时器的时候，就一定要注意定时器的销毁。当进入界面时就要启动定时器，当离开界面时就要销毁定时器。我以前使用过别人写的轮播控件，当我已经离开界面进入下一个界面时，定时器竟然还在运行，这样是不对的。其实实现起来很简单：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">willMoveToWindow</span><span class="params">(newWindow: UIWindow?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.willMoveToWindow(newWindow)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = newWindow <span class="keyword">else</span> &#123;</span><br><span class="line">        stopTimer()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    refreshTimer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">stopTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">   timer?.invalidate()</span><br><span class="line">   timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">refreshTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> timer == <span class="literal">nil</span> &amp;&amp; autoScrollEnable &#123;</span><br><span class="line">        timer = <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(timeInterval, target: <span class="keyword">self</span>, selector: #selector(<span class="keyword">self</span>.timeAction), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动轮播的实现"><a href="#自动轮播的实现" class="headerlink" title="自动轮播的实现"></a>自动轮播的实现</h2><p>其实这里才是重点的好吧，一个<code>UIImageView</code>要实现轮播效果是很简单的，只需要使用系统的<code>CATransition</code>就可以了，来，上代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">timeAction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    scrollWithDirection(.<span class="type">Left</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollWithDirection</span><span class="params">(direction: ScrollDirection)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> direction &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Left</span>:</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index &gt; imageCounts - <span class="number">1</span> &#123;</span><br><span class="line">            index = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Right</span>:</span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">            index = imageCounts - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> images.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.image = images[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: imageURLStringGroup[index]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.hu_setImageWithURL(url, placeholderImage: placeholderImage)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addScrollAnimationWithDirection(direction)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addScrollAnimationWithDirection</span><span class="params">(direction: ScrollDirection)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> animation = <span class="type">CATransition</span>()</span><br><span class="line">    animation.duration = <span class="number">0.4</span></span><br><span class="line">    animation.type = kCATransitionPush</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> direction &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Left</span>:</span><br><span class="line">        animation.subtype = kCATransitionFromRight</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Right</span>:</span><br><span class="line">        animation.subtype = kCATransitionFromLeft</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.imageView.layer.addAnimation(animation, forKey:<span class="string">"scroll"</span>)</span><br><span class="line">    <span class="keyword">self</span>.pageControl.currentPage = index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常简单，所以就不一一解释了。现在我们已经构建好了UI，创建并启动了定时器（而且能成功销毁），并成功添加了手势，这样这个图片轮播控件就可以正常工作了。但是在我们成功给轮播图设置图片后，我们得做些其他的工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> images: [<span class="type">UIImage</span>] = [] &#123;</span><br><span class="line">    <span class="keyword">willSet</span> &#123;</span><br><span class="line">        imageCounts = newValue.<span class="built_in">count</span></span><br><span class="line">        imageView.image = newValue.first</span><br><span class="line">        pageControl.numberOfPages = newValue.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> imageURLStringGroup: [<span class="type">String</span>] = [] &#123;</span><br><span class="line">    <span class="keyword">willSet</span> &#123;</span><br><span class="line">        imageCounts = newValue.<span class="built_in">count</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: newValue.first!) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        imageView .hu_setImageWithURL(url, placeholderImage: placeholderImage)</span><br><span class="line">        pageControl.numberOfPages = newValue.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在就可以使用了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> images = [<span class="string">"a.jpg"</span>, <span class="string">"b.jpg"</span>,<span class="string">"c.jpg"</span>,<span class="string">"d.jpg"</span>,].flatMap &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIImage</span>(named: $<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> cycleView = <span class="type">HUScrollCycleView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">64</span>, <span class="keyword">self</span>.view.frame.size.width, <span class="number">200</span>))</span><br><span class="line">    <span class="keyword">self</span>.view.addSubview(cycleView)</span><br><span class="line">    cycleView.delegate = <span class="keyword">self</span></span><br><span class="line">    cycleView.images = images</span><br><span class="line">    cycleView.currentPageIndicatorTintColor = <span class="type">UIColor</span>.redColor()</span><br><span class="line"><span class="comment">//  cycleView.placeholderImage = UIImage(named:"a.jpg")</span></span><br><span class="line"><span class="comment">//  cycleView.imageURLStringGroup = ["http://1.7feel.cc/yungou/statics/uploads/banner/20160715/85964915563838.jpg",</span></span><br><span class="line"><span class="comment">//                                         "http://1.7feel.cc/yungou/statics/uploads/banner/20160715/20274054563730.jpg",</span></span><br><span class="line"><span class="comment">//                                         "http://1.7feel.cc/yungou/statics/uploads/banner/20160715/40912708563719.jpg",</span></span><br><span class="line"><span class="comment">//                                         "http://1.7feel.cc/yungou/statics/uploads/touimg/20160718/img193.jpg"];</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后附上<a href="https://github.com/hujewelz/HUScrollCycle" target="_blank" rel="noopener">GitHub</a>地址。<a href="https://github.com/hujewelz/HUScrollCycle" target="_blank" rel="noopener"><strong>HUScrollCycle</strong></a>中的网络图片下载并没有使用其他第三方库，这里我使用的是以前用<code>Objective-C</code>写的<code>HUWebImageDownloader</code>，它在我维护的一个图片浏览器第三方库<a href="https://github.com/hujewelz/HUPhotoBrowser" target="_blank" rel="noopener">HUPhotoBrowser</a>中使用的，它支持网络图片和本地相册图片的浏览和多选，有兴趣的童鞋可以<a href="https://github.com/hujewelz/HUPhotoBrowser" target="_blank" rel="noopener">点这里</a>。<br>所以你完全可以放心使用<strong>HUScrollCycle</strong>而不用担心对你项目产生影响。你只要按照上面的链接中的方法正确的导入<code>HUScrollCycle-Bridging-Header.h</code>就可以正常使用了。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>入坑Webpack</title>
    <url>/ck9grdo0c0017eyye2kup2sd8/</url>
    <content><![CDATA[<p>在开始学习<code>Webpack</code>之前，请先确保安装了<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">Node.js</a>,建议安装最新版的Node.js。然后就可以使用npm安装Webpack了。你可以将Webpack安装到全局，不过我们通常会把它安装到项目依赖中。</p>
<a id="more"></a>

<p>现在进入项目目录，并使用<code>npm init -y</code>初始化一个默认的package.json。打开终端，键入命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install webpack --g</span><br><span class="line">//安装到项目依赖中</span><br><span class="line">npm install webpack --save-dev</span><br></pre></td></tr></table></figure>
<p>安装好Webpack依赖后，新建一个webpack.config.js文件，用来配置webpack。不过在配置webpack之前，先安装<code>webpack-dev-server</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//全局安装</span><br><span class="line">npm install webpack-dev-server --g</span><br><span class="line">//安装到项目依赖中</span><br><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure>
<h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><p>它将在localhost:8080启动一个express静态资源web服务器，并且会以监听模式自动运行webpack，在浏览器打开<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>或<a href="http://localhost:8080/webpack-dev-server/" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server/</a>可以浏览项目中的页面和编译后的资源输出，并且通过一个socket.io服务实时监听它们的变化并自动刷新页面。<br>在终端中执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack-dev-server --inline --hot</span><br></pre></td></tr></table></figure>
<p>当我们修改了模块的内容后，<code>webpack-dev-server</code>会自动执行打包(打包后的结果会缓存到内存中，所以不能在本地文件中看到打包后的文件)。</p>
<p><code>inline</code>选项为整个页面添加了”Live Reloading”功能，而<code>hot</code>选项开启了”Hot Module Reloading”功能，这样就会尝试着重载发生变化的组件，而不是整个页面。这样就实现了修改文件，界面就会自动更新了。<br>我们可以在<code>package.json</code>中输入以下内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">   "dev": "webpack-dev-server --colors --hot --inline",</span><br><span class="line">   "build": "webpack --colors --watch"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这样我们只需要键入<code>npm run dev</code>命令就能执行上面的命令了。</p>
<p>在这之前，先看看项目的结构以及一个简单的<code>webpack config</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|——hello-webpack</span><br><span class="line">   |——src  # 项目源码</span><br><span class="line">      |——assets # 资源文件</span><br><span class="line">         |——img # 图片</span><br><span class="line">         |——css # 样式</span><br><span class="line">      |——component  # 页面组件</span><br><span class="line">      main.js  # 入口文件</span><br><span class="line">   |——static # 静态资源文件</span><br><span class="line">   index.html</span><br><span class="line">   package.json</span><br><span class="line">   webpack.config.js</span><br></pre></td></tr></table></figure>
<p><strong>webpack config.js</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">    publicPath: <span class="string">''</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'src'</span>: path.resolve(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">      <span class="string">'assets'</span>: path.resolve(__dirname, <span class="string">'./src/assets'</span>),</span><br><span class="line">      <span class="string">'components'</span>: path.resolve(__dirname, <span class="string">'./src/components'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js|jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        loader: <span class="string">'style!css'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: path.join(<span class="string">'static'</span>, <span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: <span class="string">'index.html'</span>,</span><br><span class="line">      template: <span class="string">'index.html'</span>,</span><br><span class="line">      inject: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Webpack配置"><a href="#Webpack配置" class="headerlink" title="Webpack配置"></a>Webpack配置</h2><p><strong>webpack.config.js</strong>为Webpack的默认配置，我们可以为开发环境和生产环境分别做不同的配置。下面一一介绍每个配置的作用。</p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p><code>entry</code>是入口配置项，可以是<code>string</code>,<code>Array</code>或者一个<code>Object</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  app: <span class="string">'./src/main.js'</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: <span class="string">'./src/main.js'</span></span><br></pre></td></tr></table></figure>
<p>如果页面有多个入口可以这样写:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: [<span class="string">'./src/home.js'</span>, <span class="string">'.src/profile.js'</span>]</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line">entry: &#123;</span><br><span class="line">  home: <span class="string">'./src/home.js'</span>,</span><br><span class="line">  profile: <span class="string">'./src/profile.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p><code>output</code>是输出配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  publicPath: <span class="string">'/'</span>,</span><br><span class="line">  filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  chunkFilename: <span class="string">'[id].[hash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>path</em>是文件输出到本地的路径，<em>publicPath</em>是文件的引用路径，可用来被一些Webpack插件用来处理CSS，HTML文件中的URL，一般用于生产模式，<em>filename</em>是打包后的入口文件名，<em>chunkFilename</em>是每个模块编译后的文件名，其中[hash]是用来唯一标识文件，主要用来防止缓存。</p>
<h5 id="path"><a href="#path" class="headerlink" title="path"></a>path</h5><p>仅仅用来告诉Webpack在哪里存放结果文件,上面例子中，最终的打包文件会放到与当前脚本文件同级目录的dist目录下。即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello-webpack</span><br><span class="line">  +dist</span><br><span class="line">  -webpack.config.js</span><br></pre></td></tr></table></figure>
<h5 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h5><p>入口文件打包后的名称,<code>[name]</code>对应着入口文件的key值，例如：<code>app.js</code>,这对多入口文件是很有用的，应为入口文件可以有多个，但是filename只能有一个，所以对于上面的多入口，最后就是:<code>home.js</code>,’profile.js’，当然为了体现文件层级关系可以这么写:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename: &#39;js&#x2F;[name].js&#39;</span><br></pre></td></tr></table></figure>
<p>最后的结果就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|——hello-webpack</span><br><span class="line">   |——dist</span><br><span class="line">   |——js</span><br><span class="line">       home.js</span><br><span class="line">       profile.js</span><br><span class="line">    webpack.config.js</span><br></pre></td></tr></table></figure>
<h5 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h5><p>即非入口文件打包后的名称，未被列在entry中，却又需要被打包出来的文件命名配置。一般情况下是不需要这个配置的。比如我们在做异步加载模块时就需要用到了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 require 语法告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">  <span class="comment">// 这些块将通过 Ajax 请求自动下载。</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h5 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h5><p>文件的引用路径，可用来被一些Webpack插件用来处理CSS，HTML文件中的URL，在开发模式下建议使用相对路径，在生产模式中，如果你的资源文件放在别的服务器上，可以使用服务器的地址。当然你也可以不用配置<code>publicPath</code>，。<br>在项目中我使用了<code>url-loader</code>加载图片，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">    loader: <span class="string">'url'</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">      limit: <span class="number">10000</span>,</span><br><span class="line">      name: path.join('static', 'img/[name].[hash:7].[ext]') # 图片最终的输出路径</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>main.js</code>中使用了图片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Girl from &#39;assets&#x2F;img&#x2F;girl.jpg&#39;</span><br></pre></td></tr></table></figure>
<p>那么最终浏览器访问的图片路径就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static&#x2F;img&#x2F;girl.7672e53.jpg</span><br></pre></td></tr></table></figure>
<p>所以可以根据开发环境和生产环境配置不同的<code>publicPath</code>。<br>在生产环境中，由于我的资源文件放在项目目录下，所以可以这样配置<code>output</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">'./dist'</span>),</span><br><span class="line">  publicPath: <span class="string">'./'</span>,</span><br><span class="line">  filename: <span class="string">'js/[name].[chunkhash].js'</span>,</span><br><span class="line">  chunkFilename: <span class="string">`js/[id].[chunkhash].js`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么最终打包后的输出目录结构就是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|——dist</span><br><span class="line">   |——static</span><br><span class="line">      |——img</span><br><span class="line">         girl.7672e53.jpg</span><br><span class="line">      |——js</span><br><span class="line">         app.js</span><br><span class="line">    index.html</span><br></pre></td></tr></table></figure>
<p>所以通过<code>static/img/girl.7672e53.jpg</code>可以访问到图片。在开发环境下，经过测试，将<code>publicPath</code>设置为’./‘界面是无法加载出来的，所以在开发环境下可以不用设置。</p>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js|jsx?$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        loader: <span class="string">'style!css'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif|svg)(\?.*)?$/</span>,</span><br><span class="line">        loader: <span class="string">'url'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: path.join(<span class="string">'static'</span>, <span class="string">'img/[name].[hash:7].[ext]'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由于Webpack本身只能处理JavaScript 模块，如果要处理其他类型的文件，就需要使用loader 进行转换。Loader可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。不同的loader可以将各种类型的文件转换为浏览器能够接受的格式如JS，Stylesheets等等。</p>
<p>下面一一对这些子参数进行说明：</p>
<ul>
<li><code>test</code>参数用来指示当前配置项针对哪些资源，当参数匹配时，就会使用相应的loader。</li>
<li><code>exclude</code>参数用来剔除掉需要忽略的资源。</li>
<li><code>include</code>参数用来表示本loader配置仅针对哪些目录/文件，从名称上就可以认为跟<code>exclude</code>作用相反。</li>
<li><code>loader/loaders</code>参数，用来指示用哪个/哪些loader来处理目标资源，这俩表达的其实是一个意思，只是写法不一样，我个人喜欢将loader写成一行，多个loader间使用!分割，这种形式类似于管道的概念，例如<code>loader: &#39;css?!postcss!less&#39;</code>，可以很明显地看出，目标资源先经less-loader处理过后将结果交给postcss-loader作进一步处理，然后最后再交给css-loader。</li>
</ul>
<p>loader本身也是可以配置的，传入不同的参数可以实现不同的功能。以<a href="https://github.com/webpack/url-loader" target="_blank" rel="noopener">url-loader</a>为例，我们配置url-loader使小于10000字节的图片使用DataURL，大于10000字节的图片使用URL，<code>name</code>属性配置输出图片的图片名称，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'a.png'</span>) =&gt; <span class="keyword">static</span>/a<span class="number">.3445645</span>.png</span><br></pre></td></tr></table></figure>
<p>不同的loader配置参数不一样，具体配置参数可以去官网查看。</p>
<h4 id="loader链"><a href="#loader链" class="headerlink" title="loader链"></a>loader链</h4><p>多个loader可以链式调用，作用于同一种文件类型。工作链的调用顺序是<em>从右向左</em>，各个loader之间使用”!”分开。<br>以处理css文件为例，我们需要<a href="https://github.com/webpack/css-loader" target="_blank" rel="noopener">css-loader</a>来处理css文件，然后使用<a href="https://github.com/webpack/style-loader" target="_blank" rel="noopener">style-loader</a>将css样式插入到html的<code>style</code>标签中。</p>
<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>插件可以完成更多loader不能完成的功能。<br>插件的使用一般是在webpack的配置信息plugins选项中指定。<br>loader是在打包前或打包的过程中作用于单个文件。plugin通常在打包过程结束后，作用于包或者chunk级别。</p>
<p>以下是一些常用的插件:</p>
<ol>
<li><p><a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a></p>
<p>ExtractTextPlugin的作用是把各个chunk加载的css代码合并成一个css文件并在页面加载的时候以<code>&lt;link&gt;</code>的形式进行加载。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>, </span><br><span class="line">      loader:ExtractTextPlugin.extract(<span class="string">"style-loader"</span>,<span class="string">"css-loader"</span>) &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> ExtractTextPlugin(path.join(<span class="string">'static'</span>, <span class="string">'css/[name].[contenthash].css'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果想要把CSS放到HTML的style标签中，可以不使用extract-text-webpack-plugin，只要用css-loader和style-loader就可以了。</p>
</blockquote>
</li>
<li><p><a href="https://github.com/ampedandwired/html-webpack-plugin" target="_blank" rel="noopener">html-webpack-plugin</a></p>
<p>html-webpack-plugin，是用来生产html的，其中filename是生产的文件路径和名称，template是使用的模板，inject是指将js放在body还是head里。为<code>true</code>会将js放到body里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  filename: <span class="string">'index.html'</span>,</span><br><span class="line">  template: <span class="string">'index.html'</span>,</span><br><span class="line">  inject: <span class="literal">true</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure>
<p>这个插件是建议一定要安装的。</p>
</li>
<li><p>uglifyJSPlugin</p>
<p> uglifyJSPlugin是将代码进行压缩的。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">  compress: &#123;</span><br><span class="line">    warnings: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4. CommonsChunkPlugin</span><br><span class="line"></span><br><span class="line">  CommonsChunkPlugin是将多个入口文件之间共享的块打包成一个独立的js文件。至此，你只需要在每个页面都加载这个公共代码的js文件，就可以既保持代码的完整性，又不会重复下载公共代码了。</span><br><span class="line">  &#96;&#96;&#96;js</span><br><span class="line">  new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">      name: &#39;vendor&#39;,</span><br><span class="line">      filename: &#39;[name].[chunkhash].js&#39;,</span><br><span class="line">      minChunks: 4</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>，给这个包含公共代码的chunk命个名（唯一标识）。</li>
<li><code>filename</code>，如何命名打包后生产的js文件。</li>
<li><code>minChunks</code>，公共代码的判断标准：某个js模块被多少个chunk加载了才算是公共代码。</li>
<li><code>chunks</code>，表示需要在哪些chunk（也可以理解为webpack配置中entry的每一项）里寻找公共代码进行打包。不设置此参数则默认提取范围为所有的chunk。</li>
</ul>
</li>
</ol>
<h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'.json'</span>],</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">'src'</span>: path.resolve(__dirname, <span class="string">'./src'</span>),</span><br><span class="line">    <span class="string">'assets'</span>: path.resolve(__dirname, <span class="string">'./src/assets'</span>),</span><br><span class="line">    <span class="string">'components'</span>: path.resolve(__dirname, <span class="string">'./src/components'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>resolve.extensions</code>是对模块后缀名的简写，配置后，原本是<code>require(&#39;./components/app.jsx&#39;)</code> 可以简写为<code>require(&#39;./components/app&#39;)</code>。</p>
<p><code>resolve.alias</code>是别名，配置后，比如原本是<code>require(&#39;./src/components/nav.jsx&#39;)</code>可以简写为<code>require(&#39;components/nav.jsx&#39;)</code>。</p>
<h2 id="Webpack中的hash与chunkhash"><a href="#Webpack中的hash与chunkhash" class="headerlink" title="Webpack中的hash与chunkhash"></a>Webpack中的hash与chunkhash</h2><h3 id="hash与chunkhash"><a href="#hash与chunkhash" class="headerlink" title="hash与chunkhash"></a>hash与chunkhash</h3><p>按照官方的定义<code>hash</code>就是webpack的每一次编译(compilation)所产生的hash值，<code>chunkhash</code>从字面上理解就是每一个<code>chunk</code>的hash值。那么什么时候会产生编译以及<code>chunk</code>又是什么东西？</p>
<h4 id="compilation"><a href="#compilation" class="headerlink" title="compilation"></a>compilation</h4><p><code>compilation</code>对象代表某个版本的资源对应的编译进程。当使用Webpack的development中间件时，每次检测到项目文件有改动就会创建一个compilation，进而能够针对改动生产全新的编译文件。以及在每次执行<code>webpack</code>命令时都会创建一个compilation。也就是说当创建了一个compilation，我们所有需要打包的文件(js,css,img,font等)都会产生相同的hash。</p>
<p>如果在项目中我们使用hash作为编译输出文件的hash的话，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">    home: <span class="string">'./src/home.js'</span>,</span><br><span class="line">    profile: <span class="string">'./src/profile.js'</span></span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">    path: <span class="string">'./dist'</span>,</span><br><span class="line">    filename: <span class="string">'js/[name].[hash].js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在编译后所有的文件名都会使用相同的hash值，这样带来的问题是，上面两个js文件任何一个改动都会影响另外文件的最终文件名。上线后，另外文件的浏览器缓存也全部失效。这肯定不是我们想要的结果。</p>
<p>那么如何避免这样的问题呢？</p>
<p>答案就是使用<code>chunkhash</code>。<br>按照上面所说，<code>chunkhash</code>是每一个<code>chunk</code>的hash值，<code>chunk</code>就是模块(webpack中一切皆模块)，<code>chunkhash</code>也就是根据模块内容计算出的hash值。所以某个文件的改动只会影响它本身的hash值，不会影响其他文件。<br>所以可以将上面的filename改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filename: <span class="string">'js/[name].[chunkhash].js'</span></span><br></pre></td></tr></table></figure>
<p>这样的话每个文件的hash值都不相同，上线后无改动的文件不会失去缓存。</p>
<p>不过使用<code>chunkhash</code>也不能解决所有问题，比如打包<code>css</code>文件。</p>
<h3 id="js与css共用相同chunkhash的解决方案"><a href="#js与css共用相同chunkhash的解决方案" class="headerlink" title="js与css共用相同chunkhash的解决方案"></a>js与css共用相同chunkhash的解决方案</h3><p>前文提到了webpack的编译理念，webpack将style视为js的一部分，所以在计算<code>chunkhash</code>时，会把所有的js代码和style代码混合在一起计算。所以，不论是修改了js代码还是css代码，整个chunk的内容都改变了，计算所得的chunkhash自然就一样了。</p>
<p>那么如何解决这种问题呢？</p>
<h4 id="contenthash"><a href="#contenthash" class="headerlink" title="contenthash"></a>contenthash</h4><p>webpack默认将js/style文件统统编译到一个js文件中，可以借助<a href="https://github.com/webpack/extract-text-webpack-plugin" target="_blank" rel="noopener">extract-text-webpack-plugin</a>将style文件单独编译输出。所以我们可以这样配置:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ExtractTextPlugin(<span class="string">'./dist/css/[name].[contenthash].css'</span>)</span><br></pre></td></tr></table></figure>
<p><code>contenthash</code>代表的是文本文件内容的hash值，也就是只有style文件的hash值。这样编译输出的js和css文件将会有其独立的hash值。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>在看文章的同时，搭配<a href="https://github.com/hujewelz/hello-webpack" target="_blank" rel="noopener">示例项目</a>会更直观哦，赶紧动起手来，开始入坑Webpack吧:)。</p>
<p>克隆后，请执行 <code>npm install</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//启动运行环境</span><br><span class="line">npm run dev </span><br><span class="line">//执行打包</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Web Dev</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Core Data</title>
    <url>/ck9grdo0i001ceyyefi06begh/</url>
    <content><![CDATA[<p>Core Data 是一个强大的对象图形化管理和对象持久化的框架，这一框架在 iOS 和 OS X 系统中已经存在很多年了。<a id="more"></a> 2005年的四月份，Apple 发布了 OS X 10.4，正是在这个版本中 Core Data 框架发布了。Core Data 可以很方便地将 <code>OC</code> 对象存储到数据库中，也可以将数据库中的数据转化为 <code>OC</code> 对象，在这个过程中不需要我们手动编写任何 <code>SQL</code> 语句，Core Data 会帮我们完成。对于不喜欢 <code>SQL</code> 语句的同学来说，使用 Core Data 倒是个不错的选择。即使你不愿使用 <code>Core Data</code> ，作为一个合格的 iOS 开发者， 你也应该熟悉 Core Data。</p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><p>在 Core Data 中有几个比较重要的类：</p>
<ul>
<li><strong>NSManagedObjectContext</strong><br>  托管对象上下文，我们进行数据操作时，大多都是和它打交道。我们每一个托管对象都存在于一个 context 内。Core Data 支持多个 contexts，不过对于更高级的使用情况才用。</li>
<li><strong>NSManagedObjectModel</strong><br>  托管对象模型，我们一般通过 <code>.xcdatamodeid</code>文件来加载一个托管对象模型，也可以通过代码创建。你可以把它理解为一个数据库。</li>
<li><strong>NSPersistentStoreCoordinator</strong><br>  持久化存储协调器（persistent store coordinator），它将对象图管理部分和持久化部分捆绑在一起，当它们两者中的任何一部分需要和另一部分交流时，这便需要持久化存储协调器来调节了。</li>
<li><strong>NSPersistentStore</strong><br>  持久化存储（persistent store），每个持久化存储协调器都有一个属于自己的持久化存储。它在文件系统中与 SQLite 数据库交互。为了支持更高级的设置，Core Data 可以将多个 stores 附属于同一个持久化存储协调器，并且除了存储 SQL 格式外，还有很多存储类型可供选择。</li>
<li><strong>NSManagedObject</strong><br>  托管对象类（Entity），所有 Core Data 中的托管对象都必须继承该类，根据实体创建托管对象类文件。</li>
</ul>
<p>下图很清晰地表现了它们之间的关系：</p>
<p><img src="https://objccn.io/images/issues/issue-4/stack-complex.png" alt=""></p>
<p>当所有的组件都捆绑到一起的时候，我们把它称作 Core Data 堆栈，这个堆栈有两个主要部分。一部分是关于对象图管理，这正是我们需要很好掌握的那一部分，并且知道怎么使用。第二部分是关于持久化，也就是数据如何存储到磁盘中。持久化存储协调器（persistent store coordinator）刚好位于堆栈中间。这样很好的将两部分实现了分离，我们就不用关心存储的实现细节。</p>
<h2 id="创建-Core-Data-堆栈"><a href="#创建-Core-Data-堆栈" class="headerlink" title="创建 Core Data 堆栈"></a>创建 Core Data 堆栈</h2><p>创建一个 Core Data 堆栈最方便快捷的方式是在我们创建项目时选择 <code>Use Core Data</code> 复选框，这样创建出来的工程系统会默认生成一些CoreData的代码以及一个.xcdatamodeld后缀的模型文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coredata/18436043320170227154154030_640.png" alt=""></p>
<p>不过我建议不要这么做，因为 Xcode 会把自动生成的部分代码放在AppDelegate中，我们应该把这部分代码单独抽离出去，放在专门的类或模块来管理 Core Data 相关的逻辑。</p>
<h3 id="构建模型文件"><a href="#构建模型文件" class="headerlink" title="构建模型文件"></a>构建模型文件</h3><p>使用 Core Data 的第一步是创建后缀为 <code>.xcdatamodeld</code>的模型文件，使用快捷键 Command + N，选择 Core Data -&gt; Data Model -&gt; Next，完成模型文件的创建。创建完成后，点击底部 <code>Add Entity</code> 按钮，来添加一个实体，命名为 <code>User</code>。</p>
<p>添加 <code>User</code> 实体后，会发现一个实体对应着三部分内容：Attributes、Relationships、Fetched Properties，分别对应着属性、关联关系、获取操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coredata/18436043320170227155859067_640.jpg" alt=""></p>
<p>点击 Attributes 下面的加号按钮可以给实体添加属性。<br><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coredata/18436043320170227160223054_640.jpg" alt=""></p>
<h3 id="设置堆栈"><a href="#设置堆栈" class="headerlink" title="设置堆栈"></a>设置堆栈</h3><p>我们使用 <code>initWithConcurrencyType:</code> 为主队列创建一个 managed object context，在有些代码中，你可能见到 <code>[[NSManagedObjectContext alloc] init]</code>。不过最好使用 <code>initWithConcurrencyType:</code>初始化，以明确你是使用基于队列的并发模型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSManagedObjectContext</span> *)managedObjectContext &#123;</span><br><span class="line">  <span class="keyword">if</span> (_managedObjectContext == <span class="literal">nil</span>) &#123;</span><br><span class="line">    _managedObjectContext = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSMainQueueConcurrencyType</span>];</span><br><span class="line">    _managedObjectContext.persistentStoreCoordinator = <span class="keyword">self</span>.persistentStoreCoordinator;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _managedObjectContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建 managed object context 时我们给它设置了一个持久化存储协调器</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSPersistentStoreCoordinator</span> *)persistentStoreCoordinator &#123;</span><br><span class="line">  <span class="keyword">if</span> (_persistentStoreCoordinator == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *path = [[<span class="keyword">self</span> applicationDocumentsDirectory] URLByAppendingPathComponent:<span class="string">@"test.sqlite"</span>];</span><br><span class="line">    _persistentStoreCoordinator = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:<span class="keyword">self</span>.objectModel];</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (![_persistentStoreCoordinator addPersistentStoreWithType:<span class="built_in">NSSQLiteStoreType</span> configuration:<span class="literal">nil</span> URL:path options:<span class="literal">nil</span> error:&amp;error]) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"error: %@"</span>, error.localizedDescription);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _persistentStoreCoordinator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSManagedObjectModel</span> *)objectModel &#123;</span><br><span class="line">  <span class="keyword">if</span> (_objectModel == <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *momdURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@"coredata"</span> withExtension:<span class="string">@"momd"</span>];</span><br><span class="line">    _objectModel = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:momdURL];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _objectModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过一个托管对象模型创建了一个持久化存储协调器，并使用 <code>addPersistentStoreWithType: configuration: URL: options: error:</code> 关联了数据库的部分，关联本地数据库后会返回一个 <code>NSPersistentStore</code> 对象，这个对象负责具体持久化存储的实现。可以多次调用该方法添加多个持久化存储对象。</p>
<p>一个持久化存储协调器有四种可选的持久化存储方案，用得最多的是 SQLite 的方式。其中Binary和XML这两种方式，在进行数据操作时，需要将整个文件加载到内存中，这样对内存的消耗是很大的。</p>
<ul>
<li><strong>NSSQLiteStoreType：</strong>SQLite数据库</li>
<li><strong>NSXMLStoreType：</strong>XML文件</li>
<li><strong>NSBinaryStoreType：</strong>二进制文件</li>
<li><strong>NSInMemoryStoreType：</strong>直接存储在内存中</li>
</ul>
<p>我在一个单独的类中，完成了以上所有操作，并添加了一个 <code>saveContext</code> 方法，方便在其他类中调用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DBHelper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSManagedObjectContext</span> *managedObjectContext;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSManagedObjectModel</span> *objectModel;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSPersistentStoreCoordinator</span> *persistentStoreCoordinator;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)saveContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="创建托管对象"><a href="#创建托管对象" class="headerlink" title="创建托管对象"></a>创建托管对象</h3><p>创建实体后，就可以根据对应的实体，生成开发中使用的基于 NSManagedObject 类的托管对象类文件。使用快捷键 Command + N，选择 Core Data -&gt; NSManagerObject subclass -&gt; Next，选择模型文件 -&gt; 选择实体，完成模型文件的创建。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/coredata/18436043320170227162725013_640.png" alt=""></p>
<h2 id="操作数据"><a href="#操作数据" class="headerlink" title="操作数据"></a>操作数据</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>在模型类中可以加入一个类方法来将新的对象插入到 managed object 上下文中，并使用 <code>saveContext</code> 将数据保存到SQLite数据库中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User *user &#x3D; [NSEntityDescription insertNewObjectForEntityForName:@&quot;User&quot; inManagedObjectContext:[DBHelper sharedInstance].managedObjectContext];</span><br><span class="line">user.name &#x3D; @&quot;张三&quot;;</span><br><span class="line">user.age &#x3D; @22;</span><br><span class="line">[[DBHelper sharedInstance] saveContext];</span><br></pre></td></tr></table></figure>

<p>Core Data 创建新对象的 API 并不是非常的直观，我们可以以一种更加优雅的方式来实现同样的功能：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)entityName&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)insertNewObjectForEntity &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:[<span class="keyword">self</span> entityName]</span><br><span class="line">                                       inManagedObjectContext:[DBHelper sharedInstance].managedObjectContext];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)save &#123;</span><br><span class="line">  [[DBHelper sharedInstance] saveContext];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在保存一个对象就简单多了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">User *user = [User insertNewObjectForEntity];</span><br><span class="line">user.name = <span class="string">@"李四"</span>;</span><br><span class="line">user.age = @<span class="number">22</span>;</span><br><span class="line">[user save];</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>我们只需要创建一个 <code>NSFetchRequest</code>对象，然后调用 managed object context 的 <code>executeFetchRequest:</code> 方法返回查询结果集合。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"User"</span>];</span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *result = [[DBHelper sharedInstance].managedObjectContext executeFetchRequest:request error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error: %@"</span>, error.localizedDescription);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">[result enumerateObjectsUsingBlock:^(User   * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"name: %@, age: %zd"</span>, obj.name, obj.age.integerValue);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>我们通过给 <code>request</code> 设置一些条件，查询我们想要的数据：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name = %@"</span>, <span class="string">@"张三"</span>];</span><br><span class="line">request.predicate = predicate;</span><br></pre></td></tr></table></figure>

<h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>修改数据很简单，我们只要根据条件查询出数据后，修改对象的属性后，保存数据即可：</p>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"User"</span>];</span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name=%@"</span>, <span class="string">@"张三"</span>];</span><br><span class="line">request.predicate = predicate;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *result = [[DBHelper sharedInstance].managedObjectContext executeFetchRequest:request error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error: %@"</span>, error.localizedDescription);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">[result enumerateObjectsUsingBlock:^(User   * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    obj.age = @<span class="number">33</span>;</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[[DBHelper sharedInstance] saveContext];</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>删除数据跟修改数据几乎一模一样，唯一的区别就是查询出数据后，调用 managed object context 的 <code>deleteObject:</code> 方法来删除数据：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSFetchRequest</span> *request = [<span class="built_in">NSFetchRequest</span> fetchRequestWithEntityName:<span class="string">@"User"</span>];</span><br><span class="line"><span class="built_in">NSPredicate</span> *predicate = [<span class="built_in">NSPredicate</span> predicateWithFormat:<span class="string">@"name=%@"</span>, <span class="string">@"张三"</span>];</span><br><span class="line">request.predicate = predicate;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *result = [[DBHelper sharedInstance].managedObjectContext executeFetchRequest:request error:&amp;error];</span><br><span class="line"> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"error: %@"</span>, error.localizedDescription);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[result enumerateObjectsUsingBlock:^(User   * _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    [[DBHelper sharedInstance].managedObjectContext deleteObject:obj];</span><br><span class="line"> &#125;];</span><br><span class="line">  </span><br><span class="line">[[DBHelper sharedInstance] saveContext];</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>很多人，特别是初学者都认为 Core Data 很难，所以尽量去避免在项目中使用它。其实去了解后发现其实并不是很复杂。像上面的增删改查操作，看上去大体流程都差不多，都是一些最基础的简单操作。要想更深入地了解 Core Data 可以去网上看高级教程。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Core Data</tag>
      </tags>
  </entry>
  <entry>
    <title>属性 -- 你真的弄明白了吗?</title>
    <url>/ck9grdo0k001feyye5pqt6a7t/</url>
    <content><![CDATA[<p>“属性”（property）是 Objective-C 2.0 的一项特性，用于封装对象中的数据。Objective-C 对象通常会把其所需要的数据保存为实例变量，并通过 “存取方法”（<code>getter</code>和<code>setter</code>） 来访问。<code>getter</code>用于读取变量值，<code>setter</code>用于给属性设置值。”属性”这一特性的引入，使得这一切可以让编译器自动完成。此特性还引入了一种新的”点语法”，使开发者可以更容易地依照类对象来访问数据。</p>
<a id="more"></a>

<h2 id="自动合成"><a href="#自动合成" class="headerlink" title="自动合成"></a>自动合成</h2><p>在 Objective-C 中，你可以在类的接口定义中使用 <code>@property</code> 语法就能定义一个 “属性”。其意思是说：编译器会自动生成存取方法，并向类中添加相应的实例变量。例如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface HUPerson : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这跟以前不使用 “属性” 写出来的代码是等效的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface HUPerson : NSObject &#123;</span><br><span class="line">  NSString *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)name;</span><br><span class="line">- (void)setName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>访问属性时，我们可以使用 “点语法”，编译器会把 “点语法”转换为相应的存取方法的调用，使用”点语法”的效果与直接调用存取方法相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HUPerson *person &#x3D; [[HUPerson alloc] init];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面的调用是一样的</span><br><span class="line">person.name &#x3D; @&quot;jewelz&quot;;</span><br><span class="line">[person setName:@&quot;jewelz&quot;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;NSString *name &#x3D; person.name;</span><br><span class="line">NSString *name &#x3D; [person name];</span><br></pre></td></tr></table></figure>
<p>使用属性时，编译器自动生成存取方法和实例变量的过程叫做 “自动合成”（autosynthesis）。这个过程在由编译器在编译期执行，所以我们在编译器里看不到这些自动合成的代码。自动合成的示例变量名是在属性名前面加上下划线。不过我们可以使用<code>@synthesize</code>语法来指定示例变量名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation HUPerson</span><br><span class="line">@synthesize name &#x3D; _aName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的代码会将生成的实例变量命名为<code>_aName</code>，而不再使用默认的名称。不过在项目中使用这个方法修改实例变量的名称并不是个好主意。统一的代码风格对于一个大型项目来说是很有必要的，所以还是使用默认的命名吧，除非你坚持要这么做。</p>
<p>若不想让编译器自动合成存取方法，则可以自己实现。如果你只实现了存取方法中的一个，那么另一个会由编译器帮你合成。前提是你定义的属性是可以读写的，而不是 <code>readonly</code>的。我们还有一种方式来阻止编译器自动合成存取方法，那就是使用 <code>@dynamic</code> 关键字，它会告诉编译器：不用自动给我合成存取方法也不用生成实例变量。在编译访问属性的代码时，即使编译器找不到定义的存取方法，也不会报错。例如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface HUPerson : NSObject</span><br><span class="line">@property (nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation HUPerson</span><br><span class="line">@dynamic name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这时编译器不会为 <code>HUPerson</code> 自动合成存取方法或实例变量。你仍然可以正常的访问其中的属性，编译器也不会发出警告信息。如果你没有实现相应的存取方法，那么在运行时程序就会崩溃掉。</p>
<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><p>在定义属性时，我们常常会给属性指定一些特性，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, readwrite, copy) NSString *name;</span><br></pre></td></tr></table></figure>
<p>属性的特性有四中类型：</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>在默认情况下，由编译器合成的方法会通过锁机制确保其原子性。如果属性指定为 <code>nonatomic</code>，则不会使用同步锁。系统默认是 <code>atomic</code>的，不过这在一定程度上会影响系统性能，所以在iOS开发中一般指定为 <code>nonatomic</code>的。</p>
<h4 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h4><ul>
<li><p>具备 <strong>readwrite</strong>（读写） 特性的属性同时拥有 <code>getter</code> 和 <code>setter</code>方法，这是编译器自动帮我们生成的。</p>
</li>
<li><p>具备 <strong>readonly</strong>（只读） 特性的属性只有 <code>getter</code> 方法。这样的话我们就不能在类内部使用点语法来给变量赋值了，所以一般的做法是：在类的接口中对外公开为只读属性，然后在类的 Extension 中将其重新定义为读写属性。</p>
<h4 id="内存管理语义"><a href="#内存管理语义" class="headerlink" title="内存管理语义"></a>内存管理语义</h4><p>编译器在合成存取方法时，要根据次特性来决定使用哪种内存管理策略，在合成设置方法时，编辑器会生成相应的代码。主要有以下几种：</p>
</li>
<li><p><strong>asign</strong> 设置方法只会执行针对纯类型（NSInter、CGFloat等）的简单赋值。</p>
</li>
<li><p><strong>strong</strong> 此特性表明该属性定义了一种 “拥有关系”。为这种属性设置值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。</p>
</li>
<li><p><strong>weak</strong> 此特性表明该属性定义了一种 “非拥有关系”。为这种属性设置值时，设置方法既不保留新值，也不释放旧值，此特性与 asign 类似，不过在属性所指的对象遭到销毁时，属性值会被设置为 <code>nil</code>。</p>
</li>
<li><p><strong>unsafe_unretained</strong> 此特性的语言与 asign 相同，但是它使用于对象类型。它表明了一种 “非拥有关系”，不过与 weak 不同，在属性所指的对象遭到销毁时，属性值不会被设置为 <code>nil</code>。</p>
</li>
<li><p><strong>copy</strong> 此特性表达的所属关系与 strong 类似。为这种属性设置值时，并不保留新值，而是将其 “拷贝”。</p>
<h4 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h4><p>可以通过如下特性来指定存取方法的方法名：</p>
</li>
<li><p><strong>getter=name</strong> 指定 <code>getter</code>的名称。一个好的实践是，当某个属性是 BOOL 类型时，我们将其获取方法加上 “is” 前缀。类似下面这样：</p>
  <figure class="highlight plain"><figcaption><span>(nonatomic, assign, getter</span></figcaption><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li>
<li><p><strong>setter=name</strong> 指定 <code>setter</code>的名称。这种用法不太常见。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>如何发布自己的开源框架到CocoaPods</title>
    <url>/ck9grdo0n001jeyyeaxw286n3/</url>
    <content><![CDATA[<p>在开发过程中，经常会使用到第三框架，我们通过一个<code>pod install</code>命令，很方便的就将第三方框架加到我们自己的项目中。<br>如果我们也想将自己写的组件或库开源出去，让别人也可以通过<code>pod install</code>命令安装自己的框架该怎么做呢？</p>
<a id="more"></a>
<p>下面，我就教大家一步一步的将自己的pods发布到<code>CocoaPods</code> 中。如果你现在对<code>CocoaPods</code>还不太了解，推荐你看一看这篇文章：<a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="noopener">用CocoaPods做iOS程序的依赖管理</a></p>
<h2 id="创建自己项目的Podspec描述文件"><a href="#创建自己项目的Podspec描述文件" class="headerlink" title="创建自己项目的Podspec描述文件"></a>创建自己项目的Podspec描述文件</h2><p>下面我会通过一个名为<code>HUPhotoBrowser</code>的项目来讲解一下整个过程。<br>项目发布到<code>github</code>后，需要打上<code>tag</code>。之后我们在工程根目录中初始化一个Podspec文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec create HUPhotoBrowser</span><br></pre></td></tr></table></figure>
<p>该命令将在本目录产生一个名为<code>HUPhotoBrowser.podspec</code>文件。用编辑器打开该文件，里面已经有非常丰富的说明文档。下面介绍如何声明第三方库的代码目录和资源目录，还有该第三方库所依赖ios核心框架和第三方库。这是我的podspec文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         &#x3D; &quot;HUPhotoBrowser&quot;</span><br><span class="line">  s.version      &#x3D; &quot;0.0.2&quot;</span><br><span class="line">  s.summary      &#x3D; &quot;photo browser for ios.&quot;</span><br><span class="line">  s.homepage     &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;hujewelz&#x2F;HUPhotoBrowser&quot;</span><br><span class="line">  s.license      &#x3D; &quot;MIT&quot;</span><br><span class="line">  s.author             &#x3D; &#123; &quot;Jewelz Hu&quot; &#x3D;&gt; &quot;hujewelz@163.com&quot; &#125;</span><br><span class="line">  s.platform     &#x3D; :ios, &quot;7.0&quot;</span><br><span class="line">  s.source       &#x3D; &#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;hujewelz&#x2F;HUPhotoBrowser.git&quot;, :tag &#x3D;&gt; &quot;0.0.2&quot; &#125;</span><br><span class="line">  s.source_files  &#x3D; &quot;HUPhotoBrowser&quot;, &quot;HUPhotoBrowser&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br><span class="line">   s.framework  &#x3D; &quot;UIKit&quot;</span><br><span class="line">  # s.frameworks &#x3D; &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</span><br></pre></td></tr></table></figure>
<p><code>s.name</code>是我们库的名称，<code>s.version</code>是库原代码版本号，<code>s.summary</code>是对我们库的一个简单的介绍，<code>s.homepage</code>声明库的主页，<code>s.license</code>是所采用的授权版本，<code>s.author</code>是库的作者。<code>s.platform</code>是我们库所支持的软件平台，这在我们最后提交进行编译 时有用。<code>s.source</code>声明原代码的地址。我这里是托管在github上,所以这里将地址copy过来就行了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-5f185444531af1d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午3.02.58.png"><br>对于很多第三方库而言，在发布的时候都会打上一个<code>tag</code>，如版本0.0.1就会打上一个名为<code>0.0.1</code>的<code>tag</code>,你也可以选择一个最新的<code>commit</code>来作为该库0.0.1版的代码, 那么最终source就是这样了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;:git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;hujewelz&#x2F;HUPhotoBrowser.git&quot;, :commit &#x3D;&gt; &#39;65584b0e0b08e01f83e66d487180c164b5182409&#39;&#125;</span><br></pre></td></tr></table></figure>
<p>我这里还是使用的tag，所以我这里就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; :git &#x3D;&gt; &quot;https:&#x2F;&#x2F;github.com&#x2F;hujewelz&#x2F;HUPhotoBrowser.git&quot;, :tag &#x3D;&gt; &quot;0.0.2&quot; &#125;</span><br></pre></td></tr></table></figure>
<p>以后我们的库有新版本时，我们可以修改相应的<code>version</code>和<code>source</code>。<br><code>s.source_files</code>声明了我们库的源代码的位置，所以这个地方不能填错了。<br>先看一下我的目录结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-98aca18e60fac44a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午3.15.07.png"><br>所以工程根目录下的<code>HUPhotoBrowse</code>文件夹才是库的原代码目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.source_files  &#x3D; &quot;HUPhotoBrowser&quot;, &quot;HUPhotoBrowser&#x2F;**&#x2F;*.&#123;h,m&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>目录的层级关系一定要跟代码库的保持一致。这里前一部分可以不用的，因为我这里后一部分的<code>HUPhotoBrowser/**</code>与前面是一致的，这个指定的目录下的文件都会进行编译。如果该目录下还有一些资源文件（如图片等），这些文件并不需要进行编译。可以使用<code>s.resourcs</code>声明。<code>*.{h,m}</code>是一个类似正则表达式的字符串，表示匹配所有以<code>.h</code>和<code>.m</code>为扩展名的文件。<br><code>s.framework</code>声明了所依赖的核心库，我这里只用到了<code>UIKit</code>,所以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.framework  &#x3D; &quot;UIKit&quot;</span><br></pre></td></tr></table></figure>
<p>如果你的项目中依赖多个库，可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.frameworks &#x3D; &quot;SomeFramework&quot;, &quot;AnotherFramework&quot;</span><br></pre></td></tr></table></figure>
<p>当然，我们开发的库中也可能还依赖第三方库，例如<code>JSONKit</code>，那么，就可以做如下声明:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot;</span><br></pre></td></tr></table></figure>
<p>如果有多个需要填写多个<code>s.dependency</code>。<br>编辑完<code>podspec</code>文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，验证需要执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint PodName.podspec</span><br></pre></td></tr></table></figure>
<p>当看到<code>HUPhotoBrowser passed validation.</code>时，说明验证通过了。在检测你的podspec时候，如果直接用pod spec lint xxx.podspec的话，出现错误它只会直接一句红色的话<code>The spec did not pass validation, due to 1 error.</code>告诉你的有多少个error和warning，而不会具体的指出你的错误出在哪里，这时候你可以在这句指令后面加上参数–verbose 这样就会告诉你具体的错误信息。这样根据它提示你的错误信息去解决就可以了。</p>
<p>编辑好<code>podspec</code>文件后就可以将该<code>podspec</code>文件保存到本机的<code>~/.cocoapods/repos/master/Specs</code>目录中仅供自己使用，也可以将其提交到CocoaPods/Specs代码库中。下面我们先将其保存到本机中：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-c8e31c301e9c2c59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午3.44.31.png"><br>下面可以看一下是否可以通过搜索找到该库:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-51c1e65c0c2a5a9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午3.48.06.png"><br>同样在需要依赖于<code>HUPhotoBrowser</code>这个库的项目，可以将下列添加到项目的<code>Podfile</code>文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod &#39;HUPhotoBrowser&#39;, &#39;~0.0.2&#39;</span><br></pre></td></tr></table></figure>
<p>保存文件，并用<code>pod install</code>安装<code>HUPhotoBrowser</code>库。</p>
<p>通过以上步骤创建Pod库还只能供自己使用，下面会继续讲解如何将其提交到CocoaPods/Specs代码库中，让其他人也可以通过<code>pod install</code>安装我们的开源库。</p>
<h2 id="CocoaPods-Trunk发布自己的Pods"><a href="#CocoaPods-Trunk发布自己的Pods" class="headerlink" title="CocoaPods Trunk发布自己的Pods"></a>CocoaPods Trunk发布自己的Pods</h2><p>在cocoapods使用了trunk之后，<code>CocoaPods</code> 需要0.33以上版本，用 <code>pod --version</code>查看版本，如果版本低，需要更新。</p>
<h3 id="注册Trunk"><a href="#注册Trunk" class="headerlink" title="注册Trunk"></a>注册Trunk</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod trunk register orta@cocoapods.org &#39;Orta Therox&#39; --description&#x3D;&#39;macbook air&#39;</span><br></pre></td></tr></table></figure>
<p>大家在注册时需要替换成自己的邮箱和用户名，一切顺利的话就会受到一份邮件，点击邮件中的链接后验证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk me</span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/1351863-641b06a41444a0dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午4.05.42.png"><br>当然，如果你的pod是由多人维护的，你也可以添加其他维护者:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod trunk add-owner ARAnalytics kyle@cocoapods.org</span><br></pre></td></tr></table></figure>
<p>上面的工作完成之后，我们就可以开始 <code>trunk push</code>了。</p>
<h3 id="Trunk-push"><a href="#Trunk-push" class="headerlink" title="Trunk push"></a>Trunk push</h3><p><code>pod trunk push</code> 命令会首先验证你本地的<code>podspec</code>文件(是否有错误)，之后会上传<code>spec</code>文件到<code>trunk</code>，最后会将你上传的<code>podspec</code>文件转换为需要的<code>json</code>文件。在工程根目录(包含有.podspec)下执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push</span><br></pre></td></tr></table></figure>
<p>如果在<code>trunk push</code>过程中报错了，仔细查看一下错误信息。我当初就是使用了<code>podspec</code>文件中描述的版本所没有的API，之后修改<code>podspec</code>文件中<code>s.platform = :ios, &quot;7.0&quot;</code>就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-70f2bc73825180bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午4.12.59.png"><br>如果你能看的上面的结果说明上传成功了。我们也可以在本地的<code>~/.cocoapods/repos/master/Specs</code>目录下看到转换之后的<code>json</code>文件,</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1351863-9f93e6c957de080f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕快照 2016-02-26 下午4.16.56.png"><br>至此我们整个制作自己的开源库的过程就完成了，以后有新版本只需要修改工程根目录下的<code>podspec</code>文件就行了，然后重新执行<code>pod trunk push</code>命令。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后对这个过程做个总结：</p>
<ol>
<li>开源库发布之后，需要打上<code>tag</code></li>
<li>进入到项目根目录下，创建<code>podspec</code>文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec create PodName</span><br></pre></td></tr></table></figure></li>
<li>编辑<code>podspec</code>文件中的相关信息，有两个比较重要的地方<code>s.source</code>和<code>s.source_files</code>,可以验证是否有误：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod spec lint PodName.podspec</span><br></pre></td></tr></table></figure></li>
<li>注册pod trunk<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pod trunk register orta@cocoapods.org &#39;Orta Therox&#39; --description&#x3D;&#39;macbook air&#39;</span><br></pre></td></tr></table></figure></li>
<li>发布到pod trunk<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod trunk push [NAME.podspec]</span><br></pre></td></tr></table></figure>
该命令在包含有<code>.podspec</code>文件的目录下执行</li>
<li>更新pod库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod setup</span><br></pre></td></tr></table></figure>
如果<code>pod trunk push</code>成功后无法<code>pod search</code>到自己的库，可执行该命令。</li>
</ol>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>哈哈。好吧，我承认其实我是来打广告的。例子中的<a href="https://github.com/hujewelz/HUPhotoBrowser" target="_blank" rel="noopener"><strong>HUPhotoBrowser</strong></a>是我开源的一个图片浏览器的库，使用起来非常简单，一行代码就以实现图片浏览功能，支持本地和网络图片。希望大家可以支持一下，欢迎大家star。如果有什么问题的话可以直接issue我。最后，希望能跟大家共同进步。项目地址：<a href="https://github.com/hujewelz/HUPhotoBrowser" target="_blank" rel="noopener">HUPhotoBrowser</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>开启 RxSwift 之旅——开篇</title>
    <url>/ck9grdo0p001meyye03vacymp/</url>
    <content><![CDATA[<p>RxSwift 是 ReactiveX 在 Swift 下的实现。ReactiveX 是一个通过使用可观察序列来组合异步和基于事件的程序的库。</p>
<a id="more"></a>

<p>很多地方通常把 ReactiveX 称为 “函数响应式编程” ，其实这是不恰当的。ReactiveX 可以是函数式的，可以是响应式的，但是和“函数响应式编程”是不同的概览。一个主要的不同点是“函数响应式编程”是对随着时间不停变化的值进行操作的，而 ReactiveX 对随时间发射的离散值进行操作。</p>
<p>我们先不急着去看 RxSwift 的源码，在这之前，我们有必要先了解一下什么是响应式编程。</p>
<h2 id="“什么是响应式编程”"><a href="#“什么是响应式编程”" class="headerlink" title="“什么是响应式编程”"></a>“什么是响应式编程”</h2><blockquote>
<p>响应式编程是一种面向数据流和变化传播的编程范式。</p>
</blockquote>
<p>在某种程度上，这并不是什么新东西。用户输入、单击事件、变量值等都可以看做一个流，你可以观察这个流，并基于这个流做一些操作。响应式就是基于这种想法。</p>
<p>一个流就是一个将要发生的以时间为序的事件序列。它能发射出三种不同的东西：一个数据值(某种类型的)，一个错误（error）或者一个“完成（completed）”的信号。比如说，当前按钮所在的窗口或视图关闭时，“单击”事件流也就“完成”了。</p>
<p>以一个单击事件流为例：定义一个针对数据值的函数，在发出一个值时，该函数就会异步地执行，还有一个针对发出错误时的函数，最后还有针对发出‘完成’时的函数。“监听”流的行为叫做订阅。我们定义的这些函数就是观察者。这个流就是被观察的主体(subject)（或“可观察的(observable)”）。这正是观察者设计模式。</p>
<p>在你使用 RxSwift 时，你就会发现它正是按照这种模式来进行设计的。在 RxSwift 中，一个流可以被称为序列(Sequences)。序列的生产者就是 Observable 。</p>
<p>在 RxSwift 的 playground 中就有这么一句话：</p>
<blockquote>
<p>Every Observable instance is just a sequence.</p>
</blockquote>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>如果你在学习 RxSwift 之前就使用过 ReactiveCocoa 的话，你会发现 RxSwift 和 ReactiveCocoa 完全是两个不同的物种。在 RxSwift 的世界里，所有的东西都是 Observable 的。你可以创造它们、操作它们，然后订阅它们来响应变化。</p>
<p>理解 Observable 还有一件很重要的事情：</p>
<blockquote>
<p>Observables will not execute their subscription closure unless there is a subscriber. </p>
</blockquote>
<p>可以这么理解，如果你只是调用一个返回一个 Observable 的方法，生成序列不会被执行。Observable 只是一个解释序列如何被生成和什么参数被使用于生成元素的定义。生成序列开始于 subscribe 方法被调用的时候。</p>
<p>下面的例子中，Observable 的闭包永远不会执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">example(<span class="string">"Observable with no subscribers"</span>) &#123;</span><br><span class="line">    <span class="number">_</span> = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"This will never be printed"</span>)</span><br><span class="line">        observer.on(.next(<span class="string">"😬"</span>))</span><br><span class="line">        observer.on(.completed)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有当我们调用 <code>subscribe(_:)</code> 时，Observable 的闭包才会执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">example(<span class="string">"Observable with subscriber"</span>) &#123;</span><br><span class="line">  <span class="number">_</span> = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Observable created"</span>)</span><br><span class="line">            observer.on(.next(<span class="string">"😉"</span>))</span><br><span class="line">            observer.on(.completed)</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">        &#125;</span><br><span class="line">        .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中从传入闭包创建一个 Observable ，到调用 <code>subscribe(_:)</code> 这个过程中 RxSwift 到底做了什么？我们可以先从简单的 empty 开始。</p>
<h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p>empty 就是创建一个空的 sequence, 它只能发出一个 completed 事件。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">example(of: <span class="string">"empty"</span>) &#123;</span><br><span class="line">    <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line">        .subscribe(&#123;</span><br><span class="line">            <span class="built_in">print</span>($<span class="number">0</span>)</span><br><span class="line">    &#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">--- <span class="type">Example</span> of: empty ---</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>

<p>上面代码中通过 Observable 的 <code>empty</code> 方法创建了一个 <code>Observable&lt;Int&gt;</code>, 打开 Observable+Creation.swift 文件，可以看到 <code>empty()</code> 的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">()</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">E</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">EmptyProducer</span>&lt;<span class="type">E</span>&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里返回了一个 <code>EmptyProducer</code> 的实例，点进去看看<code>EmptyProducer</code>是个什么东西：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyProducer</span>&lt;<span class="title">Element</span>&gt; : <span class="title">Producer</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O : ObserverType&gt;<span class="params">(<span class="number">_</span> observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">Element</span> &#123;</span><br><span class="line">        observer.on(.completed)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EmptyProducer</code>是 <code>Producer</code> 的子类，重写了 <code>subscribe(:)</code> 。在 subscribe 方法中，观察者订阅了一个完成信号。</p>
<p>当我们通过 <code>empty()</code> 创建了一个 Observable 后，然后会调用 <code>subscribe(_:)</code>，打开 ObservableType+Extensions.swift 文件, 可以看到 subscribe 方法的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(<span class="number">_</span> on: @escaping <span class="params">(Event&lt;E&gt;)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span> &#123; e <span class="keyword">in</span></span><br><span class="line">        on(e)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.subscribeSafe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>subscribe 方法接受了闭包之后，先创建了一个匿名观察者，subscribe 的闭包参数作为构造器的参数传给了 observer。点击进去 AnonymousObserver源码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AnonymousObserver</span>&lt;<span class="title">ElementType</span>&gt; : <span class="title">ObserverBase</span>&lt;<span class="title">ElementType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Element</span> = <span class="type">ElementType</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">EventHandler</span> = (<span class="type">Event</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> _eventHandler : <span class="type">EventHandler</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> eventHandler: @escaping <span class="type">EventHandler</span>) &#123;</span><br><span class="line">#<span class="keyword">if</span> <span class="type">TRACE_RESOURCES</span></span><br><span class="line">        <span class="keyword">let</span> <span class="number">_</span> = <span class="type">Resources</span>.incrementTotal()</span><br><span class="line">#endif</span><br><span class="line">        _eventHandler = eventHandler</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">onCore</span><span class="params">(<span class="number">_</span> event: Event&lt;Element&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _eventHandler(event)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">#<span class="keyword">if</span> <span class="type">TRACE_RESOURCES</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="number">_</span> = <span class="type">Resources</span>.decrementTotal()</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AnonymousObserver 的构造器接受一个闭包，然后在 onCore 方法中， 私有的 <code>_eventHandler</code> 会被调用。到这里为止，我们还是不知道我们在调用 <code>subscribe(_:)</code> 时传入的闭包最终的调用时机。不过已经很清楚的知道了，这个闭包在 <code>onCore(:)</code> 中调用了，我们继续进入 AnonymousObserver 的父类 ObserverBase 中一探究竟：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObserverBase</span>&lt;<span class="title">ElementType</span>&gt; : <span class="title">Disposable</span>, <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">E</span> = <span class="type">ElementType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _isStopped: <span class="type">AtomicInt</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;E&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .next:</span><br><span class="line">            <span class="keyword">if</span> _isStopped == <span class="number">0</span> &#123;</span><br><span class="line">                onCore(event)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .error, .completed:</span><br><span class="line">            <span class="keyword">if</span> <span class="type">AtomicCompareAndSwap</span>(<span class="number">0</span>, <span class="number">1</span>, &amp;_isStopped) &#123;</span><br><span class="line">                onCore(event)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onCore</span><span class="params">(<span class="number">_</span> event: Event&lt;E&gt;)</span></span> &#123;</span><br><span class="line">        rxAbstractMethod()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="number">_</span> = <span class="type">AtomicCompareAndSwap</span>(<span class="number">0</span>, <span class="number">1</span>, &amp;_isStopped)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一下就很清楚了，<code>onCore(:)</code> 会被 <code>on(:)</code> 调用。让我们再次回到 ObservableType+Extensions.swift 文件中，匿名观察者(AnonymousObserver)创建完后，调用 <code>subscribeSafe(:)</code> 作为函数返回值。在文件的最下面可以看到 <code>subscribeSafe(:)</code> 的实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribeSafe</span>&lt;O: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.asObservable().subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会调用 <code>subscribe(:)</code> ，注意了，这里的 <code>subscribe(:)</code> 是 ObservableType 协议中定义的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ObservableType</span> : <span class="title">ObservableConvertibleType</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">E</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的参数是一个 ObserverType，也就是一个观察者，千万要与 <code>func subscribe(_ on: @escaping (Event&lt;E&gt;) -&gt; Void) -&gt; Disposable</code> 做好区分。</p>
<p>好了， subscribe 方法将创建的匿名观察者作为参数，而在 EmptyProducer 中的 subscribe 的实现我们已经看过了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">override func subscribe&lt;O : ObserverType&gt;(_ observer: O) -&gt; Disposable where O.E &#x3D;&#x3D; Element &#123;</span><br><span class="line">    observer.on(.completed)</span><br><span class="line">    return Disposables.create()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里刚好调用了观察者的 <code>on(:)</code>, 在 ObserverBase 中 on 方法会调用 <code>onCore(:)</code>, onCore 方法调用了 <code>subscribe(_ on: @escaping (Event&lt;E&gt;) -&gt; Void) -&gt; Disposable</code> 参数中的闭包。由于 <code>subscribe(_ observer: O)</code> 中观察者只订阅了 “completed” 信号，所有闭包不会执行。</p>
<p>至此从创建一个 observable， 到调用 <code>subscribe(_:)</code> 整个过程我们已经很清楚了。现在也就能明白为什么只是调用一个返回一个 Observable 的方法，生成序列不会被执行了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后总结一下调用 <code>subscribe(_:)</code> 后的整个过程：用 subscribe 中的闭包创建一个匿名观察者（观察者私有的 <code>_eventHandler</code> 会将闭包保存起来），然后将创建的匿名观察者作为参数传给 <code>subscribeSafe(:)</code> , <code>subscribeSafe(:)</code> 会调用 <code>subscribe(:)</code>, 并将匿名观察者作为参数。<code>subscribe(:)</code> 会调用 observer 的 <code>on(:)</code>, 当 observer 的 on 方法被调用后，最终会调用开始时传入的闭包。</p>
<p>以上只是分析了一下 empty 的实现，像 of, just, create 等的实现在细节上有一些区别，总的思路是一样的。在查看源码时可能会有一点绕，主要是因为继承太多，很多方法都要到父类中去找，而且 ObservableType 和 ObserverType 的 Extension 太多，代码分散到各个文件中。</p>
<p>RxSwift 的代码只看了个开头，还有很多地方没有完全弄明白。在使用 RxSwift 的过程中你能体会到 “响应式” 和 “函数式” 给我们的开发带来的便利性。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建基于HLS和RTMP的视频推流</title>
    <url>/ck9grdo0q001oeyyef5o16u3p/</url>
    <content><![CDATA[<p>在视频直播越来越火热的今天，作为一个开发者有必要了解一个完整的直播流程是怎样的。在一个完整的手机机直播主要包含了以下几个环节：</p>
<a id="more"></a>

<ul>
<li><p>推流端：采集，前处理，编码，推流。</p>
</li>
<li><p>服务端处理：转码，录制，截图，鉴黄。</p>
</li>
<li><p>播放器：拉流，解码，渲染；互动系统：聊天室，礼物系统等。</p>
</li>
</ul>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在视频直播越来越火热的今天，作为一个开发者有必要了解一个完整的直播流程是怎样的。在一个完整的手机机直播主要包含了以下几个环节：</p>
<ul>
<li><p>推流端：采集，前处理，编码，推流。</p>
</li>
<li><p>服务端处理：转码，录制，截图，鉴黄。</p>
</li>
<li><p>播放器：拉流，解码，渲染；互动系统：聊天室，礼物系统等。</p>
</li>
</ul>
<p>概括起来就是以下几个步骤：</p>
<ul>
<li><p>采集: iOS 系统因为软硬件种类不多，硬件适配性比较好，所以比较简单。而 Android 端市面上机型众多，要做些机型的适配工作。PC 端是最麻烦的，各种奇葩摄像头驱动。所以现在很多的中小型直播平台，只做 iOS 端的视频直播。</p>
</li>
<li><p>前处理: 美颜算法，视频的模糊效果，水印等都是在这个环节做。目前 iOS 端最著名开源框架的毫无疑问就是 GPUImage 。其中内置了一百多种渲染效果，还支持各种脚本自定义。</p>
</li>
<li><p>编码: 重难点在于要在分辨率，帧率，码率，GOP 等参数设计上找到最佳平衡点。iOS8 之后，Apple 开放了 VideoToolbox.framework, 可以直接进行硬编解码，这也是为什么现在大多数直播平台最低只支持到iOS8 的原因之一。iOS 端硬件兼容性比较好，可以直接采取硬编码。而 Android 得硬编码又是一大坑。</p>
</li>
<li><p>传输: 这块一般都是交给 CDN 服务商。CDN 只提供带宽和服务器之间的传输，发送端和接收端的网络连接抖动缓存还是要自己实现的。目前国内最大的CDN服务商应该是网宿。</p>
</li>
<li><p>服务器处理: 需要在服务器做一些流处理工作，让推送上来的流适配各个平台各种不同的协议，比如:RTMP,HLS,FLV…</p>
</li>
<li><p>解码和渲染: 也就即音视频的播放。解码毫无疑问也必须要硬解码。iOS 端兼容较好，Android 依然大坑。这块的难点在于音画同步，国内比较好的开源项目应该是B站开源的<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="noopener">ijkplayer</a>。</p>
</li>
</ul>
<p>对于移动端开发者来说，最主要工作的就是推流端和播放器端了。<br>在本篇文章中我把注意力放在大家不太关注的服务端。同学们只要按照下面的步骤，就能很快的搭建一个视频推流服务器。</p>
<h1 id="在-Mac下-搭建-nginx-rtmp-服务器"><a href="#在-Mac下-搭建-nginx-rtmp-服务器" class="headerlink" title="在 Mac下 搭建 nginx+rtmp 服务器"></a>在 Mac下 搭建 nginx+rtmp 服务器</h1><h3 id="1-使用-homebrew-安装-nginx"><a href="#1-使用-homebrew-安装-nginx" class="headerlink" title="1. 使用 homebrew 安装 nginx"></a>1. 使用 <a href="https://brew.sh" target="_blank" rel="noopener">homebrew</a> 安装 nginx</h3><p>先 clone nginx 到本地：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew tap homebrew/nginx</span><br></pre></td></tr></table></figure>
<p>执行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install nginx-full --with-rtmp-module</span><br></pre></td></tr></table></figure>
<p>此时, nginx和rtmp模块就安装好了, 输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure>
<p>在浏览器里打开 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>，如果出现以下页面说明 nginx 安装成功。</p>
<p><img src="http://image18-c.poco.cn/mypoco/myphoto/20170322/12/18436043320170322125539085.png?526x218_130" alt=""></p>
<h3 id="2-配置-hls-和-rtmp"><a href="#2-配置-hls-和-rtmp" class="headerlink" title="2. 配置 hls 和 rtmp"></a>2. 配置 hls 和 rtmp</h3><p>使用编辑器打开 <code>usr/local/etc/nginx/nginx.conf</code>文件，找到 <code>http</code> 下的 <code>server</code>, 在花括号中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen       8080;</span><br><span class="line">   server_name  localhost;</span><br><span class="line"></span><br><span class="line">   #charset koi8-r;</span><br><span class="line"></span><br><span class="line">   #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">   location &#x2F; &#123;</span><br><span class="line">       root   html;</span><br><span class="line">       index  index.html index.htm;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   # HLS config</span><br><span class="line">   location &#x2F;hls &#123;</span><br><span class="line">       types &#123;</span><br><span class="line">           application&#x2F;vnd.apple.mpegurl m3u8;</span><br><span class="line">           video&#x2F;mp2t ts;</span><br><span class="line">     &#125;</span><br><span class="line">       root html;</span><br><span class="line">       add_header Cache-Control no-cache;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>这样 HLS 就配置好了。</p>
<p>现在来配置 RTMP ，直接滚动到最后一行，在 <code>http</code> 的结束(最后的<code>}</code>)后面添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">       listen 1935;</span><br><span class="line">       application gzhm &#123;</span><br><span class="line">           live on;</span><br><span class="line">           record off;</span><br><span class="line">       &#125;</span><br><span class="line">       #增加对HLS支持开始</span><br><span class="line">       application hls &#123;</span><br><span class="line">           live on;</span><br><span class="line">           hls on;</span><br><span class="line">           hls_path &#x2F;usr&#x2F;local&#x2F;var&#x2F;www&#x2F;hls;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存配置文件，重新加载 nginx 配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h1 id="测试推流"><a href="#测试推流" class="headerlink" title="测试推流"></a>测试推流</h1><p>我们可以使用 <a href="http://ffmpeg.org" target="_blank" rel="noopener">ffmpeg</a> 来进行推流。关于 ffmpeg 的详细用法，大家可以参考官方文档。 </p>
<blockquote>
<p>FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。</p>
</blockquote>
<h3 id="1-使用-homebrew-安装-ffmpeg"><a href="#1-使用-homebrew-安装-ffmpeg" class="headerlink" title="1. 使用 homebrew 安装 ffmpeg"></a>1. 使用 homebrew 安装 ffmpeg</h3><p>在终端执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure>

<p>安装 ffmpeg 时间就要长一点了, 请耐心等待一会。安装完成后，就可以使用 ffmpeg 来推流了。</p>
<h3 id="2-推流"><a href="#2-推流" class="headerlink" title="2. 推流"></a>2. 推流</h3><p>我们可以在终端输入以下命令来推流：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -loglevel verbose -re -i  视频的全路径  -vcodec libx264 -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 -f flv rtmp://localhost:1935/hls/文件名称(不包含后缀)</span><br></pre></td></tr></table></figure>

<p>然后你就可以在 <code>/usr/local/var/www/hls</code> 目录下看到一个后缀名为 <code>.m3u8</code> 的文件和 <code>.ts</code> 分片文件。</p>
<p>这里的输出目录 <code>/hls</code> 是在 <code>nginx.conf</code>中 配置好的。这里要对应，不然是无法推流成功的。</p>
<h3 id="3-测试拉流"><a href="#3-测试拉流" class="headerlink" title="3. 测试拉流"></a>3. 测试拉流</h3><ol>
<li><p>HLS 拉流测试：</p>
<p> 你可以在电脑 Safari 里输入地址查看视频，也可以用 iPad 或者 iPhone 上的 Safari 来访问（需要把 localhost 改为 nginx 的所在电脑的ip地址）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;hls&#x2F;a.m3u8</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTMP 拉流测试<br> 由于浏览器并不支持 rtmp 协议，所以我们需要下载支持 rtmp 协议的视频播放器，可以使用 VLC 播放器。</p>
<p> 将视频推流到服务器后，打开 VLC，然后 File -&gt; open network -&gt; 输入：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trmp:&#x2F;&#x2F;localhost:1935&#x2F;hls&#x2F;a</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>通过以上简单的几个步骤，就能在自己的电脑上搭建推流服务器了。不过在真实的项目中还是建议使用第三方的直播服务，比如阿里云和腾讯云，他们对视频直播都有比较完整的方案。</p>
]]></content>
      <tags>
        <tag>直播</tag>
      </tags>
  </entry>
  <entry>
    <title>打造一个流畅的UITableView</title>
    <url>/ck9grdo0s001seyye9gof2ihd/</url>
    <content><![CDATA[<p>Table view需要有很好的滚动性能，不然用户会在滚动过程中发现动画的瑕疵。<br>为了保证table view平滑滚动，确保你采取了以下的措施:</p>
<a id="more"></a>

<ul>
<li>正确使用<code>reuseIdentifier</code>来重用cell</li>
<li>尽量使所有的view opaque，包括cell自身</li>
<li>避免图片缩放</li>
<li>缓存行高</li>
<li>尽量不要在<code>cellForRowAtIndexPath:</code>中设置数据，如果你需要用到它，只用一次然后缓存结果</li>
<li>对齐像素</li>
<li>使用<code>rowHeight</code>, <code>sectionFooterHeight</code> 和 <code>sectionHeaderHeight</code>来设定固定的高，不要请求delegate</li>
</ul>
<h2 id="1-正确使用-reuseIdentifier-来重用cell"><a href="#1-正确使用-reuseIdentifier-来重用cell" class="headerlink" title="1. 正确使用 reuseIdentifier 来重用cell"></a>1. 正确使用 <strong>reuseIdentifier</strong> 来重用cell</h2><p>一个开发中常见的错误就是没有给UITableViewCells， UICollectionViewCells，甚至是UITableViewHeaderFooterViews设置正确的reuseIdentifier。</p>
<p>为了性能最优化，table view用 <code>tableView:cellForRowAtIndexPath:</code> 为rows分配cells的时候，它的数据应该重用自UITableViewCell。</p>
<p>不使用reuseIdentifier的话，每显示一行，table view就不得不创建全新的cell。这对性能的影响可是相当大的，尤其会使app的滚动体验大打折扣。所以在使用 UITableViewCell， UICollectionViewCell，或者 UITableViewHeaderFooterView 的时候一定要使用reuseIdentifier。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">  static NSString *ID &#x3D; @&quot;cell&quot;;</span><br><span class="line">  TableViewCell *cell &#x3D; [tableView dequeueReusableCellWithIdentifier:ID forIndexPath:indexPath];</span><br><span class="line">  </span><br><span class="line">  return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section &#123;</span><br><span class="line">  static NSString *footerViewWithIdentifie &#x3D; @&quot;footer&quot;;</span><br><span class="line">  UITableViewHeaderFooterView *footer &#x3D; [tableView dequeueReusableHeaderFooterViewWithIdentifier:footerViewWithIdentifie];</span><br><span class="line">  return footer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-尽量把views设置为不透明"><a href="#2-尽量把views设置为不透明" class="headerlink" title="2. 尽量把views设置为不透明"></a>2. 尽量把views设置为不透明</h2><p>如果你有不透明的Views，你应该设置它们的opaque属性为YES。一些没有被设置为opaque的视图，因为透明通道的存在，系统需要去计算图层堆叠后像素点的真实颜色，这就会产生是混合(blending)操作。我们可以通过模拟器的Debug\Color Blended Layers 选项来查看哪些 view 没有设置为不透明。选中’Color Blended Layers‘。然后iOS模拟器就会将全部区域显示为两种颜色：绿色和红色。绿色区域表示没有混合，但红色区域表示有混合操作。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/tabelview/opaque.png" alt="opaque"></p>
<p>如果屏幕是静止的，那么这个opaque属性的设置与否不是一个大问题。但是，如果 view 是嵌入到 scroll view 中的，或者是复杂动画的一部分，不将设置这个属性的话肯定会影响程序的性能。所以为了程序的性能，尽可能的将view设置为不透明。</p>
<h2 id="3-避免图片缩放"><a href="#3-避免图片缩放" class="headerlink" title="3. 避免图片缩放"></a>3. 避免图片缩放</h2><p>如果要在 <code>UIImageView</code> 中显示一个来自bundle的图片，你应保证图片的大小和 <code>UIImageView</code> 的大小相同。在运行中缩放图片是很耗费资源的，特别是 <code>UIImageView</code> 嵌套在 <code>UIScrollView</code> 中的情况下。如果不做任何处理，直接将图片丢进去，问题就大了，这意味着，GPU需要对大图进行缩放到小的区域显示，需要做像素点的sampling，这种smapling的代价很高，又需要兼顾pixel alignment。计算量会飙升。<br>如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大小的话，你可以在下载完成后，最好是用background thread，缩放一次，然后在UIImageView中使用缩放后的图片。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span> *)imageByScalingAndCroppingForSize:(<span class="built_in">CGSize</span>)targetSize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIImage</span> *sourceImage = <span class="keyword">self</span>;</span><br><span class="line">    <span class="built_in">UIImage</span> *newImage = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = sourceImage.size;</span><br><span class="line">    <span class="built_in">CGFloat</span> width = imageSize.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> height = imageSize.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> targetWidth = targetSize.width;</span><br><span class="line">    <span class="built_in">CGFloat</span> targetHeight = targetSize.height;</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = <span class="number">0.0</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> scaledWidth = targetWidth;</span><br><span class="line">    <span class="built_in">CGFloat</span> scaledHeight = targetHeight;</span><br><span class="line">    <span class="built_in">CGPoint</span> thumbnailPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.0</span>,<span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CGSizeEqualToSize</span>(imageSize, targetSize) == <span class="literal">NO</span>) &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> widthFactor = targetWidth / width;</span><br><span class="line">        <span class="built_in">CGFloat</span> heightFactor = targetHeight / height;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (widthFactor &gt; heightFactor)</span><br><span class="line">            scaleFactor = widthFactor; <span class="comment">// scale to fit height</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            scaleFactor = heightFactor; <span class="comment">// scale to fit width</span></span><br><span class="line">        scaledWidth  = width * scaleFactor;</span><br><span class="line">        scaledHeight = height * scaleFactor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// center the image</span></span><br><span class="line">        <span class="keyword">if</span> (widthFactor &gt; heightFactor) &#123;</span><br><span class="line">            thumbnailPoint.y = (targetHeight - scaledHeight) * <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (widthFactor &lt; heightFactor) &#123;</span><br><span class="line">            thumbnailPoint.x = (targetWidth - scaledWidth) * <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(targetSize); <span class="comment">// this will crop</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> thumbnailRect = <span class="built_in">CGRectZero</span>;</span><br><span class="line">    thumbnailRect.origin = thumbnailPoint;</span><br><span class="line">    thumbnailRect.size.width  = scaledWidth;</span><br><span class="line">    thumbnailRect.size.height = scaledHeight;</span><br><span class="line">    </span><br><span class="line">    [sourceImage drawInRect:thumbnailRect];</span><br><span class="line">    </span><br><span class="line">    newImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="keyword">if</span>(newImage == <span class="literal">nil</span>)</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"could not scale image"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> newImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-缓存行高"><a href="#4-缓存行高" class="headerlink" title="4. 缓存行高"></a>4. 缓存行高</h2><p>这个方法对于cell定高的UITableView来说没有意义，但如果由于某些原因需要动态高度的cell的话，这个方法可以很容易地让滑动更流畅。</p>
<p>UITableView的delegate方法<code>tableView:heightForRowAtIndexPath:</code>会为每个cell调用一次，所以你应该非常快地返回高度值，避免做一些复杂的高度计算。所以如果你需要动态计算cell的高度的话，应该在调用这个方法之前就计算好高度，并将其缓存起来。我的习惯是在从服务器获取完数据后，在做数据模型化的时候计算内容的高度，并用属性保存起来。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  CellModel *model = <span class="keyword">self</span>.cellModels[indexPath.row];</span><br><span class="line">  <span class="keyword">return</span> model.rowHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你的cell高度是固定的话，请使用<code>rowHeight</code>, <code>sectionFooterHeight</code> 和 <code>sectionHeaderHeight</code>来设定固定的高，不要请求delegate。因为<code>tableView:heightForRowAtIndexPath:</code>会为每个cell调用一次。</p>
<h2 id="5-尽量不要在cellForRowAtIndexPath-中设置数据"><a href="#5-尽量不要在cellForRowAtIndexPath-中设置数据" class="headerlink" title="5. 尽量不要在cellForRowAtIndexPath:中设置数据"></a>5. 尽量不要在<code>cellForRowAtIndexPath:</code>中设置数据</h2><p>在UITableView的dataSource中实现的<code>tableView:cellForRowAtIndexPath:</code>方法，需要为每个cell调用一次，它应该快速执行。所以你需要尽可能快地返回重用cell实例。不要在这里去执行数据绑定，因为目前在屏幕上还没有cell。为了执行数据绑定，可以在UITableView的delegate方法<code>tableView:willDisplayCell:forRowAtIndexPath:</code>中进行。这个方法在显示cell之前会被调用。</p>
<h2 id="6-对齐像素"><a href="#6-对齐像素" class="headerlink" title="6. 对齐像素"></a>6. 对齐像素</h2><p>在完美的世界中(我们尝试构建的)，屏幕点总是被处理成物理像素的整型坐标。但在现实生活中它可能是浮点值，例如，线段可能起始于x为0.25的地方。这时候，iOS将执行子像素渲染。</p>
<p>这一技术在应用于特定类型的内容(如文本)时很有意义。但当我们绘制平滑直线时则没有必要。<br>如果所有的平滑线段都使用子像素渲染技术来渲染，那你会让iOS执行一些不必要的任务，从而降低FPS。</p>
<p>什么情况下会出现这种不必要的子像素抗锯齿操作呢？最常发生的情况是通过代码计算而变成浮点值的视图坐标，或者是一些不正确的图片资源，这些图片的大小不是对齐到屏幕的物理像素上的（例如，你有一张在Retina显示屏上的大小为60X61的图片，而不是60X60的）。</p>
<p>我们可以在iOS模拟器上运行程序，在”Debug“菜单中选中”Color Misaligned Image“。<br>这一次有两种高亮区域：品红色区域会执行子像素渲染，而黄色区域是图片大小没有对齐的情况。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/tabelview/yellow.png" alt=""></p>
<p>所以为了避免出现上面的情况，要做到这两点：</p>
<ul>
<li>对所有像素相关的数据做四舍五入处理（使用ceilf, floorf和CGRectIntegral），包括点坐标，UIView的高度和宽度。</li>
<li>跟踪你的图像资源：图片必须是像素完美的，否则在Retina屏幕上渲染时，它会做不必要的抗锯齿处理。</li>
</ul>
<h2 id="7-少用masksToBounds"><a href="#7-少用masksToBounds" class="headerlink" title="7. 少用masksToBounds"></a>7. 少用masksToBounds</h2><p>日常生产中app布局离不开美丽的圆角(RounderCorner)，特别是用圆角UIImageView来做数据呈现交互，但是这种柔和易于让人接受的视图效果并不仅仅是改变了一个形状那么简单，需要付出一定的性能代价。<br>相信这已经是总所周知的问题了，日常我们使用layer的两个属性，简单的两行代码就能实现圆角的呈现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">imageView.layer.cornerRadius = <span class="number">20</span>;</span><br><span class="line">imageView.layer.masksToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>

<p>由于这样处理的渲染机制是GPU在当前屏幕缓冲区外新开辟一个渲染缓冲区进行工作，也就是离屏渲染，这会给我们带来额外的性能损耗，如果这样的圆角操作达到一定数量，会触发缓冲区和上下文的的频繁切换，这个才是最致命的，创建新的缓冲区代价都不算大，付出最大代价的是上下文切换。性能的代价会宏观地表现在用户体验上—-掉帧。</p>
<p>如果你非得使用<code>cornerRadius</code>呢？如果你非得这做的话，那么这样也可以拯救你：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.layer.shouldRasterize = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.layer.rasterizationScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br></pre></td></tr></table></figure>

<p><code>shouldRasterize = YES</code> 会使视图渲染内容被缓存起来，下次绘制的时候可以直接显示缓存，当然要在视图内容不改变的情况下。</p>
<p>最好的方式是：预先生成圆角图片，并缓存起来。预处理圆角图片可以在后台处理，处理完毕后缓存起来，再在主线程显示，这就避免了不必要的离屏渲染了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImageView</span> (<span class="title">CornerRadius</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hu_setCornerRadius:(<span class="built_in">CGFloat</span>)radius &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> bq = dispatch_queue_create(<span class="string">"com.hujewelz.cornerradius"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  <span class="built_in">dispatch_async</span>(bq, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(<span class="keyword">self</span>.bounds.size, <span class="literal">NO</span>, [<span class="built_in">UIScreen</span> mainScreen].scale);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:<span class="keyword">self</span>.bounds byRoundingCorners:<span class="built_in">UIRectCornerAllCorners</span> cornerRadii:<span class="built_in">CGSizeMake</span>(radius, radius)];</span><br><span class="line">    [path addClip];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.image drawInRect:<span class="keyword">self</span>.bounds];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="keyword">self</span>.image = image;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在iOS模拟器上运行程序，在”Debug“菜单中选中”Color Offscreen-Rendered“。<br>黄色区域表示产生了离屏渲染。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>教你如何用Swift写个json转模型的开源库</title>
    <url>/ck9grdo0t001ueyye8298emtu/</url>
    <content><![CDATA[<p>在iOS项目开发过程中，我们经常会用到将从服务器获取的 json 转 model 的操作，我们可以使用 Swift 提供的<code>setValuesForKeys</code> 或者 Objective-C 提供的<code>setValuesForKeysWithDictionary</code> 方法来完成这一操作。</p>
<a id="more"></a>

<p>使用上面两个方法只能将字典转换成 model , 如果 json 最外层是个数组，那么我们就必须在循环中使用这个方法，这非常不方便， 而且还有个条件，就是 model 中的所有属性名必须跟字典中的 key 完全对应，这样就会遇到另外一个问题，如果我们字典中的一个 key 与系统关键字重名，那我们在 model 就不能使用这个 key 作为属性名了。</p>
<p>为了解决上面的问题，我们会使用一些第三方库去完成字典转模型的操作，例如 MJExtension 。由于它是一个 OC 的库，所以在 Swift 项目中需要引入桥接文件。在 Swift 中使用其 API 时其实是很不 swift 的。所以现在我们就用 Swift 3.0 来写一个 swift style 的 json 转模型的库吧。</p>
<p>例如我们有这样的两个 model:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User: NSObject &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age &#x3D; 0</span><br><span class="line">    var desc: String?</span><br><span class="line">&#125;</span><br><span class="line">class Repos: NSObject &#123;</span><br><span class="line">    var title: String?</span><br><span class="line">    var owner: User?</span><br><span class="line">    var viewers: [User]?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们想实现这样的调用: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let repos &#x3D; json ~&gt; Repos.self    &#x2F;&#x2F; 将一个字典转成一个Repos的实例</span><br><span class="line"> </span><br><span class="line">let viewers  &#x3D; viewers &#x3D;&gt; User.self  &#x2F;&#x2F;将一个数组转换成User的数组</span><br></pre></td></tr></table></figure>
<p><code>~&gt;</code> 和 <code>=&gt;</code> 是自定义的运算符，主要是为了调用方便。它们的定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public func ~&gt;&lt;T: NSObject&gt;(lhs: Any, rhs: T.Type) -&gt; T?</span><br><span class="line">public func &#x3D;&gt;&lt;T: NSObject&gt;(lhs: Any, rhs: T.Type) -&gt; [T]?</span><br></pre></td></tr></table></figure>
<p>这里给出我的实现 <a href="https://github.com/hujewelz/modelSwift" target="_blank" rel="noopener">ModelSwift</a>。大家可以先看看我的实现然后试着写出自己的实现。好了，现在就让我们开始吧。</p>
<h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h2><p>由于将数组转成模型数组，其实要做的工作跟将字典转模型是一样的，只是做了个循环而已。所以我们首先要解决的问题是：如何在 Swift 将字典转成模型。这里我们是使用 KVC就可以了。我们使用 NSObject 的  <code>setValue(_ value: Any?, forKey key: String)</code> 方法来给对象设置值。</p>
<p>从上面要实现的效果来看，我们在使用前并不用先实例化一个对象。所以我们要解决的第二个问题是：如何通过类型来实例化一个对象。 </p>
<p>另一个要解决的问题是字典中的 key 与关键字重名，或者我们想使用自己的名字。所以我们要实现自己的映射的策略。</p>
<p>还有一个问题是，如果我们服务器返回的字典数据中包含另外一个字典数组，对应我们的 model 中就是一个对象包含另外一个对象的数组。那么我们怎样才能知道这个数组中对象的类型呢？</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>对于上面提到的第一问题我在上面已经给出了解决方案，就是让我们的 model 继承 NSObject, 然后使用   <code>setValue(_ value: Any?, forKey key: String)</code> 方法来给对象设置值。这里的 <code>value</code> 其实是要根据 model 中的属性名去字典中获取的。如果我们能拿到 model 所有的属性名，那么给 model 设置值的操作就完成了。那么如何获取到 model 的属性名呢？这就必须得使用到 Swift 中的反射机制了。</p>
<h3 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h3><p>Swift 的反射机制是基于一个叫 Mirror 的 <code>struct</code> 来实现的。对于 Mirror 的详细结构大家可以按住 <code>cmd</code> 点进去查看。这里我们主要关注的是 <code>public typealias Child = (label: String?, value: Any)</code> 这个 typealias，它其实是一个元祖，<code>label</code> 就表示我们的属性名，是 Optional 的。<code>value</code> 表示的是属性的值。这里 <code>label</code> 为什么是 Optional 的？如果你仔细考虑下，其实这是非常有意义的，并不是所有支持反射的数据结构都包含有名字的子节点。 Mirror 会以属性的名字做为 <code>label</code>，但是 Collection 只有下标，没有名字。Tuple 同样也可能没有给它们的条目指定名字。</p>
<p>Mirror 有个 <code>children</code> 的存储属性，它的定义是这样的: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public let children: Mirror.Children</span><br></pre></td></tr></table></figure>
<p>这里的 <code>Mirror.Children</code> 也是一个 typealias，它是这样定义的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public typealias Children &#x3D; AnyCollection&lt;Mirror.Child&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到它是 Child 的集合。所以我们可以通过 Mirror 的 <code>children</code> 属性来获得 model 的所有属性名。</p>
<p>我们写个类来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var age &#x3D; 0</span><br><span class="line">    var friends: [Person]?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mirror &#x3D; Mirror(reflecting: Person())</span><br><span class="line">for case let (label?, value) in mirror.children &#123;</span><br><span class="line">    print (&quot;\(label) &#x3D; \(value)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; </span><br><span class="line">age &#x3D; 0</span><br><span class="line">friends &#x3D; nil</span><br></pre></td></tr></table></figure>
<p>Mirror 还有一个类型为 <code>Any.Type</code> 的 <code>subjectType</code> 存储属性，表示该映射对象的类型，例如上面的 <code>mirror.subjectType</code> 就是 <code>User</code>。使用 <code>subjectType</code> 就可以获得对象的类型以及其所有属性的类型。为了实现这个效果，我们可以写出下面的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func subjectType(of subject: Any) -&gt; Any.Type &#123;</span><br><span class="line">    let mirror &#x3D; Mirror(reflecting: subject)</span><br><span class="line">    return mirror.subjectType</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func children(of subject: Any) &#123;</span><br><span class="line">    let mirror &#x3D; Mirror(reflecting: subject)</span><br><span class="line">    for case let(label?, value) in mirror.children &#123;</span><br><span class="line">        print (&quot;\(label) &#x3D; \(subjectType(of: value))&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">children(of: Person())</span><br></pre></td></tr></table></figure>
<p>打印结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; String</span><br><span class="line">age &#x3D; Int</span><br><span class="line">friends &#x3D; Optional&lt;Array&lt;Person&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>我原本想使用这个方法来得到 model 中包含的另外对象的类型和数组中对象的类型，例如 Person 中有 <code>father</code> 和 <code>friends</code> 属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var age &#x3D; 100</span><br><span class="line">    var father: Person?</span><br><span class="line">    var friends: [Person]?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是发现结果是 <code>Optional&lt;Person&gt;</code> 和 <code>Optional&lt;Array&lt;Person&gt;&gt;</code>。所以我们还是得显示地指出一个 model 中包含的其他对象的类型，以及数组中对象的类型。在后面我会给出自己的实现。大家可以给出自己的实现。</p>
<h3 id="通过类型来实例化一个对象"><a href="#通过类型来实例化一个对象" class="headerlink" title="通过类型来实例化一个对象"></a>通过类型来实例化一个对象</h3><p>要使用 Mirror 来获得反射对象的所有属性名，就必须先使用 <code>init(reflecting subject: Any)</code> 来创建一个 Mirror。而创建 Mirror 就必须传入一个 subject（在这里我们主要传入一个NSObject类型的对象）。所以我们的首要任务就是通过类型来实例化一个对象。</p>
<blockquote>
<p>有些同学可能有疑问了：我要转换成 Person 的对象，我直接传入一个<br> Person 的实例就行了啊。如果你看看我们 josn 转模型的方法定义就能明白了。 <code>func ~&gt;&lt;T: NSObject&gt;(lhs: Any, rhs: T.Type) -&gt; T?</code></p>
</blockquote>
<p>还是以上面的 Person 为例，我们看看这样的调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.self().age</span><br><span class="line">&#x2F;&#x2F; 结果是：100</span><br></pre></td></tr></table></figure>
<p>所以我们通过一个类的 <code>self()</code>方法可以得到一个类的实例。其实我们还可以通过 AnyClass 来实例化对象。AnyClass 是类的类型，其定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public typealias AnyClass &#x3D; AnyObject.Type</span><br></pre></td></tr></table></figure>
<p>我们通过类的<code>self</code>属性可以得到类的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.self     </span><br><span class="line">&#x2F;&#x2F;结果是：Person.Type</span><br></pre></td></tr></table></figure>
<p>得到类的类型后，通过调用其 <code>init()</code>方法就可以创建一个实例了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.self.init().age</span><br><span class="line">&#x2F;&#x2F; 结果是：100</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用类型创建对象的类中的init方法前面必须是 required 的，因为这么创建方式是使用meta type来创建的。由于我们 json 转模型的 model 是继承自 NSObject 的，所以不用在每个类中显示地实现。</p>
</blockquote>
<h2 id="写个简单的-josn-转模型"><a href="#写个简单的-josn-转模型" class="headerlink" title="写个简单的 josn 转模型"></a>写个简单的 josn 转模型</h2><p>有了上面的基础就可以来实现我们的 josn 转模型了。首先我们来写出 <code>~&gt;</code> 的定义，并通过类来创建一个对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">infix operator ~&gt;</span><br><span class="line"></span><br><span class="line">func ~&gt;&lt;T: NSObject&gt;(lhs: Any, rhs: T.Type) -&gt; T? &#123;</span><br><span class="line">    guard let json &#x3D; lhs as? [String: Any], !json.isEmpty else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let obj &#x3D; T.self()</span><br><span class="line">    let mirror &#x3D; Mirror(reflecting: obj)</span><br><span class="line">    </span><br><span class="line">    for case let(label?, value) in mirror.children &#123;</span><br><span class="line">        print (&quot;\(label) &#x3D; \(value)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person: NSObject &#123;</span><br><span class="line">    var name &#x3D; &quot;&quot;</span><br><span class="line">    var age &#x3D; 0</span><br><span class="line"></span><br><span class="line">    override var description: String &#123;</span><br><span class="line">        return &quot;name &#x3D; \(name), age &#x3D; \(age)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let json: [String: Any] &#x3D; [&quot;name&quot;: &quot;jewelz&quot;, &quot;age&quot;: 100]</span><br><span class="line">let p &#x3D; json ~&gt; Person.self</span><br><span class="line">&#x2F;&#x2F; 打印结果：</span><br><span class="line">&#x2F;&#x2F; name &#x3D; </span><br><span class="line">&#x2F;&#x2F; age &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>通过上面的几行代码我们确实成功的创建了一个 Person 的实例了。下一步就是给实例设置值了。我们在上面的 <code>for</code> 循环中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 从字典中获取值</span><br><span class="line">if let value &#x3D; json[label] &#123;</span><br><span class="line">     obj.setValue(value, forKey: label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个代码就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">infix operator ~&gt;</span><br><span class="line"></span><br><span class="line">func ~&gt;&lt;T: NSObject&gt;(lhs: Any, rhs: T.Type) -&gt; T? &#123;</span><br><span class="line">    guard let json &#x3D; lhs as? [String: Any], !json.isEmpty else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let obj &#x3D; T.self()</span><br><span class="line">    let mirror &#x3D; Mirror(reflecting: obj)</span><br><span class="line">    </span><br><span class="line">    for case let(label?, _) in mirror.children &#123;</span><br><span class="line">        &#x2F;&#x2F; 从字典中获取值</span><br><span class="line">        if let value &#x3D; json[label] &#123;</span><br><span class="line">            obj.setValue(value, forKey: label)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p &#x3D; json ~&gt; Person.self</span><br><span class="line">print(p!)</span><br><span class="line">&#x2F;&#x2F;结果：name &#x3D; jewelz, age &#x3D; 100</span><br></pre></td></tr></table></figure>
<p>有了上面 <code>~&gt;</code> 的实现，<code>=&gt;</code> 的实现就很简单了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">infix operator &#x3D;&gt;</span><br><span class="line">func &#x3D;&gt;&lt;T: NSObject&gt;(lhs: Any, rhs: T.Type) -&gt; [T]? &#123;</span><br><span class="line">    guard let array &#x3D; lhs as? [Any], !array.isEmpty else &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return array.flatMap&#123; $0 ~&gt; rhs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面只是实现了一个简单 josn 转模型，其实在实际项目中要解决的问题还有很多。现在再来看看我在文章开头给出的 User 类和 Respo 类:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class User: NSObject &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var age &#x3D; 0</span><br><span class="line">    var desc: String?</span><br><span class="line">&#125;</span><br><span class="line">class Repos: NSObject &#123;</span><br><span class="line">    var title: String?</span><br><span class="line">    var owner: User?</span><br><span class="line">    var viewers: [User]?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只简单的用上面的实现是无法得到想要的结果的。对于 User 类来说，<code>desc</code> 属性对应 json 的 <code>description</code> key，所以我们还要进行 model 的属性与 json 的键的映射。这里的思路就是将 model 的属性名作为 key，以要替换的 json 的键作为 value 存入字典中。我们可以拓展 NSObject ，添加一个计算属性并提供一个空实现。不过这样的倾入性太大，毕竟不是所有的类都需要做这个映射。所以最后的方式是 POP。比如我们可以制定这样一个协议：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public protocol Reflectable: class &#123;</span><br><span class="line">    var reflectedObject: [String: Any.Type] &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在需要做映射的类中去实现该协议。</p>
<p>对于更复杂的 Repos 类来说，要做的事情更多。比如  <code>owner</code>的类型怎么知道？<code>owner</code> 这个对象怎么完成赋值？<code>viewers</code> 数组中的类型是什么，怎样才能完成赋值？ 虽然通过上面提到的 Mirro 可以得到所有的类型，但得到的是 <code>Optional&lt;User&gt;</code>以及 <code>Optional&lt;Array&lt;User&gt;&gt;</code>。我的解决的办法就跟上面做属性名替换是一样的。这里就不详细地说明了，大家可以各显神通。写出自己的实现。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过上面的几个步骤，我们就能很快的实现一个简单的 json 转模型的需求了。总结起来就是以下几点：</p>
<ul>
<li>所有要转换的 model 继承 NSObject </li>
<li>使用类的类型来实例化对象</li>
<li>通过反射获得对象的所有属性名</li>
<li>通过  <code>setValue(_ value: Any?, forKey key: String)</code> 方法来给属性设置值</li>
</ul>
<p>对于在最后提出的几个问题，我这里就不一一详细地说明了。大家可以<a href="https://github.com/hujewelz/modelSwift" target="_blank" rel="noopener">点这里</a>看看我的实现。大家可以使用 CocoaPods 或者 Carthage 将 <a href="https://github.com/hujewelz/modelSwift" target="_blank" rel="noopener">ModelSwift</a> 集成到项目中。如果在使用中有什么问题可以 issue 我，也可以给个 star 持续关注。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>组件生命周期管理和通信方案</title>
    <url>/ck9grdo0v001yeyyech57bwur/</url>
    <content><![CDATA[<p>随着移动互联网的快速发展，项目的迭代速度越来越快，需求改变越来越频繁，传统开发方式的工程所面临的一些，如代码耦合严重、维护效率低、开发不够敏捷等问题就凸现了出来。于是越来越多的公司开始推行”组件化”，通过对原有业务或新业务进行组件(或模块)拆分来提高并行开发效率。</p>
<a id="more"></a>

<p>在笔者面试过程中发现，很多同学口中的”组件化”也只是把代码分库，然后在主项目中使用 CocoaPods 把各个子库聚合起来。对于怎样合理地对组件分层、如何管理组件(主要包括组件的生命周期管理和组件的通信管理)，如何管理不同版本的依赖，以及是否有整套集成和发布工具，这类问题的知之甚少。如果完全不了解这些问题，那么只是简单的对主项目进行组件拆分，并不能提高多少开发效率。</p>
<p>笔者认为合理地进行组件拆分和管理各个组件之间的通信是组件化过程中最大的难点。合理地进行组件拆分是为了解耦，并且各个组件能更容易地独立变化。而对于一个完整的应用来说，每个组件不可能孤零零地存在，必定会互相调用。这样不同组件之间必须能进行通信而又没有<em>编译期的依赖</em>。</p>
<h2 id="组件生命周期管理"><a href="#组件生命周期管理" class="headerlink" title="组件生命周期管理"></a>组件生命周期管理</h2><p>可能很多同学在实施组件化的过程中知道要解决组件通信的问题，却很少关注组件的生命周期。这里的生命周期主要是指 AppDelegate 中的生命周期方法。有时候一些组件需要在这些钩子方法中做一些事情，这时候就需要一个能够管理组件的工具，并在适当的时机执行组件相应的逻辑。</p>
<p>比如笔者在项目中是这样做的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    [[Ant shareInstance] application:application didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[Ant shareInstance] applicationWillResignActive:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[Ant shareInstance] applicationDidEnterBackground:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[Ant shareInstance] applicationWillEnterForeground:application];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有注册的组件(模块)会在 AppDelegate 相应的生命周期方法调用时自动调用。例如有如下组件定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">ANT_MODULE_EXPORT(Module1App)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Module1App</span>() &lt;<span class="title">ATModuleProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Module1App</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    state = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Module A state: %zd"</span>, state);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application &#123;</span><br><span class="line">    state += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Module A state: %zd"</span>, state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>上面示例代码中第一行的 <code>ANT_MODULE_EXPORT(Module1App)</code> 是导出组件。<a href="https://github.com/hujewelz/Ant" target="_blank" rel="noopener">Ant</a> 会在 dyld 加载完 image 后将导出的组件进行注册。当应用生命周期方法被调用时，会实例化所有注册过的组件，调用组件相应的方法，并进行缓存，之后再次调用就会从缓存中取出组件的实例对象。</p>
<blockquote>
<p>一般拥有完整生命周期的组件一般称为一个模块，一个模块其实也是一个独立的组件，它一般是包含一个完整的业务，列如：登录模块，外卖模块，消息模块等。</p>
</blockquote>
<p>组件的生命周期管理并不复杂，实现方案都没有太大区别，但它也是组件化中必不可少的部分。</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>业界关于组件通信的方案比较多，主要有：<code>url-block</code>, <code>target-action</code>, <code>protocol-class</code>。下面笔者会对这三种方案做个简单的介绍。</p>
<h4 id="URL-Block"><a href="#URL-Block" class="headerlink" title="URL-Block"></a>URL-Block</h4><p>这是蘑菇街在组件化过程中使用的一种组件间通信方式，在应用启动时注册组件提供的服务，把调用组件使用的<code>url</code>和组件提供的服务<code>block</code>对应起来，保存到内存中。在使用组件的服务时，通过<code>url</code>找到对应的<code>block</code>，然后获取服务。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[MGJRouter registerURLPattern:<span class="string">@"mgj://foo/bar"</span> toHandler:^(<span class="built_in">NSDictionary</span> *routerParameters) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"routerParameterUserInfo:%@"</span>, routerParameters[MGJRouterParameterUserInfo]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[MGJRouter openURL:<span class="string">@"mgj://foo/bar"</span>];</span><br></pre></td></tr></table></figure>

<p>笔者是在15年开始学习组件化，那个时候就是使用的蘑菇街的这种发案。不过笔者从来没有在实际项目中使用这种方案。casa 在<a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">这篇文章</a>中批判了这种方案。笔者对 case 的观点很是赞同。</p>
<p>如果项目中需要很多组件的服务，那么就需要在内存中维护大量的 <code>url-block</code>项，造成内存问题，对于服务注册的代码应该放在什么地方也是一个问题。笔者一直认为 <code>url-block</code> 注册是一种很粗暴的方式，比如某个应用在启动时注册了100个服务，但某些服务在用户使用过程中根本就没有触发，这就造成了内存浪费。比如我们点击应用中的按钮跳转到某个页面，如果用户没有点击按钮，下个页面就永远不会创建，我们一般不会提前创建这个页面的。笔者更倾向于在需要服务的时候才进行服务对象的创建，在特定场景下也提供服务对象的缓存。</p>
<p>使用 <code>url</code> 传参也是一个不可忽略的问题，对于一些基础数据类型，使用这种方案倒是没有问题，但是对于一些非常规对象就无能为力了，如 <code>UIImage</code>, <code>NSData</code> 等类型。</p>
<p>还有一个问题是 casa 在文章中没有指出的，这个问题在他的 <code>target-action</code> 方案中也存在。下面用一个例子来说明一下。</p>
<p>比如在一个组件 A 中提供了一个服务：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[MGJRouter registerURLPattern:<span class="string">@"mgj://foo/bar"</span> toHandler:^(<span class="built_in">NSDictionary</span> *routerParameters) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"routerParameterUserInfo:%@"</span>, routerParameters[MGJRouterParameterUserInfo]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>然后在一个组件 B 中使用了服务：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[MGJRouter openURL:<span class="string">@"mgj://foo/bar"</span>];</span><br></pre></td></tr></table></figure>

<p>从上面示例代码中可以看到，两个不同组件能通信其实是通过一个字符串来定义的。如果服务使用方在写代码时写错了一个字符，那么使用方根本就不可能调起正确的服务，一旦出现这个问题，在开发过程中很难被发现。如果我们对组件多，注册的服务多，那么在使用时就存在很大的沟通问题，提供方和接入方可能会在每个字符串所代表的意义上浪费大量的时间。而这些问题都可以在工程设计上避免的。虽说我们在写代码时要低耦合，但并不代表不要耦合，有时候需要一些耦合来提高代码的健壮性和可维护性。</p>
<p>在 Swift 中可以使用枚举来解决上面的问题，我们可以像下面这样做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">URLPatternCompatible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">URLPattern</span>: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> orderDetail</span><br><span class="line">    <span class="keyword">case</span> others</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeService</span>: <span class="title">URLPatternCompatible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">URLPattern</span>: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .orderDetail:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"mgj://foo/bar/orderdetail"</span></span><br><span class="line">        <span class="keyword">case</span> .others:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"mgj://foo/bar/others"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A (服务提供方)</span></span><br><span class="line"><span class="type">MGJRouter</span>.register(.orderDetail) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B (服务使用方)</span></span><br><span class="line"><span class="type">MGJRouter</span>.<span class="keyword">open</span>(.orderDetail)</span><br></pre></td></tr></table></figure>

<p>SomeService 的定义可以放到一个专门的组件中，服务提供方和使用方都依赖这个专门的组件。我们这里不仅将字符串放到了一个统一的地方进行维护，而且还将一些在运行期才能发现的问题提前暴露到编译器。这里我们通过耦合来达到提高代码的健壮性和可维护性的目的。</p>
<h4 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h4><p>Target-actin 是 casa 在批判蘑菇街的方案时提出的一种方案。它解决了 <code>url-block</code> 方案中内存问题、url 传参问题、没有区分本地调用和远程调用等问题。其核心就是使用了 NSObject 的 <code>- (id)performSelector:(SEL)aSelector withObject:(id)object;</code> 方法。</p>
<p>在本地应用调用中，本地组件A在某处调用 <code>[[CTMediator sharedInstance] performTarget:targetName action:actionName params:@{...}]</code> 向 <code>CTMediator</code> 发起跨组件调用，<code>CTMediator</code> 根据获得的 target 和 action 信息，通过 objective-C 的 runtime 转化生成 target 实例以及对应的 action 选择子，然后最终调用到目标业务提供的逻辑，完成需求。</p>
<p>casa 在文章中也给出了 demo，在具体的项目中，我们可以这样使用:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CTMediator+SomeAction.h</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)xx_someAction:(<span class="built_in">NSDictionary</span> *)params;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CTMediator+SomeAction.m </span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)xx_someAction:(<span class="built_in">NSDictionary</span> *)params &#123;</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">self</span> performTarget:<span class="string">@"A"</span> action:<span class="string">@"someAction"</span> params:params shouldCacheTarget:<span class="literal">NO</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是提供给服务调用方的一个简洁的接口。其实就是对 CTMediator 方法的封装。我们一般将 CTMediator 的这个分类放到一个独立的组件中。调用方依赖这个独立的组件就可以了。</p>
<p>在某个组件中调用服务：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件 A 中</span></span><br><span class="line"><span class="built_in">UIViewController</span> *vc = [<span class="built_in">CTMediator</span> sharedInstance] xx_someAction:@&#123;<span class="string">@"key"</span>: value&#125;];</span><br></pre></td></tr></table></figure>

<p>针对上面服务的定义，服务提供方的定义就<em>必须</em>是下面这样：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TargetA.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Target_A</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)someAction:(<span class="built_in">NSDictionary</span> *)params;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TargetA.m</span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)someAction:(<span class="built_in">NSDictionary</span> *)params &#123; ... &#125;</span><br></pre></td></tr></table></figure>


<p>在这整个过程中可以看到，服务的调用方只需要依赖 CTMediator 这个中间件及其分类(定义服务)。服务提供方和调用方没有任何依赖。确实做到了组件解耦。可以肯定的是 target-action 方案确实解决了 url-block 方案的一些问题。但是仔细一看，也是存在一些问题的。</p>
<p>跟 url-block 方案一样，两个不同组件能通信其实仍然是通过一个字符串来定义的。为什么这么说呢，我们可以看一下下面的代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CTMediator+SomeAction.m </span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)xx_someAction:(<span class="built_in">NSDictionary</span> *)params &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> performTarget:<span class="string">@"A"</span> action:<span class="string">@"someAction"</span> params:params shouldCacheTarget:<span class="literal">NO</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TargetA.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Target_A</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="built_in">UIViewController</span> *)someAction:(<span class="built_in">NSDictionary</span> *)params;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，服务能调起主要是调用了 CTMediator 的 </p>
<p><code>- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget;</code> 方法。这里不管是 <code>targetName</code> 还是 <code>action</code> 都是字符串，在实现中 CTMediator 会示例化一个 <code>Target_targetName</code> 类的对象，并且创建一个 <code>Action_actionName</code> 的 selector，所有我们在服务提供的组件中的 Target 以及 Action 是不能随便定义的。Target 必须是以 <code>Target_</code>开头，方法必须以 <code>Action_</code>开头。这种强制要求感觉不是一种工程师的思维。这里想去耦合，却以一种不是很正确的方式造成了隐式的耦合。这也是让我抛弃 CTMediator 转而去开发自己的组件化通信方案的原因之一。</p>
<h4 id="Protocol-Class"><a href="#Protocol-Class" class="headerlink" title="Protocol-Class"></a>Protocol-Class</h4><p>Protocol-Class 方案也是常用的组件化通信方式之一。这里把它放到最后，肯定是因为笔者使用的是这种方案咯(笑)。</p>
<p>Protocol-Class 方案就是通过 protocol 定义服务接口，服务提供方通过实现该接口来提供接口定义的服务。具体实现就是把 protocol 和 class 做一个映射，同时在内存中保存一张映射表，使用的时候，就通过 protocol 找到对应的 class 来获取需要的服务。这种方案的优缺点先不说，可以先看一下具体的实践：</p>
<p><strong>示例图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/moduleliftcycle/protocol-class.jpg" alt="protocol-class使用示例图"></p>
<p><strong>示例代码：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestService.h (定义服务)</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">TestService</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="comment">/// 测试</span></span><br><span class="line">- (<span class="keyword">void</span>)service1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 A (服务提供方)</span></span><br><span class="line">ANT_REGISTER_SERVICE(TestServiceImpl, TestService)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestServiceImpl</span>() &lt;<span class="title">TestService</span>&gt; @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestServiceImpl</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)service1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Service test from Impl"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B (服务使用方)</span></span><br><span class="line"><span class="keyword">id</span> &lt;TestService&gt; obj = [Ant serviceImplFromProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">TestService</span>)];</span></span><br><span class="line">[obj service1];</span><br></pre></td></tr></table></figure>

<p>像上面的方案一样，我们会将服务的定义放到独立的组件中。这个组件仅仅只包含了服务的声明。不管是服务提供方还是服务使用方都依赖这个独立的组件，服务提供方还是服务使用方互不依赖。</p>
<p>这里将系统提供的服务定义为协议，通过耦合提高了代码的健壮性和可维护性。这里定义服务的 protocol 对服务提供方做了一个限定：你可以提供哪些服务，同时也给服务使用方做了限定：你可以使用哪些服务。这种设计将系统有哪些服务都交代的清清楚楚，通过服务的 protocol 我们就知道了每个服务的功能，调用需要的参数，返回值等。这里的定义服务的同时也可以作为系统服务的接口文档，这节省了服务提供方和使用方很多的沟通时间，让其能关注业务的开发。这在大型项目，多团队开发中优势尤为明显。</p>
<p>当然 protocol-class 这种方案缺点也很明显，需要在内存中保存 protocol 到 Class 的映射关系。但是我们可以通过将服务分类，让系统注册的 protocol-class 项尽量少一些，不要一个服务定义一个实现。对于一个有100个服务的系统，定义10个服务实现，每个实现提供10个服务，肯定要比100个服务实现占用的内存少很多。这就要求我们在实践过程中能对系统中的服务能做好划分。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是笔者对组件化的一些思考，很多观点可能也不太成熟，如果有什么不合理的地方，也欢迎各位同学提出建议。组件解耦在 iOS 中其实有多种解决方案，各位同学可以根据项目实际情况选择适合自己的方案。</p>
<blockquote>
<p>上面代码中的 <a href="https://github.com/hujewelz/Ant" target="_blank" rel="noopener">Ant</a> 是笔者最近开发的一个负责组件生命周期管理和通信的开源工具。因为笔者公司从17年开始就一直使用 Swift 进行开发，原来的工具是用 Swift 编写的，使用了很多 Swift 的特性，在 OC 中使用就显得不伦不类了，就针对 OC 进行了重新设计，于是就有了 <a href="https://github.com/hujewelz/Ant" target="_blank" rel="noopener">Ant</a> 。</p>
</blockquote>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>用 Swift 写一个响应式编程库</title>
    <url>/ck9grdo0w0021eyye49ls8ecl/</url>
    <content><![CDATA[<p>2017年又快过去了，忙了一年感觉没啥收获，感觉是不是应该写点啥，想了好久没想出要写什么。下半年因为工作的原因，狗狗也没养了，吉他上也积满了灰尘，</p>
<a id="more"></a>

<p>兴致勃勃的学习素描，到现在也没画出了啥😂，博客也很久没更新了。想想感觉更新一下博客吧。</p>
<p>整个2017年我完全使用 Swift 进行开发了。使用 Swift 进行开发是一个很愉快的体验，我已经完全不想再去碰 OC 了。最近想做一个响应式编程的库，所以就把它拿来分享一下。</p>
<h2 id="Reactive-Programing"><a href="#Reactive-Programing" class="headerlink" title="Reactive Programing"></a>Reactive Programing</h2><p>说到响应式编程，ReactiveCocoa 和 RxSwift 可以说是目前 iOS 开发中最优秀的第三方开源库了。今天咱们不聊 ReactiveCocoa 和 RxSwif，咱们自己来写一个响应式编程库。如果你对观察者模式很熟悉的话，那么响应式编程就很容易理解了。</p>
<blockquote>
<p>响应式编程是一种面向数据流和变化传播的编程范式。</p>
</blockquote>
<p>比如用户输入、单击事件、变量值等都可以看做一个流，你可以观察这个流，并基于这个流做一些操作。“监听”流的行为叫做订阅。响应式就是基于这种想法。</p>
<p> 废话不多说，撸起袖子开干。</p>
<p>我们以一个获取用户信息的网络请求为例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchUser</span><span class="params">(with id: Int, completion: @escaping <span class="params">(<span class="params">(User)</span></span></span></span> -&gt; <span class="type">Void</span>)) &#123;</span><br><span class="line">     <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now()+<span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> user = <span class="type">User</span>(name: <span class="string">"jewelz"</span>)</span><br><span class="line">         completion(user)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是我们通常的做法，在请求方法里传入一个回调函数，在回调里拿到结果。在响应式里面，我们监听请求，当请求完成时，观察者得到更新。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchUser</span><span class="params">(with id: Int)</span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">User</span>&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>发送网络请求就可以这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">fetchUser(with: <span class="string">"12345"</span>).subscribe(&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在完成 Signal 之前， 需要定义订阅后返回的数据结构，这里我只关心成功和失败两种状态的数据，所以可以这样写:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Value</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以开始实现我们的 Signal 了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Signal</span>&lt;<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">typealias</span> <span class="type">Subscriber</span> = (<span class="type">Result</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Void</span></span><br><span class="line">  	<span class="keyword">fileprivate</span> <span class="keyword">var</span> subscribers: [<span class="type">Subscriber</span>] = []</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> result: Result&lt;Value&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> subscriber <span class="keyword">in</span> subscribers &#123;</span><br><span class="line">            subscriber(result)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(<span class="number">_</span> subscriber: @escaping <span class="params">(Result&lt;Value&gt;)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        subscribers.append(subscriber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写个小例子测试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> signal = <span class="type">Signal</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">signal.subscribe &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">signal.send(.success(<span class="number">100</span>))</span><br><span class="line">signal.send(.success(<span class="number">200</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print</span></span><br><span class="line">success(<span class="number">100</span>)</span><br><span class="line">success(<span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<p>我们的 Signal 已经可以正常工作了，不过还有很多改进的空间，我们可以使用一个工厂方法来创建一个 Signal, 同时将 <code>send</code>变为私有的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">()</span></span> -&gt; ((<span class="type">Result</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Void</span>, <span class="type">Signal</span>&lt;<span class="type">Value</span>&gt;) &#123;</span><br><span class="line">     <span class="keyword">let</span> signal = <span class="type">Signal</span>&lt;<span class="type">Value</span>&gt;()</span><br><span class="line">     <span class="keyword">return</span> (signal.send, signal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(<span class="number">_</span> result: Result&lt;Value&gt;)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在我们需要这样使用 Signal 了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> (sink, signal) = <span class="type">Signal</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line">signal.subscribe &#123; result <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">sink(.success(<span class="number">100</span>))</span><br><span class="line">sink(.success(<span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<p>接着我们可以给 UITextField 绑定一个 Signal，只需要在 Extension 中给 UITextField添加一个计算属性  ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UITextField &#123;</span><br><span class="line">    var signal: Signal&lt;String&gt; &#123;</span><br><span class="line">        let (sink, signal) &#x3D; Signal&lt;String&gt;.empty()</span><br><span class="line">        let observer &#x3D; KeyValueObserver&lt;String&gt;(object: self, keyPath: #keyPath(text)) &#123; str in</span><br><span class="line">            sink(.success(str))</span><br><span class="line">        &#125;</span><br><span class="line">        signal.objects.append(observer)</span><br><span class="line">        return signal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的 <code>observer</code> 是一个局部变量，在 <code>signal</code>调用完后，就会被销毁，所以需要在 Signal 中保存该对象，可以给 Signal 添加一个数组，用来保存需要延长生命周期的对象。 KeyValueObserver 是对 KVO 的简单封装，其实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyValueObserver</span>&lt;<span class="title">T</span>&gt;: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> object: <span class="type">NSObject</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> keyPath: <span class="type">String</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> callback: (<span class="type">T</span>) -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(object: <span class="type">NSObject</span>, keyPath: <span class="type">String</span>, callback: @escaping (<span class="type">T</span>) -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.object = object</span><br><span class="line">        <span class="keyword">self</span>.keyPath = keyPath</span><br><span class="line">        <span class="keyword">self</span>.callback = callback</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        object.addObserver(<span class="keyword">self</span>, forKeyPath: keyPath, options: [.new], context: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> keyPath = keyPath, keyPath == <span class="keyword">self</span>.keyPath, <span class="keyword">let</span> value = change?[.newKey] <span class="keyword">as</span>? <span class="type">T</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">      </span><br><span class="line">        callback(value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        object.removeObserver(<span class="keyword">self</span>, forKeyPath: keyPath)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以使用<code>textField.signal.subscribe({})</code> 来观察 UITextField 内容的改变了。</p>
<p> 在 Playground 写个 VC 测试一下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> textField =  <span class="type">UITextField</span>()</span><br><span class="line">    <span class="keyword">var</span> signal: <span class="type">Signal</span>&lt;<span class="type">String</span>&gt;?</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        signal = textField.signal</span><br><span class="line">        signal?.subscribe(&#123; result <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">        &#125;)</span><br><span class="line">        textField.text = <span class="string">"1234567"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Removing vc"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vc: <span class="type">VC?</span> = <span class="type">VC</span>()</span><br><span class="line">vc?.viewDidLoad()</span><br><span class="line">vc = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Print</span></span><br><span class="line">success(<span class="string">"1234567"</span>)</span><br><span class="line"><span class="type">Removing</span> vc</span><br></pre></td></tr></table></figure>



<h2 id="Reference-Cycles"><a href="#Reference-Cycles" class="headerlink" title="Reference Cycles"></a>Reference Cycles</h2><p>我在上面的 Signal 中，添加了 <code>deinit</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Removing Signal"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后发现 Signal 的析构方法并没有执行，也就是说上面的代码中出现了循环引用，其实仔细分析上面 UITextField 的拓展中 <code>signal</code>的实现就能发现问题出在哪儿了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="type">KeyValueObserver</span>&lt;<span class="type">String</span>&gt;(object: <span class="keyword">self</span>, keyPath: #keyPath(text)) &#123; str <span class="keyword">in</span></span><br><span class="line">    sink(.success(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>KeyValueObserver</code> 的回调中，调用了 <code>sink()</code>方法，而 <code>sink</code> 方法其实就是 <code>signal.send(_:)</code>方法，这里在闭包中捕获了<code>signal</code> 变量，于是就形成了循环引用。这里只要使用 <code>weak</code> 就能解决。修改下的代码是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">()</span></span> -&gt; ((<span class="type">Result</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="type">Void</span>, <span class="type">Signal</span>&lt;<span class="type">Value</span>&gt;) &#123;</span><br><span class="line">     <span class="keyword">let</span> signal = <span class="type">Signal</span>&lt;<span class="type">Value</span>&gt;()</span><br><span class="line">     <span class="keyword">return</span> (&#123;[<span class="keyword">weak</span> signal] value <span class="keyword">in</span> signal?.send(value)&#125;, signal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行， Signal 的析构方法就能执行了。</p>
<p>上面就实现了一个简单的响应式编程的库了。不过这里还存在很多问题，比如我们应该在适当的时机移除观察者，现在我们的观察者被添加在 <code>subscribers</code> 数组中，这样就不知道该移除哪一个观察者，所以我们将数字替换成字典，用 UUID   作为 key :</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">typealias</span> <span class="type">Token</span> = <span class="type">UUID</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> subscribers: [<span class="type">Token</span>: <span class="type">Subscriber</span>] = [:]</span><br></pre></td></tr></table></figure>

<p>我们可以模仿 RxSwift 中的 Disposable 用来移除观察者，实现代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> dispose: () -&gt; <span class="type">Void</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(<span class="number">_</span> dispose: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposable</span>(dispose)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> dispose: @escaping () -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dispose = dispose</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        dispose()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来的 <code>subscribe(_:)</code> 返回一个 Disposable 就可以了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(<span class="number">_</span> subscriber: @escaping <span class="params">(Result&lt;Value&gt;)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> token = <span class="type">UUID</span>()</span><br><span class="line">     subscribers[token] = subscriber</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Disposable</span>.create &#123;</span><br><span class="line">          <span class="keyword">self</span>.subscribers[token] = <span class="literal">nil</span></span><br><span class="line">      &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样我们只要在适当的时机销毁 Disposable 就可以移除观察者了。</p>
<p>作为一个响应式编程库都会有 <code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>reduce</code> 等方法，所以我们的库也不能少，我们可以简单的实现几个。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 比较简单，就是将一个 <em>返回值为包装值的函数</em> 作用于一个<strong>包装(Wrapped)值</strong>的过程， 这里的包装值可以理解为可以包含其他值的一种结构，例如 Swift 中的数组，可选类型都是包装值。它们都有重载的 <code>map</code>, <code>flatMap</code>等函数。以数组为例，我们经常这样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> images = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].<span class="built_in">map</span>&#123; <span class="type">UIImage</span>(named: $<span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>现在来实现我们的 map 函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(Value)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Signal</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> (sink, signal) = <span class="type">Signal</span>&lt;<span class="type">T</span>&gt;.empty()</span><br><span class="line">     <span class="keyword">let</span> dispose = subscribe &#123; (result) <span class="keyword">in</span></span><br><span class="line">          sink(result.<span class="built_in">map</span>(transform))</span><br><span class="line">      &#125;</span><br><span class="line">      signal.objects.append(dispose)</span><br><span class="line">      <span class="keyword">return</span> signal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我同时给 Result 也实现了 map 函数:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(Value)</span></span></span> -&gt; <span class="type">T</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">            <span class="keyword">return</span> .success(transform(value))</span><br><span class="line">        <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .error(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (sink, intSignal) = <span class="type">Signal</span>&lt;<span class="type">Int</span>&gt;.empty()</span><br><span class="line">intSignal</span><br><span class="line">    .<span class="built_in">map</span>&#123; <span class="type">String</span>($<span class="number">0</span>)&#125;</span><br><span class="line">    .subscribe &#123;  result <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">sink(.success(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print success("100")</span></span><br></pre></td></tr></table></figure>



<h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h2><p>flatMap 和 map 很相似，但也有一些不同，以可选型为例，Swif t是这样定义 map 和 flatMap 的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U?</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U?</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U?</span></span><br></pre></td></tr></table></figure>

<p> flatMap 和 map 的不同主要体现在 transform 函数的返回值不同。map 接受的函数返回值类型是 <code>U</code>类型，而 flatMap 接受的函数返回值类型是 <code>U?</code>类型。例如对于一个可选值，可以这样调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aString: <span class="type">String?</span> = <span class="string">"￥99.9"</span></span><br><span class="line"><span class="keyword">let</span> price = aString.flatMap&#123; <span class="type">Float</span>($<span class="number">0</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Price is nil</span></span><br></pre></td></tr></table></figure>

<p>我们这里 flatMap 和 Swift 中数组以及可选型中的 flatMap 保持了一致。</p>
<p>所以我们的 flatMap 应该是这样定义：<code>flatMap&lt;T&gt;(_ transform: @escaping (Value) -&gt; Signal&lt;T&gt;) -&gt; Signal&lt;T&gt;</code> 。</p>
<p>理解了 flatMap 和 map 的不同，实现起来也就很简单了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(Value)</span></span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Signal</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> (sink, signal) = <span class="type">Signal</span>&lt;<span class="type">T</span>&gt;.empty()</span><br><span class="line">     <span class="keyword">var</span> _dispose: <span class="type">Disposable?</span></span><br><span class="line">     <span class="keyword">let</span> dispose = subscribe &#123; (result) <span class="keyword">in</span></span><br><span class="line">         <span class="keyword">switch</span> result &#123;</span><br><span class="line">         <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">             <span class="keyword">let</span> new = transform(value)</span><br><span class="line">             _dispose = new.subscribe(&#123; _result <span class="keyword">in</span></span><br><span class="line">                 sink(_result)</span><br><span class="line">             &#125;)</span><br><span class="line">         <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">             sink(.error(error))</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> _dispose != <span class="literal">nil</span> &#123;</span><br><span class="line">        signal.objects.append(_dispose!)</span><br><span class="line">    &#125;</span><br><span class="line">    signal.objects.append(dispose)</span><br><span class="line">    <span class="keyword">return</span> signal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以模拟一个网络请求来测试 flatMap：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">users</span><span class="params">()</span></span> -&gt; <span class="type">Signal</span>&lt;[<span class="type">User</span>]&gt; &#123;</span><br><span class="line">     <span class="keyword">let</span> (sink, signal) = <span class="type">Signal</span>&lt;[<span class="type">User</span>]&gt;.empty()</span><br><span class="line">     <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now()+<span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> users = <span class="type">Array</span>(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">map</span>&#123; <span class="type">User</span>(id: <span class="type">String</span>(describing: $<span class="number">0</span>)) &#125;</span><br><span class="line">         sink(.success(users))</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> signal</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">userDetail</span><span class="params">(with id: String)</span></span> -&gt; <span class="type">Signal</span>&lt;<span class="type">User</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (sink, signal) = <span class="type">Signal</span>&lt;<span class="type">User</span>&gt;.empty()</span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now()+<span class="number">2</span>) &#123;</span><br><span class="line">        sink(.success(<span class="type">User</span>(id: id, name: <span class="string">"jewelz"</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dispose = users()</span><br><span class="line">    .flatMap &#123; <span class="keyword">return</span> <span class="keyword">self</span>.userDetail(with: $<span class="number">0</span>.first!.id) &#125;</span><br><span class="line">    .subscribe &#123; result <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">&#125;</span><br><span class="line">disposes.append(dispose)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print: success(ReactivePrograming.User(name: Optional("jewelz"), id: "1"))</span></span><br></pre></td></tr></table></figure>

<p>通过使用 flatMap ，我们可以很简单的将一个 Signal 转换为另一个 Signal , 这在我们处理多个请求嵌套时就会很方便了。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>上面通过100 多行的代码就实现了一个简单的响应式编程库。不过对于一个库来说，以上的内容还远远不够。现在的 Signal 还不具有原子性，要作为一个实际可用的库，应该是线程安的。还有我们对 Disposable 的处理也不够优雅，可以模仿 RxSwift 中 DisposeBag 的做法。上面这些问题可以留给读者自己去思考了。（更多内容可以查看<a href="http://jewelz.me" target="_blank" rel="noopener">我的主页</a>）</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>Reactive programing</tag>
      </tags>
  </entry>
  <entry>
    <title>被误解的MVC</title>
    <url>/ck9grdo0y0025eyye2om86uj7/</url>
    <content><![CDATA[<p><strong>MVC</strong>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面…</p>
<a id="more"></a>

<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote>
<p><strong>MVC</strong>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
</blockquote>
<!--more-->
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><blockquote>
<p>通常意义上的三层架构就是将整个业务应用划分为：界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）。区分层次的目的即为了“<a href="http://baike.baidu.com/view/3082578.htm" target="_blank" rel="noopener">高内聚低耦合</a>”的思想。在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。微软推荐的分层式结构一般分为三层，从下至上分别为：数据访问层、业务逻辑层（又或称为领域层）、表示层。</p>
</blockquote>
<h2 id="总是被误解"><a href="#总是被误解" class="headerlink" title="总是被误解"></a>总是被误解</h2><p>起初老师总说三层MVC，MVC三层架构……<br>MVC是三个字母，三层架构也是“三”，所有我们就很自然的将MVC里的三个核心部件与三层架构等同起来：三层就是MVC，MVC就是三层架构。很多人认为<code>界面层</code>等于<code>View</code>,<code>业务逻辑层</code>等于<code>Controller</code>,<code>数据访问层</code>等于<code>Model</code>，其实这是完全错误的。<br>MVC主要用于三层架构的表现层，是一种复合设计模式，主要是为了解决应用程序用户界面与业务逻辑数据的耦合问题。而三层架构是从整个应用程序架构的角度来划分的。虽然表现不一样，但它们的目的都是一样：分层，解耦。</p>
<p><strong>MVC</strong>里的<code>Controller</code>是负责对页面进行控制的，比如：页面间跳转，显示逻辑等。三层架构里的<code>业务逻辑层</code>主要是对<code>业务实体数据</code>的加工，把加工后的数据传给页面显示。 MVC里的<code>Model</code>只是数据实体，是数据的容器，不具备什么增删改查的功能，它接收的数据是从<code>业务逻辑层</code>处理好传过来的数据。而三层架构里的<code>数据访问层</code>是具有增删改查功能的，是直接对数据库操作的，为业务逻辑层提供数据支持。<br>如果非要让它们有所对应的话，那么三层架构中的界面层就相当于MVC中的V(View)和C(Controller)了，业务逻辑层和数据访问层就对应MVC中的M(Model)。其实从本质上来讲，它们还是不同纬度上的东西。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>由一道Swift面试题引发的对方法调度的思考</title>
    <url>/ck9grdo0z0028eyyee4by4a1x/</url>
    <content><![CDATA[<p>最近在看swift面试题时，其中有一道题目让我很诧异。题目是这样的：</p>
<p>以下代码会打印出什么？</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Pizzeria</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makePizza</span><span class="params">(<span class="number">_</span> ingredients: [String])</span></span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeMargherita</span><span class="params">()</span></span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Pizzeria</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeMargherita</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> makePizza([<span class="string">"tomato"</span>, <span class="string">"mozzarella"</span>]) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lombardis</span>: <span class="title">Pizzeria</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makePizza</span><span class="params">(<span class="number">_</span> ingredients: [String])</span></span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(ingredients)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeMargherita</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> makePizza([<span class="string">"tomato"</span>, <span class="string">"basil"</span>, <span class="string">"mozzarella"</span>]) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lombardis1: <span class="type">Pizzeria</span> = <span class="type">Lombardis</span>()</span><br><span class="line"><span class="keyword">let</span> lombardis2: <span class="type">Lombardis</span> = <span class="type">Lombardis</span>() </span><br><span class="line">lombardis1.makeMargherita()</span><br><span class="line">lombardis2.makeMargherita()</span><br></pre></td></tr></table></figure>
<p>当然，即使是swift新手也会毫不犹豫的给出答案：</p>
<p>打印两行<code>[&quot;tomato&quot;, &quot;basil&quot;, &quot;mozzarella&quot;]</code></p>
<p>然后面试官笑了笑，将<code>Pizzeria</code>中声明的<code>makeMargherita()</code>去掉，代码变为：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Pizzeria</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makePizza</span><span class="params">(<span class="number">_</span> ingredients: [String])</span></span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Pizzeria</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeMargherita</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">return</span> makePizza([<span class="string">"tomato"</span>, <span class="string">"mozzarella"</span>]) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Lombardis</span>: <span class="title">Pizzeria</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makePizza</span><span class="params">(<span class="number">_</span> ingredients: [String])</span></span> &#123; </span><br><span class="line">    <span class="built_in">print</span>(ingredients)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeMargherita</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> makePizza([<span class="string">"tomato"</span>, <span class="string">"basil"</span>, <span class="string">"mozzarella"</span>]) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lombardis1: <span class="type">Pizzeria</span> = <span class="type">Lombardis</span>()</span><br><span class="line"><span class="keyword">let</span> lombardis2: <span class="type">Lombardis</span> = <span class="type">Lombardis</span>() </span><br><span class="line">lombardis1.makeMargherita()</span><br><span class="line">lombardis2.makeMargherita()</span><br></pre></td></tr></table></figure>
<p>估计有很多童鞋会跟我一样，不假思索地给出答案：打印两行<code>[&quot;tomato&quot;, &quot;basil&quot;, &quot;mozzarella&quot;]</code>。如果答案还是一样，面试官就没有删除那行代码的必要了吧。正确答案应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;tomato&quot;, &quot;mozzarella&quot;]</span><br><span class="line">[&quot;tomato&quot;, &quot;basil&quot;, &quot;mozzarella&quot;]</span><br></pre></td></tr></table></figure>
<p>聪明的童鞋即使不知道正确答案，知道此处有陷阱，也会给出了正确答案。那么导致这种结果的真正原因是什么呢？答案就是<strong>方法调度(Method Dispatch)</strong></p>
<h2 id="什么是方法调度"><a href="#什么是方法调度" class="headerlink" title="什么是方法调度"></a>什么是方法调度</h2><p>方法调度就是一个程序在调用一个方法时如何选择要执行的指令的过程。当我们每次调用一个方法时方法调度都会发生。</p>
<p>编译型语言有三种基础的方法调度方式: 直接调度(Direct Dispatch), 函数表调度(Table Dispatch) 和 消息调度(Message Dispatch)。大部分语言支持一到两种。Java默认使用函数表调度，你可以通过使用 <code>final</code> 关键字将其变为直接调度。C++默认使用直接调度，通过 <code>virtual</code> 关键字可以改为函数表调度。Objective-C总是使用消息调度。但允许开发者使用C直接派发来获取性能的提高。Swift在这方面走在了前面，她支持全部的3种调度方式。这样的方式非常好,，不过也给很多Swift开发者带来了困扰。</p>
<h2 id="调度类型（Types-of-Dispatch）"><a href="#调度类型（Types-of-Dispatch）" class="headerlink" title="调度类型（Types of Dispatch）"></a>调度类型（Types of Dispatch）</h2><p>调度的目的是程序告诉CPU被调用的函数在哪里，在我们深入Swift的这种行为之前，有必要了解一下方法调度的三种方式。</p>
<p><strong>直接调度(Direct Dispatch)</strong></p>
<p>直接调度是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等, 但这不在这篇博客的讨论范围。</p>
<p>然而, 对于编程来说直接调用也是最大的局限, 而且因为缺乏动态性所以没办法支持继承。</p>
<p><strong>函数表调度 (Table Dispatch )</strong></p>
<p>函数表调度是编译型语言实现动态行为最常见的实现方式. 函数表使用了一个数组来存储类声明的每一个函数的指针. 大部分语言把这个称为 “virtual table”(虚函数表), Swift 里称为 “witness table”. 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被 <code>override</code> 的话, 表里面只会保存被 <code>override</code> 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数.</p>
<p>看看下面的例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>: <span class="title">ParentClasss</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method3</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个情况下, 编译器会创建两个函数表, 一个是 <code>ParentClass</code> 的, 另一个是 <code>ChildClass</code> 的:</p>
<p><img src="https://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/virtual-dispatch-768x227.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="type">ChildClass</span>()</span><br><span class="line">obj.method2()</span><br></pre></td></tr></table></figure>
<p>当一个方法被调用时，会经历下面几个过程：</p>
<ol>
<li>读取 <code>0xB00</code> 对象的调度表</li>
<li>通过索引读取该方法的函数指针，在这里, <code>method2</code> 的索引是1(偏移量), 所以地址就是 <code>0xB00 + 1</code></li>
<li>跳到 <code>0x222</code> (函数指针指向 0x222)</li>
</ol>
<p>查表是一种简单, 易实现, 而且性能可预知的方式. 然而, 这种派发方式比起直接派发还是慢一点。从字节码角度来看, 多了两次读和一次跳转, 由此带来了性能的损耗。另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化。</p>
<p>这种基于数组的实现, 缺陷在于函数表无法拓展。子类会在虚数函数表的最后插入新的方法, 没有位置可以让 extension 安全地插入函数。</p>
<p><strong>消息调度 (Message Dispatch )</strong></p>
<p>消息调度是调用函数最动态的方式。也是 Cocoa 的基石, 这样的机制催生了 <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html" target="_blank" rel="noopener">KVO</a>, <a href="https://developer.apple.com/reference/uikit/uiappearance" target="_blank" rel="noopener">UIAppearence</a> 和 <a href="https://developer.apple.com/library/content///documentation/Cocoa/Conceptual/CoreData/index.html" target="_blank" rel="noopener">CoreData</a> 等功能. 这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过 <a href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html" target="_blank" rel="noopener">swizzling</a> 来改变, 甚至可以用 <a href="http://stackoverflow.com/questions/38877465/are-method-swizzling-and-isa-swizzling-the-same-thing/38878119#38878119" target="_blank" rel="noopener">isa-swizzling</a> 修改对象的继承关系, 可以在面向对象的基础上实现自定义调度。</p>
<p>看下面两个类:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>: <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">method3</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 会用树来构建这种继承关系:</p>
<p><img src="https://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/message-dispatch-768x412.png" alt=""></p>
<p>当一个消息被发送时, 运行时会顺着类的继承关系向上查找应该被调用的方法. 如果你觉得这样做效率很低, 它确实很低! 然而, 只要缓存建立了起来, 这个查找过程就会通过缓存来把性能提高到和函数表一样快. 但这只是消息机制的原理, <a href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/" target="_blank" rel="noopener">这里有一篇文章</a>很深入的讲解了具体的技术细节.</p>
<h2 id="Swift-的调度机制"><a href="#Swift-的调度机制" class="headerlink" title="Swift 的调度机制"></a>Swift 的调度机制</h2><p>那么，swift是如何调度的呢？这里有四个方面,来指导如何选择调度:</p>
<ul>
<li>方法声明的位置</li>
<li>引用类型</li>
<li>特定的行为</li>
<li>显式地优化</li>
</ul>
<p>要说明的是Swift 并没有在文档里具体写明什么时候会使用函数表什么时候使用消息机制. 唯一的承诺是使用 <code>dynamic</code> 修饰的时候会通过 Objective-C 的运行时使用消息机制。</p>
<p><strong>声明的位置 (Location Matters)</strong></p>
<p>在Swift中有两个地方可以声明一个方法：类型声明的作用域内和 <code>extension</code>。根据声明类型的不同, 也会有不同的派发方式:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mainMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里, <code>mainMethod</code> 会使用函数表的方式, 而 <code>extensionMethod</code> 则会使用直接调度。根据声明的位置，可以总结如下：</p>
<p><img src="https://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/Defaults-1-768x503.png" alt=""></p>
<p>总结起来有这么几点:</p>
<ul>
<li>值类型总是会使用直接派发, 简单易懂</li>
<li>而协议和类的 <code>extension</code> 都会使用直接调度</li>
<li>协议和普通Swift类声明作用域里的方法都会使用函数表进行调度</li>
<li>继承 <code>NSObject</code> 的类声明作用域里的方法都会使用函数表调度</li>
<li>继承 <code>NSObject</code> 的类的 <code>extension</code> 会使用消息调度</li>
</ul>
<p><strong>引用类型 (Reference Type Matters)</strong></p>
<p>引用的类型决定了调度的方式, 这是显而易见的, 但有一个重要的区别。 一个比较常见的疑惑, 发生在一个协议拓展和类型拓展同时实现了同一个函数的时候。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"In Protocol extension method"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> 🐱: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> 🐱 </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"喵喵"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = 🐱()</span><br><span class="line"><span class="keyword">let</span> proto: <span class="type">Animal</span> = cat</span><br><span class="line"></span><br><span class="line">cat.extensionMethod()</span><br><span class="line">proto.extensionMethod()</span><br></pre></td></tr></table></figure>
<p>刚接触 Swift 的童鞋可能会认为 <code>proto.extensionMethod()</code>调用的是结构体里的实现。 但是, 引用的类型决定了调度的方式, 协议拓展里的方法会使用直接调度。如果把 <code>extensionMethod</code> 的声明移动到协议的声明位置的话, 则会使用函数表调度, 最终就会调用结构体里的实现。 并且要记得, 如果两种声明方式都使用了直接调度的话, 基于直接调度的运作方式, 我们不可能实现预想的 <code>override</code> 行为。</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式—开篇</title>
    <url>/ck9grdo10002ceyye41s226ys/</url>
    <content><![CDATA[<p>根据《设计模式》一书，设计模式是对定制来解决特定场景下一般设计问题的类和互相通讯对象的描述。</p>
<a id="more"></a>

<p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software</strong>  的书，在书中首次提到了软件开发中设计模式的概念。</p>
<p>设计模式主要基于以下的面向对象设计原则：</p>
<ul>
<li>针对接口编程，而不是针对实现编程</li>
<li>优先使用对象组合，而不是继承</li>
</ul>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p>根据设计模式的参考书 <strong>Design Patterns - Elements of Reusable Object-Oriented Software</strong> 中所提到的，总共有 23 种设计模式。这些模式可以分为以下三类：</p>
<p><strong>创建型</strong>：工厂方法，抽象工厂，单例模式，建造者模式，原型模式；</p>
<p><strong>结构型</strong>：适配器模式，装饰器模式，代理模式，外观模式，桥接模式，组合模式，享元模式；</p>
<p><strong>行为型</strong>：策略模式，模板方法，观察者模式，迭代器模式，责任链模式，命令模式，备忘录模式，状态模式，访问者模式，中介者模式，解释器模式；</p>
<h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><p><strong>单一职责原则(SRP)</strong></p>
<blockquote>
<p>就一个类而言，应该仅有一个引起它变化的原因。</p>
</blockquote>
<p>从这句定义我们很难理解它的含义，通俗讲就是我们不要让一个类承担过多的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到破坏。 </p>
<p><strong>开发封闭原则(ASD)</strong></p>
<blockquote>
<p>软件实体（类、模块、函数等等）应该是可以拓展的，但是不可修改。</p>
</blockquote>
<p>开放封闭有两个含义，一个是对于拓展是开放的，另一个是对于修改是封闭的。对于开发来说需求肯定是要变化的，但是新需求一来，我们就要把类重新改一遍这显然是令人头疼的，所以我们设计程序时面对需求的改变要尽可能的保证相对的稳定，尽量用新代码实现拓展来修改需求，而不是通过修改原有的代码来实现。 </p>
<p><strong>里氏替换原则(LSP)</strong></p>
<blockquote>
<p>所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
</blockquote>
<p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。<br>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p>
<p>在使用里氏代换原则时需要注意如下几个问题：</p>
<ul>
<li>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</li>
<li>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</li>
</ul>
<p><strong>依赖倒置原则(DIP)</strong></p>
<blockquote>
<p>高层模块不应该依赖低层模块，两个都应该依赖于抽象。<br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p><strong>迪米特原则(LOD)</strong></p>
<blockquote>
<p>一个软件实体应当尽可能少地与其他实体发生相互作用。 </p>
</blockquote>
<p>也称为最少知识原则。如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。<br>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。 </p>
<p><strong>接口隔离原则(ISP)</strong></p>
<blockquote>
<p>一个类对另一个类的依赖应该建立在最小的接口上。</p>
</blockquote>
<p>建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>说说iOS多线程</title>
    <url>/ck9grdo12002geyye90fjf2ui/</url>
    <content><![CDATA[<p>线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.</p>
<!--excerpt-->



<p>在说多线程之前我们必须先弄懂两个概念：<code>进程</code> 和 <code>线程</code></p>
<h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><blockquote>
<p>进程(Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</p>
</blockquote>
<p>简单来说，进程是指在系统中正在运行的一个应用程序，每一个程序都是一个进程，并且进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><blockquote>
<p>线程是程序执行流的最小单元线程是程序中一个单一的顺序控制流程。是进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。</p>
</blockquote>
<p>1个进程要想执行任务必须得有线程。线程中任务的执行是串行的，一个线程中的任务只能一个一个地按顺序执行，也就是说在同一时间内，1个线程只能执行1个任务。</p>
<p>线程和进程的区别在于,子进程和父进程有不同的代码和数据空间,而多个线程则共享数据空间,每个线程有自己的执行堆栈和程序计数器为其执行上下文.多线程主要是为了节约CPU时间,发挥利用,根据具体情况而定. 线程的运行中需要使用计算机的内存资源和CPU。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><blockquote>
<p>多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。</p>
</blockquote>
<p>所谓多线程，就是在单个程序中同时运行多个线程完成不同的工作<br>注意，多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>在说GCD之前我们得先弄懂4个比较容易混淆的术语：<code>同步</code>、<code>异步</code>、 <code>并发</code>、 <code>串行</code><br>同步和异步主要影响：能不能开启新的线程</p>
<ul>
<li><code>同步</code>：只是在当前线程中执行任务，不具备开启新线程的能力</li>
<li><code>异步</code>：可以在新的线程中执行任务，具备开启新线程的能力<br>并行和串行主要影响：任务的执行方式</li>
<li><code>并发</code>：多个任务并发（同时）执行</li>
<li><code>串行</code>：一个任务执行完毕后，再执行下一个任务</li>
</ul>
<p>GCD是最常用的管理并行代码和执行异步操作的Unix系统层的API。GCD构造和管理队列中的任务。首先，让我们看看队列是什么。</p>
<h4 id="队列是什么？"><a href="#队列是什么？" class="headerlink" title="队列是什么？"></a>队列是什么？</h4><p>队列是按 <code>先进先出(FIFO)</code> 管理对象的数据结构。队列类似电影院的售票窗口，票的销售是谁先到谁先服务。在等待线前面的人先去买他们的门票，在其余的后抵达的人之前。</p>
<h4 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h4><p>调度队列是一种简单的同步和异步任务的方法。任务以 <code>block</code> 的形式被提交到其中。系统有两种调度队列: <code>串行队列</code> 和 <code>并行队列</code> 。任务分配给这两个队列都是在单独的线程执行的，而不是在创建任务的线程上。换句话说，你创建任务(block)再提交到主线程的调度队列，但所有这些任务任务将运行在单独的线程而不是主线程。</p>
<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p>当你创建一个串行队列，队列一次只能执行一个任务。同一队列中的任务将按着顺序依次执行，然而它们并不关心任务是不是在单独的线程，所以你可以通过使用多个串行队列来并行地执行任务。例如，你可以创建两个串行队列，每个队列一次只执行一个任务，不过多达两个任务仍可并行执行。<br>使用串行队列的优点：</p>
<ol>
<li>保证序列化访问共享资源，避免竞争条件。</li>
<li>任务的执行顺序是可预测的。当你提交任务到一个串行调度队列，它们将按插入的顺序执行。</li>
<li>你可以创建任意数量的串行队列。</li>
</ol>
<h4 id="并行队列"><a href="#并行队列" class="headerlink" title="并行队列"></a>并行队列</h4><p>并行队列可以并行执行多个任务。任务按添加到队列的顺序开始，但它们的执行会同时发生，不会相互等待。并行队列保证任务开始的顺序，但你不知道执行的顺序。</p>
<h4 id="使用队列"><a href="#使用队列" class="headerlink" title="使用队列"></a>使用队列</h4><p>默认情况下，系统为每个应用提供了一个串行队列和四个并行队列。主调度队列是全局可用的串行队列，它在应用的主线程执行任务，主要用来更新UI,同时只有一个任务执行。<br>除了主队列，系统提供了4个并行队列，称之为全局调度队列。这些队列对于应用是全局的，区别只在于它们的优先级。使用<code>dispatch_get_global_queue</code>可以获取到一个全局队列，它有以下四个优先级：</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code></li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code></li>
</ul>
<p>以上优先级由高到低，所有你可以根据任务的优先级决定你使用的队列。不过，你也可以创建任意数量的串行或并行队列。</p>
<h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>即操作，你想要干什么，说白了就是一段代码，在 GCD 中就是一个 <code>Block</code>，所以添加任务十分方便。任务有两种执行方式： <code>同步执行</code> 和 <code>异步执行</code>，他们之间的区别是在于会不会阻塞当前线程，直到 <code>Block</code> 中的任务执行完毕！</p>
<p>下面举几个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func GCD1() &#123;</span><br><span class="line">    print(&quot;task 1&quot;);</span><br><span class="line">    dispatch_sync(dispatch_get_main_queue()) &#123; &#x2F;&#x2F;会阻塞当前线程，task 2不会执行</span><br><span class="line">       print(&quot;task 2&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行会发现控制台打印出<code>task 1</code>，因为主线程被阻塞了，task2不会执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func GCD2() &#123;</span><br><span class="line">    print(&quot;task 1&quot;);</span><br><span class="line">    </span><br><span class="line">    let queue &#x3D; dispatch_queue_create(&quot;come.jewelez.serial&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        print(&quot;task 2 \(NSThread.currentThread())&quot;)</span><br><span class="line">        dispatch_sync(queue, &#123; () -&gt; Void in  &#x2F;&#x2F;会阻塞当前线程，task 3不会执行</span><br><span class="line">            print(&quot;task 3 \(NSThread.currentThread())&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        print(&quot;task 4 \(NSThread.currentThread())&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;task 5&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，你会发现控制台只会打印<code>task1, task5, task2</code>, 而<code>task3</code>和<code>task4</code>不会执行。首先我们创建了一个串行队列，然后以异步的方式提交了任务，所以<code>task2</code>可以执行，在任务中又以同步的方式向队列中提交了一个新的任务，由于是同步方式所以会阻塞当前线程，<code>task3</code>不会执行，因为是串行队列，当前线程又线程阻塞了，所以<code>task4</code>也不会执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func GCD3() &#123;</span><br><span class="line">    print(&quot;task 1&quot;)</span><br><span class="line">    </span><br><span class="line">    let queue &#x3D; dispatch_queue_create(&quot;come.jewelez.serial&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        print(&quot;task 2 \(NSThread.currentThread())&quot;)</span><br><span class="line">        </span><br><span class="line">        dispatch_sync(dispatch_get_main_queue(), &#123; () -&gt; Void in  &#x2F;&#x2F;异步遇到同步回主线程, task 3执行完后才会执行task 4</span><br><span class="line">            print(&quot;task 3 \(NSThread.currentThread())&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">         print(&quot;task 4 \(NSThread.currentThread())&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    print(&quot;task 5 \(NSThread.currentThread())&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个就很容易理解了，不过要注意的一点是异步遇到同步回主线程, <code>task 3</code>执行完后才会执行<code>task 4</code>，控制台打印如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">task 1</span><br><span class="line">task 2 &lt;NSThread: 0x7fe290e05d30&gt;&#123;number &#x3D; 2, name &#x3D; (null)&#125;</span><br><span class="line">task 5 &lt;NSThread: 0x7fe290c045b0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">task 3 &lt;NSThread: 0x7fe290c045b0&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">task 4 &lt;NSThread: 0x7fe290e05d30&gt;&#123;number &#x3D; 2, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure>
<p>来看最后一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func GCD4() &#123;</span><br><span class="line">    print(&quot;task 1&quot;)</span><br><span class="line">    </span><br><span class="line">    let queue &#x3D; dispatch_queue_create(&quot;come.jewelez.serial&quot;, DISPATCH_QUEUE_SERIAL)</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        print(&quot;task 2 \(NSThread.currentThread())&quot;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123; () -&gt; Void in</span><br><span class="line">           </span><br><span class="line">            for i in 0..&lt;1000 &#123;</span><br><span class="line">                print(&quot;i: \(i)&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            print(&quot;task 3 \(NSThread.currentThread())&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        print(&quot;task 4 \(NSThread.currentThread())&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;task 5 \(NSThread.currentThread())&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子与上个不同在于，主线程中的任务也是以异步的方式执行的，所以<code>task 4</code>不用等到<code>task 3</code>执行完才执行。</p>
<h4 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h4><p>dispatch_group是用于监视一任务（Block）的机制。例如，当我们向一个队列里添加了多个任务，当队列中的所有任务执行完成后，我们需要做某种操作，这个时候就可以使用<code>dispatch_group</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue &#x3D; dispatch_queue_create(&quot;com.hujewelz.test&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_group_t group &#x3D; dispatch_group_create();</span><br><span class="line">  </span><br><span class="line">__block NSString *result1 &#x3D; nil, *result2 &#x3D; nil;</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务1&quot;);</span><br><span class="line">    result1 &#x3D; @&quot;result 1&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;任务2&quot;);</span><br><span class="line">    result2 &#x3D; @&quot;result 2&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">    NSLog(@&quot;notify--result: %@-%@&quot;, result1, result2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-07-17 17:27:32.536 多线程[16626:593137] 任务1</span><br><span class="line">2016-07-17 17:27:32.536 多线程[16626:593139] 任务2</span><br><span class="line">2016-07-17 17:27:32.537 多线程[16626:593139] notify--result: result 1-result 2</span><br></pre></td></tr></table></figure>

<h3 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h3><p>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。在两种类型中，这些队列所处理的任务都使用 NSOperation 的子类来表述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSOperationQueue *mainQueue &#x3D; [NSOperationQueue mainQueue];  &#x2F;&#x2F;主队列</span><br><span class="line">NSOperationQueue *queue &#x3D; [[NSOperationQueue alloc] init]; &#x2F;&#x2F;自定义队列</span><br><span class="line">NSBlockOperation *operation &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">                &#x2F;&#x2F;任务执行</span><br><span class="line">            &#125;];</span><br><span class="line">[queue addOperation:operation];</span><br></pre></td></tr></table></figure>
<p>我们可以通过设置 maxConcurrentOperationCount 属性来控制并发任务的数量，当设置为 1 时， 那么它就是一个串行队列。主对列默认是串行队列，这一点和 dispatch_queue_t 是相似的。</p>
<h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>你可以使用系统提供的一些现成的 NSOperation 的子类， 如 <code>NSBlockOperation</code>、 <code>NSInvocationOperation</code>。</p>
<h4 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h4><p>NSOperation的子类NSInvocationOperation为我们提供了一套简单的多线程编程方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSInvocationOperation *invo &#x3D; [[NSInvocationOperation alloc]initWithTarget:self</span><br><span class="line">                                                                   selector:@selector(handleInvocation)</span><br><span class="line">                                                                     object:nil];</span><br><span class="line">[invo start];</span><br></pre></td></tr></table></figure>
<p>调用 <code>start</code>方法，就会马上执行封装好的操作，也就是会调用<code>self</code>的<code>handleInvocation</code>方法.</p>
<blockquote>
<p>注意：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。</p>
</blockquote>
<h4 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h4><h5 id="1-同步执行一个操作"><a href="#1-同步执行一个操作" class="headerlink" title="1. 同步执行一个操作"></a>1. 同步执行一个操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSBlockOperation *blckOp &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;执行一个新操作: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[blckOp start];</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行一个新操作: &lt;NSThread: 0x60800007a940&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，初始化一个NSBlockOperation对象后，调用<code>start</code>方法，<br>发现还是在当前线程同步执行操作，并没有异步执行。</p>
<h5 id="2-并发执行多个操作"><a href="#2-并发执行多个操作" class="headerlink" title="2. 并发执行多个操作"></a>2. 并发执行多个操作</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSBlockOperation *blckOp &#x3D; [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;执行一个新操作: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blckOp addExecutionBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;又执行一个新操作 1: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[blckOp addExecutionBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;又执行一个新操作 2: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">  </span><br><span class="line">[blckOp addExecutionBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;又执行一个新操作 3: %@&quot;, [NSThread currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[blckOp start];</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">又执行一个新操作 1: &lt;NSThread: 0x608000079280&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;</span><br><span class="line">执行一个新操作: &lt;NSThread: 0x60000007c540&gt;&#123;number &#x3D; 1, name &#x3D; main&#125;</span><br><span class="line">又执行一个新操作 2: &lt;NSThread: 0x60800007eac0&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;</span><br><span class="line">又执行一个新操作 3: &lt;NSThread: 0x60800007ecc0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;</span><br></pre></td></tr></table></figure>
<p>从结果可以看出，当我们通过 <code>addExecutionBlock:</code> 方法添加了新的操作后，就会并发地执行这些操作，也就是会在不同线程中执行。</p>
<blockquote>
<p>结论：只要NSBlockOperation封装的操作数 &gt; 1，就会异步执行操作。</p>
</blockquote>
<h4 id="创建自己的Operation"><a href="#创建自己的Operation" class="headerlink" title="创建自己的Operation"></a>创建自己的Operation</h4><p>你也可以实现自己的子类， 通过重写 <code>main</code> 或者 <code>start</code> 方法 来定义自己的 operation 。<br>使用 <code>main</code> 方法非常简单，开发者不需要管理一些状态属性（例如 <code>isExecuting</code> 和 <code>isFinished</code>），当 <code>main</code> 方法返回的时候，这个 operation 就结束了。这种方式使用起来非常简单，但是灵活性相对重写 <code>start</code> 来说要少一些， 因为<code>main</code>方法执行完就认为operation结束了，所以一般可以用来执行同步任务。<br>如果你希望拥有更多的控制权，或者想在一个操作中可以执行异步任务，那么就重写 <code>start</code> 方法, 但是注意：这种情况下，你必须手动管理操作的状态， 只有当发送 <code>isFinished</code> 的 KVO 消息时，才认为是 operation 结束.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation YourOperation</span><br><span class="line">- (void)start</span><br><span class="line">&#123;</span><br><span class="line">  self.isExecuting &#x3D; YES;</span><br><span class="line">    &#x2F;&#x2F; 任务代码 ...</span><br><span class="line">&#125;</span><br><span class="line">- (void)finish &#x2F;&#x2F;异步回调</span><br><span class="line">&#123;</span><br><span class="line">  self.isExecuting &#x3D; NO;</span><br><span class="line">  self.isFinished &#x3D; YES;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当实现了 <code>start</code> 方法时，默认会执行 <code>start</code> 方法，而不执行 <code>main</code> 方法<br>为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 <code>setter</code> 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。<br>需要手动管理的状态有：</p>
<ul>
<li><code>isExecuting</code> 代表任务正在执行中</li>
<li><code>isFinished</code> 代表任务已经执行完成</li>
<li><code>isCancelled</code> 代表任务已经取消执行</li>
</ul>
<p>手动的发送 KVO 消息， 通知状态更改如下 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self willChangeValueForKey:@&quot;isCancelled&quot;];</span><br><span class="line">_isCancelled &#x3D; YES;</span><br><span class="line">[self didChangeValueForKey:@&quot;isCancelled&quot;];</span><br></pre></td></tr></table></figure>
<p>为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 <code>isCancelled</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)main &#123;</span><br><span class="line">    &#x2F;&#x2F; 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果已经取消，释放资源，并返回</span><br><span class="line">        if (self.isCancelled) &#123;</span><br><span class="line">            [self reset];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        NSURLSessionConfiguration *configuration &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">        self.session &#x3D; [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">        </span><br><span class="line">        NSURLRequest *repuest &#x3D; [NSURLRequest requestWithURL:_url];</span><br><span class="line">        __weak __typeof(self) wself &#x3D; self;</span><br><span class="line">        NSURLSessionDataTask *task &#x3D; [_session dataTaskWithRequest:repuest completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;</span><br><span class="line">            __strong __typeof(self) sself &#x3D; wself;</span><br><span class="line">            if (!sself.completedBlock) &#123;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            if (data &#x3D;&#x3D; nil) &#123;</span><br><span class="line">                sself.completedBlock(nil, nil, error);</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果已经取消，释放资源，并返回</span><br><span class="line">            if (sself.isCancelled) &#123;</span><br><span class="line">                [sself reset];</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            UIImage *image &#x3D; [UIImage hu_imageFromData:data];</span><br><span class="line">            [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                sself.completedBlock(image, data, nil);</span><br><span class="line">            &#125;];   </span><br><span class="line">        &#125;];</span><br><span class="line">        [task resume];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>
