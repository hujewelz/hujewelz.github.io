<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hujewelz.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="iOS 应用程序启动过程可以以 main 函数为界，这里我们先不用管 main() 函数调用后的过程，主要来分析一下 mian() 函数调用之前的dyld阶段。 我们可以先写个简单的程序来看看系统在调用 main() 之前，调用了哪些函数。">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS 应用启动流程分析-Dyld">
<meta property="og:url" content="https://hujewelz.github.io/cko3zg8mw000n5ss64pg14tr7/index.html">
<meta property="og:site_name" content="Jewelz&#96;s Home Page">
<meta property="og:description" content="iOS 应用程序启动过程可以以 main 函数为界，这里我们先不用管 main() 函数调用后的过程，主要来分析一下 mian() 函数调用之前的dyld阶段。 我们可以先写个简单的程序来看看系统在调用 main() 之前，调用了哪些函数。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/01.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/02.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/03.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/04.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/05.png">
<meta property="article:published_time" content="2017-10-11T02:04:03.000Z">
<meta property="article:modified_time" content="2020-04-30T03:47:55.989Z">
<meta property="article:author" content="Jewelz Hu">
<meta property="article:tag" content="原理 dyld">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/01.png">

<link rel="canonical" href="https://hujewelz.github.io/cko3zg8mw000n5ss64pg14tr7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>iOS 应用启动流程分析-Dyld | Jewelz`s Home Page</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jewelz`s Home Page</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">iOS工程师一枚，热爱前端技术</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hujewelz.github.io/cko3zg8mw000n5ss64pg14tr7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Jewelz Hu">
      <meta itemprop="description" content="Stay hungry, Stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jewelz`s Home Page">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS 应用启动流程分析-Dyld
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-11 10:04:03" itemprop="dateCreated datePublished" datetime="2017-10-11T10:04:03+08:00">2017-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 11:47:55" itemprop="dateModified" datetime="2020-04-30T11:47:55+08:00">2020-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>iOS 应用程序启动过程可以以 <code>main</code> 函数为界，这里我们先不用管 <code>main() </code>函数调用后的过程，主要来分析一下 <code>mian()</code> 函数调用之前的dyld阶段。</p>
<p>我们可以先写个简单的程序来看看系统在调用 <code>main()</code> 之前，调用了哪些函数。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/01.png"></p>
<p>这里给 <code>load</code> 方法添加了一个断点。从调用栈可以看到最先调用的是 <code>__dyld_start</code> 函数。我们可以从 <a target="_blank" rel="noopener" href="https://github.com/opensource-apple/dyld">dyld 源码</a> dyldStartup.s 中找到 <code>__dyld_start</code> 的实现。此函数由汇编实现，兼容各种平台架构，此处主要以arm64 架构下的汇编代码为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#if __arm64__</span><br><span class="line">	.data</span><br><span class="line">	.align 3</span><br><span class="line">__dso_static: </span><br><span class="line">	.quad   ___dso_handle</span><br><span class="line"></span><br><span class="line">	.text</span><br><span class="line">	.align 2</span><br><span class="line">	.globl __dyld_start</span><br><span class="line">__dyld_start:</span><br><span class="line">	mov 	x28, sp</span><br><span class="line">	and     sp, x28, #~15		&#x2F;&#x2F; force 16-byte alignment of stack</span><br><span class="line">	mov	x0, #0</span><br><span class="line">	mov	x1, #0</span><br><span class="line">	stp	x1, x0, [sp, #-16]!	&#x2F;&#x2F; make aligned terminating frame</span><br><span class="line">	mov	fp, sp			&#x2F;&#x2F; set up fp to point to terminating frame</span><br><span class="line">	sub	sp, sp, #16             &#x2F;&#x2F; make room for local variables</span><br><span class="line">	ldr     x0, [x28]		&#x2F;&#x2F; get app&#39;s mh into x0</span><br><span class="line"> 	ldr     x1, [x28, #8]           &#x2F;&#x2F; get argc into x1 (kernel passes 32-bit int argc as 64-bits on stack to keep alignment)</span><br><span class="line">	add     x2, x28, #16		&#x2F;&#x2F; get argv into x2</span><br><span class="line">	adrp	x4,___dso_handle@page</span><br><span class="line">	add 	x4,x4,___dso_handle@pageoff &#x2F;&#x2F; get dyld&#39;s mh in to x4</span><br><span class="line">	adrp	x3,__dso_static@page</span><br><span class="line">	ldr 	x3,[x3,__dso_static@pageoff] &#x2F;&#x2F; get unslid start of dyld</span><br><span class="line">	sub 	x3,x4,x3		&#x2F;&#x2F; x3 now has slide of dyld</span><br><span class="line">	mov	x5,sp                   &#x2F;&#x2F; x5 has &amp;startGlue</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">	bl	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br><span class="line">	mov	x16,x0                  &#x2F;&#x2F; save entry point address in x16</span><br><span class="line">	ldr     x1, [sp]</span><br><span class="line">	cmp	x1, #0</span><br><span class="line">	b.ne	Lnew</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; LC_UNIXTHREAD way, clean up stack and jump to result</span><br><span class="line">	add	sp, x28, #8		&#x2F;&#x2F; restore unaligned stack pointer without app mh</span><br><span class="line">	br	x16			&#x2F;&#x2F; jump to the program&#39;s entry point</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; LC_MAIN case, set up stack for call to main()</span><br><span class="line">Lnew:	mov	lr, x1		    &#x2F;&#x2F; simulate return address into _start in libdyld.dylib</span><br><span class="line">	ldr     x0, [x28, #8] 	    &#x2F;&#x2F; main param1 &#x3D; argc</span><br><span class="line">	add     x1, x28, #16	    &#x2F;&#x2F; main param2 &#x3D; argv</span><br><span class="line">	add	x2, x1, x0, lsl #3  </span><br><span class="line">	add	x2, x2, #8	    &#x2F;&#x2F; main param3 &#x3D; &amp;env[0]</span><br><span class="line">	mov	x3, x2</span><br><span class="line">Lapple:	ldr	x4, [x3]</span><br><span class="line">	add	x3, x3, #8</span><br><span class="line">	cmp	x4, #0</span><br><span class="line">	b.ne	Lapple		    &#x2F;&#x2F; main param4 &#x3D; apple</span><br><span class="line">	br	x16</span><br><span class="line"></span><br><span class="line">#endif &#x2F;&#x2F; __arm64__</span><br></pre></td></tr></table></figure>

<p>这里主要关注一下 <code>bl</code> 指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">bl	__ZN13dyldbootstrap5startEPK12macho_headeriPPKclS2_Pm</span><br></pre></td></tr></table></figure>

<p>从注释了解到，其实就是调用 <code>dyldbootstrap::start()</code> 函数。在 dyldInitialization.cpp 中可以找到 <code>start</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt.</span></span><br><span class="line"><span class="comment">//  In dyld we have to do this manually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">	<span class="keyword">if</span> ( slide != <span class="number">0</span> ) &#123;</span><br><span class="line">		rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">	mach_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld&#x27;s main</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">	<span class="keyword">return</span> dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>start</code> 函数中做了很多 dyld 初始化相关的工作，包括：</p>
<ul>
<li>rebaseDyld() dyld 重定位</li>
<li>mach_init() mach消息初始化</li>
<li>__guard_setup() 栈溢出保护</li>
</ul>
<p>初始化工作完成后，此函数调用到了 <code>dyld::_main</code>，再将返回值传递给 <code>__dyld_start</code> 去调用真正的 <code>main()</code> 函数。</p>
<p>我们可以在 dyld.cpp 中找到<code> _main</code> 的实现， 代码比较长，就不贴代码了，不过我们可以看看 <code>_main</code> 函数的注释:</p>
<blockquote>
<p>Entry point for dyld.  The kernel loads dyld and jumps to __dyld_start which sets up some registers and call this function.</p>
<p>Returns address of main() in target program which __dyld_start jumps to</p>
</blockquote>
<p>这个是说，内核加载 dyld，并跳转到 __dyld_start 函数，它主要设置一些寄存器，并且调用了 <code>_main</code>函数。这里刚好跟上面分析的过程相吻合。</p>
<p><code>dyld::_mina()</code> 是应用程序启动的关机函数，主要做了以下一些事情：</p>
<ol>
<li>设置运行环境</li>
<li>实例化主程序 </li>
<li>加载共享缓存</li>
<li>加载插入的动态库</li>
<li>链接主程序</li>
<li>链接插入的动态库</li>
<li>执行弱符合绑定</li>
<li>执行初始化方法</li>
<li>查找入口并返回</li>
</ol>
<h5 id="设置运行环境"><a href="#设置运行环境" class="headerlink" title="设置运行环境"></a>设置运行环境</h5><p>这一步主要是设置运行参数、环境变量等。代码在开始的时候，将入参<code>mainExecutableMH</code> 赋值给了<code>sMainExecutableMachHeader</code>，这是一个<code>macho_header</code> 结构体，表示的是当前主程序的 Mach-O 头部信息，加载器依据 Mach-O 头部信息就可以解析整个 Mach-O 文件信息。接着调用 <code>setContext()</code> 设置上下文信息，包括一些回调函数、参数、标志信息等。如 <code>loadLibrary()</code> 函数实际调用的是 <code>libraryLocator()</code>，负责加载动态库。代码片断如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(<span class="keyword">const</span> macho_header* mainExecutableMH, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gLinkContext.loadLibrary			= &amp;libraryLocator;</span><br><span class="line">    gLinkContext.terminationRecorder	= &amp;terminationRecorder;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实例化主程序"><a href="#实例化主程序" class="headerlink" title="实例化主程序"></a>实例化主程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instantiate ImageLoader for main executable</span></span><br><span class="line">sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br></pre></td></tr></table></figure>

<p>这一步将主程序的 Mach-O 加载进内存，并实例化一个 ImageLoader。<code>instantiateFromLoadedImage()</code> 首先调用 <code>isCompatibleMachO()</code> 检测Mach-O 头部的magic、cputype、cpusubtype 等相关属性，判断 Mach-O 文件的兼容性，如果兼容性满足，则调用<code>ImageLoaderMachO::instantiateMainExecutable()</code> 实例化主程序的ImageLoader，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The kernel maps in main executable before dyld gets control.  We need to </span></span><br><span class="line"><span class="comment">// make an ImageLoader* for the already mapped in main executable.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		addImage(image);</span><br><span class="line">		<span class="keyword">return</span> image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">&quot;main executable not a known format&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ImageLoaderMachO::instantiateMainExecutable()</code> 函数里面首先会调用<code>sniffLoadCommands()</code> 函数来获取一些数据，包括：</p>
<ul>
<li><strong>compressed</strong>：若Mach-O存在LC_DYLD_INFO和LC_DYLD_INFO_ONLY加载命令，则说明是压缩类型的Mach-O</li>
<li><strong>segCount</strong>：根据 LC_SEGMENT_COMMAND 加载命令来统计段数量。</li>
<li><strong>libCount</strong>：根据 LC_LOAD_DYLIB、LC_LOAD_WEAK_DYLIB、LC_REEXPORT_DYLIB、LC_LOAD_UPWARD_DYLIB 这几个加载命令来统计库的数量，库的数量不能超过4095个。</li>
<li><strong>codeSigCmd</strong>：通过解析LC_CODE_SIGNATURE来获取代码签名加载命令。</li>
<li><strong>encryptCmd</strong>：通过LC_ENCRYPTION_INFO和LC_ENCRYPTION_INFO_64来获取段的加密信息。</li>
</ul>
<p>ImageLoader 是抽象类，其子类负责把 Mach-O 文件实例化为 image，当<code>sniffLoadCommands()</code> 解析完以后，根据 <code>compressed</code> 的值来决定调用哪个子类进行实例化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( compressed ) </span><br><span class="line">    <span class="keyword">return</span> ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_CLASSIC_MACHO</span></span><br><span class="line">    <span class="keyword">return</span> ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable()</code> 执行完后，会调用 <code>addImage()</code> 函数将 image 加入到 <code>sAllImages</code> 全局镜像列表中。并将image映射到申请的内存中， 其代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addImage</span><span class="params">(ImageLoader* image)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// add to master list</span></span><br><span class="line">    allImagesLock();</span><br><span class="line">        sAllImages.push_back(image);</span><br><span class="line">    allImagesUnlock();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// update mapped ranges</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegStart = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uintptr_t</span> lastSegEnd = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>, e=image-&gt;segmentCount(); i &lt; e; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( image-&gt;segUnaccessible(i) ) </span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> start = image-&gt;segActualLoadAddress(i);</span><br><span class="line">		<span class="keyword">uintptr_t</span> end = image-&gt;segActualEndAddress(i);</span><br><span class="line">		<span class="keyword">if</span> ( start == lastSegEnd ) &#123;</span><br><span class="line">			<span class="comment">// two segments are contiguous, just record combined segments</span></span><br><span class="line">			lastSegEnd = end;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// non-contiguous segments, record last (if any)</span></span><br><span class="line">			<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">				addMappedRange(image, lastSegStart, lastSegEnd);</span><br><span class="line">			lastSegStart = start;</span><br><span class="line">			lastSegEnd = end;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( lastSegEnd != <span class="number">0</span> )</span><br><span class="line">		addMappedRange(image, lastSegStart, lastSegEnd);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_LIBRARIES || (sEnv.DYLD_PRINT_LIBRARIES_POST_LAUNCH &amp;&amp; (sMainExecutable!=<span class="literal">NULL</span>) &amp;&amp; sMainExecutable-&gt;isLinked()) ) &#123;</span><br><span class="line">		dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: loaded: %s\n&quot;</span>, image-&gt;getPath());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载共享缓存"><a href="#加载共享缓存" class="headerlink" title="加载共享缓存"></a>加载共享缓存</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load shared cache</span></span><br><span class="line">checkSharedRegionDisable();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_SHARED_CACHE_SUPPORT</span></span><br><span class="line"><span class="keyword">if</span> ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion )</span><br><span class="line">	mapSharedCache();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这一步先调用 <code>checkSharedRegionDisable()</code> 检查共享缓存是否禁用。该函数的iOS实现部分仅有一句注释，从注释我们可以推断iOS必须开启共享缓存才能正常工作。接下来调用 <code>mapSharedCache()</code> 来加载共享缓存。</p>
<h5 id="加载插入的动态库"><a href="#加载插入的动态库" class="headerlink" title="加载插入的动态库"></a>加载插入的动态库</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">        loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步是加载环境变量DYLD_INSERT_LIBRARIES中配置的动态库，先判断环境变量DYLD_INSERT_LIBRARIES中是否存在要加载的动态库，如果存在则调用 <code>loadInsertedDylib()</code> 依次加载。</p>
<p><code>loadInsertedDylib()</code> 内部设置了一个LoadContext 后，调用了 <code>load()</code> 函数。该函数内部调用的一系列的 loadPhase*。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try all path permutations and check against existing loaded images</span></span><br><span class="line">ImageLoader* image = loadPhase0(path, orgPath, context, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>大致会按照下图的顺序搜索动态库，并调用不同的函数来继续处理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/02.png"></p>
<p>当内部调用到 <code>loadPhase5load()</code> 函数的时候，会先在共享缓存中搜索，如果存在则调用 <code>ImageLoaderMachO::instantiateFromCache()</code>  来实例化ImageLoader，否则通过 <code>loadPhase5open()</code> 打开文件并读取数据到内存后，再调用 <code>loadPhase6()</code> ，通过 <code>ImageLoaderMachO::instantiateFromFile()</code>  来实例化 ImageLoader，最后调用 <code>checkandAddImage()</code> 验证镜像并将其加入到全局镜像列表中。</p>
<h5 id="链接主程序"><a href="#链接主程序" class="headerlink" title="链接主程序"></a>链接主程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link main executable</span></span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>

<p>这一步调用 <code>link()</code> 函数将实例化后的主程序进行动态修正，让二进制变为可正常执行的状态。<code>link()</code> 函数内部调用了<code>ImageLoader::link()</code> 函数，从源代码可以看到，这一步主要做了以下几个事情：</p>
<ul>
<li><code>recursiveLoadLibraries()</code> 加载所有依赖的库到内存。</li>
<li><code>recursiveUpdateDepth()</code> 递归刷新依赖库的层级。</li>
<li><code>recursiveRebase()</code> 由于ASLR的存在，必须递归对主程序以及依赖库进行重定位操作。</li>
<li><code>recursiveBind()</code>  把主程序二进制和依赖进来的动态库全部执行符号表绑定。</li>
<li><code>weakBind()</code> 如果链接的不是主程序二进制的话，会在此时执行弱符号绑定，主程序二进制则在link()完后再执行弱符号绑定。</li>
<li><code>context.registerDOFs(dofs)</code> 注册DOF（DTrace Object Format）。</li>
</ul>
<h5 id="链接插入的动态库"><a href="#链接插入的动态库" class="headerlink" title="链接插入的动态库"></a>链接插入的动态库</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// link any inserted libraries</span></span><br><span class="line"><span class="comment">// do this after linking main executable so that any dylibs pulled in by inserted </span></span><br><span class="line"><span class="comment">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">        ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">        link(image, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader::RPathChain(<span class="literal">NULL</span>, <span class="literal">NULL</span>));</span><br><span class="line">        image-&gt;setNeverUnloadRecursive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// only INSERTED libraries can interpose</span></span><br><span class="line">    <span class="comment">// register interposing info after all inserted libraries are bound so chaining works</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">        ImageLoader* image = sAllImages[i+<span class="number">1</span>];</span><br><span class="line">        image-&gt;registerInterposing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步与链接主程序一样，将前面调用 <code>addImage()</code> 函数保存在 <code>sAllImages</code> 中的动态库列表循环取出并调用 <code>link()</code> 进行链接，需要注意的是，<code>sAllImages</code> 中保存的第一项是主程序的镜像，所以要从 i+1的位置开始，取到的才是动态库的 ImageLoader。</p>
<p>接下来循环调用每个镜像的 <code>registerInterposing()</code> 函数，该函数会遍历Mach-O 的 LC_SEGMENT_COMMAND 加载命令，读取__DATA, __interpose，并将读取到的信息保存到 <code>fgInterposingTuples</code> 中。</p>
<h5 id="执行弱符合绑定"><a href="#执行弱符合绑定" class="headerlink" title="执行弱符合绑定"></a>执行弱符合绑定</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">sMainExecutable-&gt;weakBind(gLinkContext);</span><br></pre></td></tr></table></figure>

<p><code>weakBind()</code> 首先通过 <code>getCoalescedImages()</code> 合并所有动态库的弱符号到一个列表里，然后调用 <code>initializeCoalIterator()</code> 对需要绑定的弱符号进行排序，接着调用 <code>incrementCoalIterator()</code> 读取dyld_info_command 结构的 <code>weak_bind_off</code> 和 <code>weak_bind_size</code> 字段，确定弱符号的数据偏移与大小，最终进行弱符号绑定。</p>
<h5 id="执行初始化方法"><a href="#执行初始化方法" class="headerlink" title="执行初始化方法"></a>执行初始化方法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_OLD_CRT_INITIALIZATION</span></span><br><span class="line">    <span class="comment">// Old way is to run initializers via a callback from crt1.o</span></span><br><span class="line">    <span class="keyword">if</span> ( ! gRunInitializersOldWay ) </span><br><span class="line">        initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// run all initializers</span></span><br><span class="line">    initializeMainExecutable(); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这一步由 <code>initializeMainExecutable()</code> 完成。dyld 会优先初始化动态库，然后初始化主程序。该函数首先执行 <code>runInitializers()</code>，内部再依次调用 <code>processInitializers()</code>、<code>recursiveInitialization()</code>。在 <code>processInitializers()</code> 之后会发送 <code>dyld_image_state_initialized</code> 通知。</p>
<p>在 <code>recursiveInitialization()</code> 的实现中有这么一行代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>注释告诉我们，这个函数主要目的是让 objc 知道 image 即将被初始化。之后执行初始化操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize this image</span></span><br><span class="line"><span class="keyword">this</span>-&gt;doInitialization(context);</span><br></pre></td></tr></table></figure>

<p>在 <code>doInitialization()</code> 中首先调用了 <code>doImageInit()</code> ，然后调用 <code>doModInitFunctions()</code> 。</p>
<p><code>doImageInit</code> 执行镜像的初始化函数，也就是 LC_ROUTINES_COMMAND中记录的函数，然后再执行 <code>doModInitFunctions</code> 来解析并执行_DATA_ 中__mod_init_func 这个 section 中保存的函数。_mod_init_funcs 中保存的是全局C++对象的构造函数以及所有带 <code>__attribute__((constructor)</code> 的C函数。</p>
<p>可以简单的写几行代码验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((constructor))</span><br><span class="line">void init_test() &#123;</span><br><span class="line">    printf(&quot;init_test called&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static TestClass t;</span><br></pre></td></tr></table></figure>

<p>代码编译后可以使用 <a target="_blank" rel="noopener" href="https://sourceforge.net/projects/machoview/">MachOView</a>来查看 Mach-O 中的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/03.png"></p>
<p>可以看到 _mod_init_funcs 这个 section 中刚好有两个数据。</p>
<p>继续回到 <code>doInitialization()</code> 函数，在其实现中我们可以找到最终调用的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initializer func = (Initializer)(((struct macho_routines_command*)cmd)-&gt;init_address + fSlide);</span><br><span class="line"><span class="keyword">if</span> ( context.verboseInit )</span><br><span class="line">	dyld::<span class="built_in">log</span>(<span class="string">&quot;dyld: calling -init function 0x%p in %s\n&quot;</span>, func, <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">func(context.argc, context.argv, context.envp, context.apple, &amp;context.programVars);</span><br></pre></td></tr></table></figure>

<p><code>Initializer</code>  是一个指向初始化方法的函数指针，这里的初始化方法就是上面 __mod_init_func 这个 section 中保存的函数。</p>
<p>我们可以通过添加 DYLD_PRINT_INITIALIZERS 环境变量在打印程序中依赖库的 <code>initializer</code> 方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/04.png"></p>
<p>从打印中可以看到最先调用 libSystem.B.dylib 的 initializer :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**dyld: calling initializer function 0x7fff780ee94c in &#x2F;usr&#x2F;lib&#x2F;libSystem.B.dylib**</span><br></pre></td></tr></table></figure>

<p>可以从<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/Libsystem/Libsystem-169.3/init.c.auto.html">这里</a>找到 libSystem 的 initializer 的完整实现。这里截取了部分代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_libkernel_init(libkernel_funcs);</span><br><span class="line"></span><br><span class="line">bootstrap_init();</span><br><span class="line">mach_init();</span><br><span class="line">pthread_init();</span><br><span class="line">__libc_init(vars, libSystem_atfork_prepare, libSystem_atfork_parent, libSystem_atfork_child, apple);</span><br><span class="line">__keymgr_initializer();</span><br><span class="line">_dyld_initializer();</span><br><span class="line">libdispatch_init();</span><br></pre></td></tr></table></figure>

<p>这里我们只要关注一下 <code>libdispatch_init()</code> 函数。因为 <code>libdispatch_init()</code>  函数最终调用了 runtime 的初始化方法 <code>_objc_init</code>。我们可以打个符号断点来验证一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hujewelz/CDN-for-myblog/images/applaunch/05.png"></p>
<p>这里可以看到 <code>_objc_init</code> 调用的顺序，先 <code>libSystem_initializer</code> 调用 <code>libdispatch_init</code> 再到 <code>_objc_init</code> 初始化 runtime。</p>
<p>这样从<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/libdispatch/libdispatch-913.60.2/">这里</a>找到 <code>libdispatch_init()</code> 函数的实现。其中有这么几个函数调用： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_hw_config_init();</span><br><span class="line">_dispatch_time_init();</span><br><span class="line">_dispatch_vtable_init();</span><br><span class="line">_os_object_init();</span><br><span class="line">_voucher_init();</span><br><span class="line">_dispatch_introspection_init();</span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>_os_object_init()</code> 函数实现中发现确实调用了 <code>_objc_init()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_os_object_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 runtime 被初始化了。</p>
<h5 id="查找入口点并返回"><a href="#查找入口点并返回" class="headerlink" title="查找入口点并返回"></a>查找入口点并返回</h5><p>这一步调用主程序的 <code>getEntryFromLC_MAIN()</code>，从加载命令读取 LC_MAIN入口，如果没有 LC_MAIN 就调用 <code>getEntryFromLC_UNIXTHREAD()</code> 读取LC_UNIXTHREAD，找到后就跳到入口点指定的地址并返回。<br>至此，整个dyld的加载过程就完成了。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%8E%9F%E7%90%86-dyld/" rel="tag"># 原理 dyld</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/cko3zg8nc001s5ss624slhzd0/" rel="prev" title="开启 RxSwift 之旅——开篇">
      <i class="fa fa-chevron-left"></i> 开启 RxSwift 之旅——开篇
    </a></div>
      <div class="post-nav-item">
    <a href="/cko3zg8ni002b5ss69pklhb2h/" rel="next" title="用 Swift 写一个响应式编程库">
      用 Swift 写一个响应式编程库 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">设置运行环境</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">实例化主程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%85%B1%E4%BA%AB%E7%BC%93%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text">加载共享缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%8F%92%E5%85%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">加载插入的动态库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">链接主程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E6%8F%92%E5%85%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">链接插入的动态库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%BC%B1%E7%AC%A6%E5%90%88%E7%BB%91%E5%AE%9A"><span class="nav-number">7.</span> <span class="nav-text">执行弱符合绑定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">执行初始化方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E5%85%A5%E5%8F%A3%E7%82%B9%E5%B9%B6%E8%BF%94%E5%9B%9E"><span class="nav-number">9.</span> <span class="nav-text">查找入口点并返回</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jewelz Hu"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Jewelz Hu</p>
  <div class="site-description" itemprop="description">Stay hungry, Stay foolish.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hujewelz" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hujewelz" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hujewelz@gmail.com" title="E-Mail → mailto:hujewelz@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/huluoboboo" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;huluoboboo" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jewelz Hu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
